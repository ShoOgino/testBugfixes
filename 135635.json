{"path":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":null,"sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce83f0d72db4660fd277a9d357698004d8f4336","date":1269047368,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be20f9fed1d3edcb1c84abcc39df87a90fab22df","date":1275590285,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c","date":1281477834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    MockRAMDirectory dir = new MockRAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c","date":1281646583,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Random random = newRandom();\n    MockRAMDirectory dir = newDirectory(random);\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n      dir.close();\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    MockRAMDirectory dir = new MockRAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a05409176bd65129d67a785ee70e881e238a9aef","date":1282582843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Random random = newRandom();\n    Directory dir = newDirectory(random);\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Random random = newRandom();\n    MockRAMDirectory dir = newDirectory(random);\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n      dir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = newDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Random random = newRandom();\n    Directory dir = newDirectory(random);\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a897aed74aaf1975eb9bbaf2e11a470b285ca88b","date":1284311041,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = newDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","a78a90fc9701e511308346ea29f4f5e548bb39fe","a78a90fc9701e511308346ea29f4f5e548bb39fe","70052d44b40be0028db94b4cffeb9aaa5468055e","70052d44b40be0028db94b4cffeb9aaa5468055e","70052d44b40be0028db94b4cffeb9aaa5468055e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e8cc373c801e54cec75daf9f52792cb4b17f536","date":1291116159,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(ReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(ReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2047784e704fe141e0ff36affac8a7cb6c7bbec","date":1295352100,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE).\n              setMaxFieldLength(IndexWriterConfig.UNLIMITED_FIELD_LENGTH)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"090a0320e4de4a3674376aef96b9701f47564f86","date":1308707325,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    Directory dir = new RAMDirectory();\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f2 = new Field(\"f2\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(\n          dir,\n          new IndexWriterConfig(TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)).\n              setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n      );\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int v1EmptyPercent = 50;\n      int v2EmptyPercent = 50;\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        Document document = new Document();\n        if (r.nextInt(100) < v1EmptyPercent) {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          document.add(f);\n        }\n        if (r.nextInt(100) < v2EmptyPercent) {\n          mydoc.val2 = Integer.toString(r.nextInt(maxval));\n          f2.setValue(mydoc.val2);\n          document.add(f2);\n        }\n\n\n        iw.addDocument(document);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException {\n            return randSet(context.reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean luceneSort = r.nextBoolean();\n        final boolean sortMissingLast = !luceneSort && r.nextBoolean();\n        final boolean sortMissingFirst = !luceneSort && !sortMissingLast;\n        final boolean reverse = r.nextBoolean();\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        final boolean secondary = r.nextBoolean();\n        final boolean luceneSort2 = r.nextBoolean();\n        final boolean sortMissingLast2 = !luceneSort2 && r.nextBoolean();\n        final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;\n        final boolean reverse2 = r.nextBoolean();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, sortMissingFirst) );\n        if (secondary) {\n          sfields.add( Sorting.getStringSortField(\"f2\", reverse2, sortMissingLast2, sortMissingFirst2) );\n        }\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        final String nullRep = luceneSort || sortMissingFirst && !reverse || sortMissingLast && reverse ? \"\" : \"zzz\";\n        final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? \"\" : \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            topCollector.setNextReader(context);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            if (cmp != 0) return cmp;\n\n            if (secondary) {\n               v1 = o1.val2==null ? nullRep2 : o1.val2;\n               v2 = o2.val2==null ? nullRep2 : o2.val2;\n               cmp = v1.compareTo(v2);\n               if (reverse2) cmp = -cmp;\n            }\n\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          if (id != collectedDocs.get(j).doc) {\n            log.error(\"Error at pos \" + j\n            + \"\\n\\tsortMissingFirst=\" + sortMissingFirst + \" sortMissingLast=\" + sortMissingLast + \" reverse=\" + reverse\n            + \"\\n\\tEXPECTED=\" + collectedDocs \n            );\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n      searcher.close();\n    }\n    dir.close();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a897aed74aaf1975eb9bbaf2e11a470b285ca88b":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"c26f00b574427b55127e869b935845554afde1fa":["090a0320e4de4a3674376aef96b9701f47564f86","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["be20f9fed1d3edcb1c84abcc39df87a90fab22df","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c2047784e704fe141e0ff36affac8a7cb6c7bbec":["323f871ffe96b871d8c534a614be60751bb023c2"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["a05409176bd65129d67a785ee70e881e238a9aef"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["3bb13258feba31ab676502787ab2e1779f129b7a","c2047784e704fe141e0ff36affac8a7cb6c7bbec"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["4e8cc373c801e54cec75daf9f52792cb4b17f536"],"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a05409176bd65129d67a785ee70e881e238a9aef":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["9ce83f0d72db4660fd277a9d357698004d8f4336"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"323f871ffe96b871d8c534a614be60751bb023c2":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"2553b00f699380c64959ccb27991289aae87be2e":["c2047784e704fe141e0ff36affac8a7cb6c7bbec","090a0320e4de4a3674376aef96b9701f47564f86"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["c2047784e704fe141e0ff36affac8a7cb6c7bbec","090a0320e4de4a3674376aef96b9701f47564f86"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["868da859b43505d9d2a023bfeae6dd0c795f5295","c2047784e704fe141e0ff36affac8a7cb6c7bbec"],"090a0320e4de4a3674376aef96b9701f47564f86":["c2047784e704fe141e0ff36affac8a7cb6c7bbec"],"9ce83f0d72db4660fd277a9d357698004d8f4336":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["090a0320e4de4a3674376aef96b9701f47564f86"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","323f871ffe96b871d8c534a614be60751bb023c2"],"3bb13258feba31ab676502787ab2e1779f129b7a":["a897aed74aaf1975eb9bbaf2e11a470b285ca88b","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["a897aed74aaf1975eb9bbaf2e11a470b285ca88b"]},"commit2Childs":{"a897aed74aaf1975eb9bbaf2e11a470b285ca88b":["3bb13258feba31ab676502787ab2e1779f129b7a","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"1da8d55113b689b06716246649de6f62430f15c0":["9ce83f0d72db4660fd277a9d357698004d8f4336"],"c2047784e704fe141e0ff36affac8a7cb6c7bbec":["29ef99d61cda9641b6250bf9567329a6e65f901d","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","e79a6d080bdd5b2a8f56342cf571b5476de04180","090a0320e4de4a3674376aef96b9701f47564f86"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["a897aed74aaf1975eb9bbaf2e11a470b285ca88b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a05409176bd65129d67a785ee70e881e238a9aef":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"323f871ffe96b871d8c534a614be60751bb023c2":["c2047784e704fe141e0ff36affac8a7cb6c7bbec","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["a05409176bd65129d67a785ee70e881e238a9aef"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"e79a6d080bdd5b2a8f56342cf571b5476de04180":[],"090a0320e4de4a3674376aef96b9701f47564f86":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"9ce83f0d72db4660fd277a9d357698004d8f4336":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["323f871ffe96b871d8c534a614be60751bb023c2"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"3bb13258feba31ab676502787ab2e1779f129b7a":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","2dadf0f3286a34a0fee6e788ffce88624bf2984e","3bb13258feba31ab676502787ab2e1779f129b7a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","d083e83f225b11e5fdd900e83d26ddb385b6955c","e79a6d080bdd5b2a8f56342cf571b5476de04180","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}