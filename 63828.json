{"path":"lucene/test-framework/src/java/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","commits":[{"id":"b266fe0ac2172d4ad87cff12bd9bf9f8c8247345","date":1465936684,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","sourceNew":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0063 × 0061 × 006E × 0027 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u0027\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u0027\\u0074\" });\n\n    // ÷ 0063 × 0061 × 006E × 2019 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u2019\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u2019\\u0074\" });\n\n    // ÷ 0061 × 0062 × 00AD × 0062 × 0079 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] SOFT HYPHEN (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [5.0] LATIN SMALL LETTER Y (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0062\\u00AD\\u0062\\u0079\",\n                     new String[] { \"\\u0061\\u0062\\u00AD\\u0062\\u0079\" });\n\n    // ÷ 0061 ÷ 0024 ÷ 002D ÷ 0033 × 0034 × 002C × 0035 × 0036 × 0037 × 002E × 0031 × 0034 ÷ 0025 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] DOLLAR SIGN (Other) ÷ [999.0] HYPHEN-MINUS (Other) ÷ [999.0] DIGIT THREE (Numeric) × [8.0] DIGIT FOUR (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT FIVE (Numeric) × [8.0] DIGIT SIX (Numeric) × [8.0] DIGIT SEVEN (Numeric) × [12.0] FULL STOP (MidNumLet) × [11.0] DIGIT ONE (Numeric) × [8.0] DIGIT FOUR (Numeric) ÷ [999.0] PERCENT SIGN (Other) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0024\\u002D\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\\u0025\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\", \"\\u0062\" });\n\n    // ÷ 0033 × 0061 ÷  #  ÷ [0.2] DIGIT THREE (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0033\\u0061\",\n                     new String[] { \"\\u0033\\u0061\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 0027 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 2019 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 × 0062 × 2060 × 00AD × 2060 × 0062 × 2060 × 0079 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER Y (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 ÷ 0024 × 2060 ÷ 002D × 2060 ÷ 0033 × 2060 × 0034 × 2060 × 002C × 2060 × 0035 × 2060 × 0036 × 2060 × 0037 × 2060 × 002E × 2060 × 0031 × 2060 × 0034 × 2060 ÷ 0025 × 2060 ÷ 0062 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DOLLAR SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HYPHEN-MINUS (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] COMMA (MidNum) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT FIVE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SIX (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SEVEN (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] PERCENT SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0024\\u2060\\u002D\\u2060\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\\u0025\\u2060\\u0062\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\", \"\\u0062\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0033 × 2060 × 0061 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0033\\u2060\\u0061\\u2060\\u2060\",\n                     new String[] { \"\\u0033\\u2060\\u0061\\u2060\\u2060\" });\n\n    // ÷ 0061 ÷ 1F1E6 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0062\" });\n\n    // ÷ 1F1F7 × 1F1FA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA ÷ 200B ÷ 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [999.0] ZERO WIDTH SPACE (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\u200B\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 200D × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n  }\n\n","sourceOld":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0063 × 0061 × 006E × 0027 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u0027\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u0027\\u0074\" });\n\n    // ÷ 0063 × 0061 × 006E × 2019 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u2019\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u2019\\u0074\" });\n\n    // ÷ 0061 × 0062 × 00AD × 0062 × 0079 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] SOFT HYPHEN (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [5.0] LATIN SMALL LETTER Y (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0062\\u00AD\\u0062\\u0079\",\n                     new String[] { \"\\u0061\\u0062\\u00AD\\u0062\\u0079\" });\n\n    // ÷ 0061 ÷ 0024 ÷ 002D ÷ 0033 × 0034 × 002C × 0035 × 0036 × 0037 × 002E × 0031 × 0034 ÷ 0025 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] DOLLAR SIGN (Other) ÷ [999.0] HYPHEN-MINUS (Other) ÷ [999.0] DIGIT THREE (Numeric) × [8.0] DIGIT FOUR (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT FIVE (Numeric) × [8.0] DIGIT SIX (Numeric) × [8.0] DIGIT SEVEN (Numeric) × [12.0] FULL STOP (MidNumLet) × [11.0] DIGIT ONE (Numeric) × [8.0] DIGIT FOUR (Numeric) ÷ [999.0] PERCENT SIGN (Other) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0024\\u002D\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\\u0025\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\", \"\\u0062\" });\n\n    // ÷ 0033 × 0061 ÷  #  ÷ [0.2] DIGIT THREE (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0033\\u0061\",\n                     new String[] { \"\\u0033\\u0061\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 0027 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 2019 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 × 0062 × 2060 × 00AD × 2060 × 0062 × 2060 × 0079 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER Y (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 ÷ 0024 × 2060 ÷ 002D × 2060 ÷ 0033 × 2060 × 0034 × 2060 × 002C × 2060 × 0035 × 2060 × 0036 × 2060 × 0037 × 2060 × 002E × 2060 × 0031 × 2060 × 0034 × 2060 ÷ 0025 × 2060 ÷ 0062 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DOLLAR SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HYPHEN-MINUS (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] COMMA (MidNum) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT FIVE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SIX (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SEVEN (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] PERCENT SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0024\\u2060\\u002D\\u2060\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\\u0025\\u2060\\u0062\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\", \"\\u0062\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0033 × 2060 × 0061 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0033\\u2060\\u0061\\u2060\\u2060\",\n                     new String[] { \"\\u0033\\u2060\\u0061\\u2060\\u2060\" });\n\n    // ÷ 0061 ÷ 1F1E6 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0062\" });\n\n    // ÷ 1F1F7 × 1F1FA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA ÷ 200B ÷ 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [999.0] ZERO WIDTH SPACE (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\u200B\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 200D × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","sourceNew":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0063 × 0061 × 006E × 0027 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u0027\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u0027\\u0074\" });\n\n    // ÷ 0063 × 0061 × 006E × 2019 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u2019\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u2019\\u0074\" });\n\n    // ÷ 0061 × 0062 × 00AD × 0062 × 0079 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] SOFT HYPHEN (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [5.0] LATIN SMALL LETTER Y (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0062\\u00AD\\u0062\\u0079\",\n                     new String[] { \"\\u0061\\u0062\\u00AD\\u0062\\u0079\" });\n\n    // ÷ 0061 ÷ 0024 ÷ 002D ÷ 0033 × 0034 × 002C × 0035 × 0036 × 0037 × 002E × 0031 × 0034 ÷ 0025 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] DOLLAR SIGN (Other) ÷ [999.0] HYPHEN-MINUS (Other) ÷ [999.0] DIGIT THREE (Numeric) × [8.0] DIGIT FOUR (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT FIVE (Numeric) × [8.0] DIGIT SIX (Numeric) × [8.0] DIGIT SEVEN (Numeric) × [12.0] FULL STOP (MidNumLet) × [11.0] DIGIT ONE (Numeric) × [8.0] DIGIT FOUR (Numeric) ÷ [999.0] PERCENT SIGN (Other) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0024\\u002D\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\\u0025\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\", \"\\u0062\" });\n\n    // ÷ 0033 × 0061 ÷  #  ÷ [0.2] DIGIT THREE (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0033\\u0061\",\n                     new String[] { \"\\u0033\\u0061\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 0027 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 2019 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 × 0062 × 2060 × 00AD × 2060 × 0062 × 2060 × 0079 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER Y (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 ÷ 0024 × 2060 ÷ 002D × 2060 ÷ 0033 × 2060 × 0034 × 2060 × 002C × 2060 × 0035 × 2060 × 0036 × 2060 × 0037 × 2060 × 002E × 2060 × 0031 × 2060 × 0034 × 2060 ÷ 0025 × 2060 ÷ 0062 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DOLLAR SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HYPHEN-MINUS (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] COMMA (MidNum) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT FIVE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SIX (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SEVEN (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] PERCENT SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0024\\u2060\\u002D\\u2060\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\\u0025\\u2060\\u0062\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\", \"\\u0062\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0033 × 2060 × 0061 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0033\\u2060\\u0061\\u2060\\u2060\",\n                     new String[] { \"\\u0033\\u2060\\u0061\\u2060\\u2060\" });\n\n    // ÷ 0061 ÷ 1F1E6 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0062\" });\n\n    // ÷ 1F1F7 × 1F1FA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA ÷ 200B ÷ 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [999.0] ZERO WIDTH SPACE (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\u200B\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 200D × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n  }\n\n","sourceOld":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0063 × 0061 × 006E × 0027 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u0027\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u0027\\u0074\" });\n\n    // ÷ 0063 × 0061 × 006E × 2019 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u2019\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u2019\\u0074\" });\n\n    // ÷ 0061 × 0062 × 00AD × 0062 × 0079 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] SOFT HYPHEN (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [5.0] LATIN SMALL LETTER Y (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0062\\u00AD\\u0062\\u0079\",\n                     new String[] { \"\\u0061\\u0062\\u00AD\\u0062\\u0079\" });\n\n    // ÷ 0061 ÷ 0024 ÷ 002D ÷ 0033 × 0034 × 002C × 0035 × 0036 × 0037 × 002E × 0031 × 0034 ÷ 0025 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] DOLLAR SIGN (Other) ÷ [999.0] HYPHEN-MINUS (Other) ÷ [999.0] DIGIT THREE (Numeric) × [8.0] DIGIT FOUR (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT FIVE (Numeric) × [8.0] DIGIT SIX (Numeric) × [8.0] DIGIT SEVEN (Numeric) × [12.0] FULL STOP (MidNumLet) × [11.0] DIGIT ONE (Numeric) × [8.0] DIGIT FOUR (Numeric) ÷ [999.0] PERCENT SIGN (Other) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0024\\u002D\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\\u0025\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\", \"\\u0062\" });\n\n    // ÷ 0033 × 0061 ÷  #  ÷ [0.2] DIGIT THREE (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0033\\u0061\",\n                     new String[] { \"\\u0033\\u0061\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 0027 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 2019 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 × 0062 × 2060 × 00AD × 2060 × 0062 × 2060 × 0079 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER Y (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 ÷ 0024 × 2060 ÷ 002D × 2060 ÷ 0033 × 2060 × 0034 × 2060 × 002C × 2060 × 0035 × 2060 × 0036 × 2060 × 0037 × 2060 × 002E × 2060 × 0031 × 2060 × 0034 × 2060 ÷ 0025 × 2060 ÷ 0062 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DOLLAR SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HYPHEN-MINUS (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] COMMA (MidNum) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT FIVE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SIX (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SEVEN (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] PERCENT SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0024\\u2060\\u002D\\u2060\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\\u0025\\u2060\\u0062\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\", \"\\u0062\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0033 × 2060 × 0061 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0033\\u2060\\u0061\\u2060\\u2060\",\n                     new String[] { \"\\u0033\\u2060\\u0061\\u2060\\u2060\" });\n\n    // ÷ 0061 ÷ 1F1E6 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0062\" });\n\n    // ÷ 1F1F7 × 1F1FA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA ÷ 200B ÷ 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [999.0] ZERO WIDTH SPACE (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\u200B\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 200D × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8c6c25f6bab8e32b731127f3516a593af8a3305","date":1546972429,"type":5,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/standard/WordBreakTestUnicode_9_0_0#test(Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/standard/WordBreakTestUnicode_6_3_0#test(Analyzer).mjava","sourceNew":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 261D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0001 × 0308 ÷ 261D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0001 ÷ 1F3FB ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0001 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0001 ÷ 2764 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0001 × 0308 ÷ 2764 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0001 ÷ 1F466 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0001 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 200D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 200D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 261D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000D ÷ 0308 ÷ 261D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000D ÷ 1F3FB ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000D ÷ 0308 ÷ 1F3FB ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000D ÷ 2764 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000D ÷ 0308 ÷ 2764 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000D ÷ 1F466 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000D ÷ 0308 ÷ 1F466 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 200D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 200D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 261D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000A ÷ 0308 ÷ 261D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000A ÷ 1F3FB ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000A ÷ 0308 ÷ 1F3FB ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000A ÷ 2764 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000A ÷ 0308 ÷ 2764 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000A ÷ 1F466 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000A ÷ 0308 ÷ 1F466 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 200D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 200D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 261D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000B ÷ 0308 ÷ 261D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 000B ÷ 1F3FB ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000B ÷ 0308 ÷ 1F3FB ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 000B ÷ 2764 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000B ÷ 0308 ÷ 2764 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 000B ÷ 1F466 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000B ÷ 0308 ÷ 1F466 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 200D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 200D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 261D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u261D\",\n                     new String[] { \"\\u3031\", \"\\u261D\" });\n\n    // ÷ 3031 × 0308 ÷ 261D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u261D\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u261D\" });\n\n    // ÷ 3031 ÷ 1F3FB ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDFFB\",\n                     new String[] { \"\\u3031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 3031 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u3031\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 3031 ÷ 2764 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u2764\",\n                     new String[] { \"\\u3031\", \"\\u2764\" });\n\n    // ÷ 3031 × 0308 ÷ 2764 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u2764\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u2764\" });\n\n    // ÷ 3031 ÷ 1F466 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83D\\uDC66\",\n                     new String[] { \"\\u3031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 3031 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u3031\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 × 200D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u200D\",\n                     new String[] { \"\\u3031\\u200D\" });\n\n    // ÷ 3031 × 0308 × 200D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u200D\",\n                     new String[] { \"\\u3031\\u0308\\u200D\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 261D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u261D\",\n                     new String[] { \"\\u0041\", \"\\u261D\" });\n\n    // ÷ 0041 × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u261D\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u261D\" });\n\n    // ÷ 0041 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0041\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0041 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0041\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0041 ÷ 2764 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u2764\",\n                     new String[] { \"\\u0041\", \"\\u2764\" });\n\n    // ÷ 0041 × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u2764\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u2764\" });\n\n    // ÷ 0041 ÷ 1F466 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83D\\uDC66\",\n                     new String[] { \"\\u0041\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0041 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0041\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 200D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u200D\",\n                     new String[] { \"\\u0041\\u200D\" });\n\n    // ÷ 0041 × 0308 × 200D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u200D\",\n                     new String[] { \"\\u0041\\u0308\\u200D\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 261D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 003A × 0308 ÷ 261D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 003A ÷ 1F3FB ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 003A × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 003A ÷ 2764 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 003A × 0308 ÷ 2764 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 003A ÷ 1F466 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 003A × 0308 ÷ 1F466 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 200D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u200D\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 200D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 261D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 002C × 0308 ÷ 261D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 002C ÷ 1F3FB ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 002C × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 002C ÷ 2764 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 002C × 0308 ÷ 2764 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 002C ÷ 1F466 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 002C × 0308 ÷ 1F466 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 200D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u200D\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 200D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 261D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 002E × 0308 ÷ 261D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 002E ÷ 1F3FB ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 002E × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 002E ÷ 2764 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 002E × 0308 ÷ 2764 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 002E ÷ 1F466 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 002E × 0308 ÷ 1F466 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 200D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u200D\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 200D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 261D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u261D\",\n                     new String[] { \"\\u0030\", \"\\u261D\" });\n\n    // ÷ 0030 × 0308 ÷ 261D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u261D\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u261D\" });\n\n    // ÷ 0030 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0030\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0030 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0030\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0030 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u2764\",\n                     new String[] { \"\\u0030\", \"\\u2764\" });\n\n    // ÷ 0030 × 0308 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u2764\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u2764\" });\n\n    // ÷ 0030 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83D\\uDC66\",\n                     new String[] { \"\\u0030\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0030 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0030\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 200D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u200D\",\n                     new String[] { \"\\u0030\\u200D\" });\n\n    // ÷ 0030 × 0308 × 200D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u200D\",\n                     new String[] { \"\\u0030\\u0308\\u200D\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 261D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 005F × 0308 ÷ 261D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 005F ÷ 1F3FB ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 005F × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 005F ÷ 2764 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 005F × 0308 ÷ 2764 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 005F ÷ 1F466 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 005F × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 200D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u200D\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 200D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [15.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83C\\uDDE6\\uD83C\\uDDE6\" });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) × [15.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\" });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 261D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 261D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 1F1E6 ÷ 1F3FB ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F1E6 ÷ 2764 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 2764 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 1F1E6 ÷ 1F466 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 200D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 ÷ 261D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u261D\",\n                     new String[] { \"\\u05D0\", \"\\u261D\" });\n\n    // ÷ 05D0 × 0308 ÷ 261D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u261D\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u261D\" });\n\n    // ÷ 05D0 ÷ 1F3FB ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDFFB\",\n                     new String[] { \"\\u05D0\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 05D0 ÷ 2764 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u2764\",\n                     new String[] { \"\\u05D0\", \"\\u2764\" });\n\n    // ÷ 05D0 × 0308 ÷ 2764 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u2764\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u2764\" });\n\n    // ÷ 05D0 ÷ 1F466 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83D\\uDC66\",\n                     new String[] { \"\\u05D0\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 200D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u200D\",\n                     new String[] { \"\\u05D0\\u200D\" });\n\n    // ÷ 05D0 × 0308 × 200D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u200D\",\n                     new String[] { \"\\u05D0\\u0308\\u200D\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 261D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0022 × 0308 ÷ 261D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0022 ÷ 1F3FB ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0022 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0022 ÷ 2764 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0022 × 0308 ÷ 2764 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0022 ÷ 1F466 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0022 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 200D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 200D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 261D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0027 × 0308 ÷ 261D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0027 ÷ 1F3FB ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0027 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0027 ÷ 2764 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0027 × 0308 ÷ 2764 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0027 ÷ 1F466 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0027 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 200D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 200D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 261D ÷ 0001 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0001\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 0001 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0001\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 000D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\r\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 000D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\r\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 000A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\n\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 000A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\n\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 000B ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u000B\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 000B ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u000B\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 3031 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u3031\",\n                     new String[] { \"\\u261D\", \"\\u3031\" });\n\n    // ÷ 261D × 0308 ÷ 3031 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u3031\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u3031\" });\n\n    // ÷ 261D ÷ 0041 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0041\",\n                     new String[] { \"\\u261D\", \"\\u0041\" });\n\n    // ÷ 261D × 0308 ÷ 0041 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0041\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0041\" });\n\n    // ÷ 261D ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u003A\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u003A\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u002C\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u002C\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 002E ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u002E\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 002E ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u002E\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 0030 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0030\",\n                     new String[] { \"\\u261D\", \"\\u0030\" });\n\n    // ÷ 261D × 0308 ÷ 0030 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0030\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0030\" });\n\n    // ÷ 261D ÷ 005F ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u005F\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 005F ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u005F\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 1F1E6 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\uD83C\\uDDE6\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 05D0 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u05D0\",\n                     new String[] { \"\\u261D\", \"\\u05D0\" });\n\n    // ÷ 261D × 0308 ÷ 05D0 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u05D0\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u05D0\" });\n\n    // ÷ 261D ÷ 0022 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\\"\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 0022 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\\"\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0027\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0027\",\n                     new String[] { \"\\u261D\\u0308\" });\n\n    // ÷ 261D ÷ 261D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u261D\",\n                     new String[] { \"\\u261D\", \"\\u261D\" });\n\n    // ÷ 261D × 0308 ÷ 261D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u261D\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u261D\" });\n\n    // ÷ 261D × 1F3FB ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\uD83C\\uDFFB\",\n                     new String[] { \"\\u261D\\uD83C\\uDFFB\" });\n\n    // ÷ 261D × 0308 × 1F3FB ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u261D\\u0308\\uD83C\\uDFFB\" });\n\n    // ÷ 261D ÷ 2764 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u2764\",\n                     new String[] { \"\\u261D\", \"\\u2764\" });\n\n    // ÷ 261D × 0308 ÷ 2764 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u2764\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u2764\" });\n\n    // ÷ 261D ÷ 1F466 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\uD83D\\uDC66\",\n                     new String[] { \"\\u261D\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 261D × 0308 ÷ 1F466 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u261D\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 261D × 00AD ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u00AD\",\n                     new String[] { \"\\u261D\\u00AD\" });\n\n    // ÷ 261D × 0308 × 00AD ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u00AD\",\n                     new String[] { \"\\u261D\\u0308\\u00AD\" });\n\n    // ÷ 261D × 0300 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0300\",\n                     new String[] { \"\\u261D\\u0300\" });\n\n    // ÷ 261D × 0308 × 0300 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0300\",\n                     new String[] { \"\\u261D\\u0308\\u0300\" });\n\n    // ÷ 261D × 200D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u200D\",\n                     new String[] { \"\\u261D\\u200D\" });\n\n    // ÷ 261D × 0308 × 200D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u200D\",\n                     new String[] { \"\\u261D\\u0308\\u200D\" });\n\n    // ÷ 261D ÷ 0061 × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0061\\u2060\",\n                     new String[] { \"\\u261D\", \"\\u0061\\u2060\" });\n\n    // ÷ 261D × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 261D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0061\\u003A\",\n                     new String[] { \"\\u261D\", \"\\u0061\" });\n\n    // ÷ 261D × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0061\" });\n\n    // ÷ 261D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0061\\u0027\",\n                     new String[] { \"\\u261D\", \"\\u0061\" });\n\n    // ÷ 261D × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0061\" });\n\n    // ÷ 261D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u261D\", \"\\u0061\" });\n\n    // ÷ 261D × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0061\" });\n\n    // ÷ 261D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0061\\u002C\",\n                     new String[] { \"\\u261D\", \"\\u0061\" });\n\n    // ÷ 261D × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0061\" });\n\n    // ÷ 261D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0031\\u003A\",\n                     new String[] { \"\\u261D\", \"\\u0031\" });\n\n    // ÷ 261D × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0031\" });\n\n    // ÷ 261D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0031\\u0027\",\n                     new String[] { \"\\u261D\", \"\\u0031\" });\n\n    // ÷ 261D × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0031\" });\n\n    // ÷ 261D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0031\\u002C\",\n                     new String[] { \"\\u261D\", \"\\u0031\" });\n\n    // ÷ 261D × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0031\" });\n\n    // ÷ 261D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u261D\", \"\\u0031\" });\n\n    // ÷ 261D × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u261D\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F3FB ÷ 0001 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0001\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0001 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0001\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 000D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\r\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 000D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\r\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 000A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\n\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 000A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\n\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 000B ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u000B\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 000B ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u000B\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 3031 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u3031\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u3031\" });\n\n    // ÷ 1F3FB × 0308 ÷ 3031 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u3031\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u3031\" });\n\n    // ÷ 1F3FB ÷ 0041 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0041\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0041\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0041 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0041\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0041\" });\n\n    // ÷ 1F3FB ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 002E ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u002E\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 002E ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u002E\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 0030 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0030\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0030\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0030 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0030\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0030\" });\n\n    // ÷ 1F3FB ÷ 005F ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u005F\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 005F ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u005F\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 1F1E6 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 05D0 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u05D0\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u05D0\" });\n\n    // ÷ 1F3FB × 0308 ÷ 05D0 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u05D0\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u05D0\" });\n\n    // ÷ 1F3FB ÷ 0022 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\\"\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0022 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\\"\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\" });\n\n    // ÷ 1F3FB ÷ 261D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u261D\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u261D\" });\n\n    // ÷ 1F3FB × 0308 ÷ 261D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u261D\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u261D\" });\n\n    // ÷ 1F3FB ÷ 1F3FB ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 1F3FB ÷ 2764 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u2764\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u2764\" });\n\n    // ÷ 1F3FB × 0308 ÷ 2764 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u2764\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u2764\" });\n\n    // ÷ 1F3FB ÷ 1F466 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F3FB × 0308 ÷ 1F466 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F3FB × 00AD ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u00AD\",\n                     new String[] { \"\\uD83C\\uDFFB\\u00AD\" });\n\n    // ÷ 1F3FB × 0308 × 00AD ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u00AD\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\\u00AD\" });\n\n    // ÷ 1F3FB × 0300 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0300\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0300\" });\n\n    // ÷ 1F3FB × 0308 × 0300 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0300\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\\u0300\" });\n\n    // ÷ 1F3FB × 200D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u200D\",\n                     new String[] { \"\\uD83C\\uDFFB\\u200D\" });\n\n    // ÷ 1F3FB × 0308 × 200D ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u200D\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\\u200D\" });\n\n    // ÷ 1F3FB ÷ 0061 × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0061\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0061\\u2060\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 1F3FB ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0061\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0061\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F3FB ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0061\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0061\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F3FB ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0061\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F3FB ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0061\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0061\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F3FB ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0031\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0031\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F3FB ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0031\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0031\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F3FB ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0031\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0031\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F3FB ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\", \"\\u0031\" });\n\n    // ÷ 1F3FB × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDFFB\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\uD83C\\uDFFB\\u0308\", \"\\u0031\" });\n\n    // ÷ 2764 ÷ 0001 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0001\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0001\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 000D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\r\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\r\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 000A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\n\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\n\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 000B ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u000B\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u000B\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 3031 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u3031\",\n                     new String[] { \"\\u2764\", \"\\u3031\" });\n\n    // ÷ 2764 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u3031\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u3031\" });\n\n    // ÷ 2764 ÷ 0041 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0041\",\n                     new String[] { \"\\u2764\", \"\\u0041\" });\n\n    // ÷ 2764 × 0308 ÷ 0041 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0041\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0041\" });\n\n    // ÷ 2764 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u003A\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u003A\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u002C\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u002C\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 002E ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u002E\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u002E\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 0030 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0030\",\n                     new String[] { \"\\u2764\", \"\\u0030\" });\n\n    // ÷ 2764 × 0308 ÷ 0030 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0030\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0030\" });\n\n    // ÷ 2764 ÷ 005F ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u005F\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 005F ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u005F\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 1F1E6 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\uD83C\\uDDE6\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 05D0 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u05D0\",\n                     new String[] { \"\\u2764\", \"\\u05D0\" });\n\n    // ÷ 2764 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u05D0\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u05D0\" });\n\n    // ÷ 2764 ÷ 0022 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\\"\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\\"\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0027\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0027\",\n                     new String[] { \"\\u2764\\u0308\" });\n\n    // ÷ 2764 ÷ 261D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u261D\",\n                     new String[] { \"\\u2764\", \"\\u261D\" });\n\n    // ÷ 2764 × 0308 ÷ 261D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u261D\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u261D\" });\n\n    // ÷ 2764 ÷ 1F3FB ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\uD83C\\uDFFB\",\n                     new String[] { \"\\u2764\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 2764 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u2764\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 2764 ÷ 2764 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u2764\",\n                     new String[] { \"\\u2764\", \"\\u2764\" });\n\n    // ÷ 2764 × 0308 ÷ 2764 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u2764\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u2764\" });\n\n    // ÷ 2764 ÷ 1F466 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\uD83D\\uDC66\",\n                     new String[] { \"\\u2764\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 2764 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u2764\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 2764 × 00AD ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u00AD\",\n                     new String[] { \"\\u2764\\u00AD\" });\n\n    // ÷ 2764 × 0308 × 00AD ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u00AD\",\n                     new String[] { \"\\u2764\\u0308\\u00AD\" });\n\n    // ÷ 2764 × 0300 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0300\",\n                     new String[] { \"\\u2764\\u0300\" });\n\n    // ÷ 2764 × 0308 × 0300 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0300\",\n                     new String[] { \"\\u2764\\u0308\\u0300\" });\n\n    // ÷ 2764 × 200D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u200D\",\n                     new String[] { \"\\u2764\\u200D\" });\n\n    // ÷ 2764 × 0308 × 200D ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u200D\",\n                     new String[] { \"\\u2764\\u0308\\u200D\" });\n\n    // ÷ 2764 ÷ 0061 × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0061\\u2060\",\n                     new String[] { \"\\u2764\", \"\\u0061\\u2060\" });\n\n    // ÷ 2764 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 2764 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0061\\u003A\",\n                     new String[] { \"\\u2764\", \"\\u0061\" });\n\n    // ÷ 2764 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0061\" });\n\n    // ÷ 2764 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0061\\u0027\",\n                     new String[] { \"\\u2764\", \"\\u0061\" });\n\n    // ÷ 2764 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0061\" });\n\n    // ÷ 2764 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u2764\", \"\\u0061\" });\n\n    // ÷ 2764 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0061\" });\n\n    // ÷ 2764 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0061\\u002C\",\n                     new String[] { \"\\u2764\", \"\\u0061\" });\n\n    // ÷ 2764 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0061\" });\n\n    // ÷ 2764 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0031\\u003A\",\n                     new String[] { \"\\u2764\", \"\\u0031\" });\n\n    // ÷ 2764 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0031\" });\n\n    // ÷ 2764 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0031\\u0027\",\n                     new String[] { \"\\u2764\", \"\\u0031\" });\n\n    // ÷ 2764 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0031\" });\n\n    // ÷ 2764 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0031\\u002C\",\n                     new String[] { \"\\u2764\", \"\\u0031\" });\n\n    // ÷ 2764 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0031\" });\n\n    // ÷ 2764 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u2764\", \"\\u0031\" });\n\n    // ÷ 2764 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEAVY BLACK HEART (Glue_After_Zwj) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2764\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u2764\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F466 ÷ 0001 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0001\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 0001 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0001\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 000D ÷  #  ÷ [0.2] BOY (EBG) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\r\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 000D ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\r\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 000A ÷  #  ÷ [0.2] BOY (EBG) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\n\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 000A ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\n\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 000B ÷  #  ÷ [0.2] BOY (EBG) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u000B\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 000B ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u000B\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 3031 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u3031\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u3031\" });\n\n    // ÷ 1F466 × 0308 ÷ 3031 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u3031\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u3031\" });\n\n    // ÷ 1F466 ÷ 0041 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0041\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0041\" });\n\n    // ÷ 1F466 × 0308 ÷ 0041 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0041\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0041\" });\n\n    // ÷ 1F466 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 002E ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u002E\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 002E ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u002E\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 0030 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0030\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0030\" });\n\n    // ÷ 1F466 × 0308 ÷ 0030 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0030\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0030\" });\n\n    // ÷ 1F466 ÷ 005F ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u005F\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 005F ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u005F\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 1F1E6 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 05D0 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u05D0\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u05D0\" });\n\n    // ÷ 1F466 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u05D0\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u05D0\" });\n\n    // ÷ 1F466 ÷ 0022 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\\"\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 0022 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\\"\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\" });\n\n    // ÷ 1F466 ÷ 261D ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u261D\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u261D\" });\n\n    // ÷ 1F466 × 0308 ÷ 261D ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u261D\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u261D\" });\n\n    // ÷ 1F466 × 1F3FB ÷  #  ÷ [0.2] BOY (EBG) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83D\\uDC66\\uD83C\\uDFFB\" });\n\n    // ÷ 1F466 × 0308 × 1F3FB ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\\uD83C\\uDFFB\" });\n\n    // ÷ 1F466 ÷ 2764 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u2764\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u2764\" });\n\n    // ÷ 1F466 × 0308 ÷ 2764 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u2764\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u2764\" });\n\n    // ÷ 1F466 ÷ 1F466 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 × 00AD ÷  #  ÷ [0.2] BOY (EBG) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u00AD\",\n                     new String[] { \"\\uD83D\\uDC66\\u00AD\" });\n\n    // ÷ 1F466 × 0308 × 00AD ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u00AD\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\\u00AD\" });\n\n    // ÷ 1F466 × 0300 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0300\",\n                     new String[] { \"\\uD83D\\uDC66\\u0300\" });\n\n    // ÷ 1F466 × 0308 × 0300 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0300\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\\u0300\" });\n\n    // ÷ 1F466 × 200D ÷  #  ÷ [0.2] BOY (EBG) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u200D\",\n                     new String[] { \"\\uD83D\\uDC66\\u200D\" });\n\n    // ÷ 1F466 × 0308 × 200D ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u200D\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\\u200D\" });\n\n    // ÷ 1F466 ÷ 0061 × 2060 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0061\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0061\\u2060\" });\n\n    // ÷ 1F466 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 1F466 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0061\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0061\" });\n\n    // ÷ 1F466 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F466 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0061\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0061\" });\n\n    // ÷ 1F466 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F466 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0061\" });\n\n    // ÷ 1F466 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F466 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0061\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0061\" });\n\n    // ÷ 1F466 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0061\" });\n\n    // ÷ 1F466 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0031\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0031\" });\n\n    // ÷ 1F466 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F466 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0031\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0031\" });\n\n    // ÷ 1F466 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F466 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0031\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0031\" });\n\n    // ÷ 1F466 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0031\" });\n\n    // ÷ 1F466 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\u0031\" });\n\n    // ÷ 1F466 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] BOY (EBG) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\uD83D\\uDC66\\u0308\", \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 261D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 00AD × 0308 ÷ 261D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 00AD ÷ 1F3FB ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 00AD × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 00AD ÷ 2764 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 00AD × 0308 ÷ 2764 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 00AD ÷ 1F466 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 00AD × 0308 ÷ 1F466 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 200D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u200D\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 200D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 261D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0300 × 0308 ÷ 261D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 0300 ÷ 1F3FB ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0300 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0300 ÷ 2764 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0300 × 0308 ÷ 2764 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 0300 ÷ 1F466 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0300 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 200D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 200D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D ÷ 0001 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0001\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 0001 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 000D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\r\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 000D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 000A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\n\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 000A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 000B ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u000B\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 000B ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 3031 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 200D × 0308 ÷ 3031 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 200D ÷ 0041 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 200D × 0308 ÷ 0041 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 200D ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u003A\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u002C\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 002E ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u002E\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 002E ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 0030 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 200D × 0308 ÷ 0030 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 200D ÷ 005F ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u005F\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 005F ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 1F1E6 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 05D0 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 200D × 0308 ÷ 05D0 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 200D ÷ 0022 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\\"\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 0022 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0027\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 261D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    // Skipping this test because it conflicts with TR#51 v11.0 rules.\n\n    // ÷ 200D × 0308 ÷ 261D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u261D\",\n                     new String[] { \"\\u261D\" });\n\n    // ÷ 200D ÷ 1F3FB ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 200D × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83C\\uDFFB\" });\n\n    // ÷ 200D × 2764 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [3.3] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u2764\",\n                     new String[] { \"\\u200D\\u2764\" });\n\n    // ÷ 200D × 0308 ÷ 2764 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u2764\",\n                     new String[] { \"\\u2764\" });\n\n    // ÷ 200D × 1F466 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [3.3] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\uD83D\\uDC66\",\n                     new String[] { \"\\u200D\\uD83D\\uDC66\" });\n\n    // ÷ 200D × 0308 ÷ 1F466 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\" });\n\n    // ÷ 200D × 00AD ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 × 00AD ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 200D × 0300 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0300\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 × 0300 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 200D × 200D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u200D\",\n                     new String[] {  });\n\n    // ÷ 200D × 0308 × 200D ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u200D\",\n                     new String[] {  });\n\n    // ÷ 200D ÷ 0061 × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 200D × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 200D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 200D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 200D × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u261D\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u261D\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u261D\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u261D\" });\n\n    // ÷ 0061 × 2060 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\\u2060\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 × 2060 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u2764\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u2764\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u2764\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u2764\" });\n\n    // ÷ 0061 × 2060 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\\u2060\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u200D\",\n                     new String[] { \"\\u0061\\u2060\\u200D\" });\n\n    // ÷ 0061 × 2060 × 0308 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u200D\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u200D\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 003A ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 261D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u261D\",\n                     new String[] { \"\\u0061\", \"\\u261D\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0061 ÷ 002C ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 2764 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u2764\",\n                     new String[] { \"\\u0061\", \"\\u2764\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F466 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0061\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 200D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u200D\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 003A ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 002C ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 261D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u261D\",\n                     new String[] { \"\\u0031\", \"\\u261D\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F3FB ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDFFB\",\n                     new String[] { \"\\u0031\", \"\\uD83C\\uDFFB\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 2764 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u2764\",\n                     new String[] { \"\\u0031\", \"\\u2764\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F466 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83D\\uDC66\",\n                     new String[] { \"\\u0031\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 200D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u200D\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 000D × 000A ÷ 0061 ÷ 000A ÷ 0308 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\\u0061\\n\\u0308\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0308 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0308\",\n                     new String[] { \"\\u0061\\u0308\" });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n    // ÷ 0041 × 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\\u0041\" });\n\n    // ÷ 0041 × 003A × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\\u0041\",\n                     new String[] { \"\\u0041\\u003A\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\\u003A\\u0041\",\n                     new String[] { \"\\u0041\", \"\\u0041\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0022 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.2] QUOTATION MARK (Double_Quote) × [7.3] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\\\"\\u05D0\" });\n\n    // ÷ 0041 × 0030 × 0030 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\\u0030\\u0041\",\n                     new String[] { \"\\u0041\\u0030\\u0030\\u0041\" });\n\n    // ÷ 0030 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\\u0030\",\n                     new String[] { \"\\u0030\\u002C\\u0030\" });\n\n    // ÷ 0030 ÷ 002C ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\\u002C\\u0030\",\n                     new String[] { \"\\u0030\", \"\\u0030\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 0041 × 005F × 0030 × 005F × 3031 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\\u0030\\u005F\\u3031\\u005F\",\n                     new String[] { \"\\u0041\\u005F\\u0030\\u005F\\u3031\\u005F\" });\n\n    // ÷ 0041 × 005F × 005F × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\\u005F\\u0041\",\n                     new String[] { \"\\u0041\\u005F\\u005F\\u0041\" });\n\n    // ÷ 1F1E6 × 1F1E7 ÷ 1F1E8 ÷ 0062 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [15.0] REGIONAL INDICATOR SYMBOL LETTER B (RI) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER C (RI) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\\u0062\",\n                     new String[] { \"\\uD83C\\uDDE6\\uD83C\\uDDE7\", \"\\u0062\" });\n\n    // ÷ 0061 ÷ 1F1E6 × 1F1E7 ÷ 1F1E8 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [16.0] REGIONAL INDICATOR SYMBOL LETTER B (RI) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER C (RI) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\\u0062\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDDE6\\uD83C\\uDDE7\", \"\\u0062\" });\n\n    // ÷ 0061 ÷ 1F1E6 × 1F1E7 × 200D ÷ 1F1E8 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [16.0] REGIONAL INDICATOR SYMBOL LETTER B (RI) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER C (RI) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\\u0062\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\", \"\\u0062\" });\n\n    // ÷ 0061 ÷ 1F1E6 × 200D × 1F1E7 ÷ 1F1E8 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) × [16.0] REGIONAL INDICATOR SYMBOL LETTER B (RI) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER C (RI) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\\u0062\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\", \"\\u0062\" });\n\n    // ÷ 0061 ÷ 1F1E6 × 1F1E7 ÷ 1F1E8 × 1F1E9 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (RI) × [16.0] REGIONAL INDICATOR SYMBOL LETTER B (RI) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER C (RI) × [16.0] REGIONAL INDICATOR SYMBOL LETTER D (RI) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\\uD83C\\uDDE9\\u0062\",\n                     new String[] { \"\\u0061\", \"\\uD83C\\uDDE6\\uD83C\\uDDE7\", \"\\uD83C\\uDDE8\\uD83C\\uDDE9\", \"\\u0062\" });\n\n    // ÷ 261D × 1F3FB ÷ 261D ÷  #  ÷ [0.2] WHITE UP POINTING INDEX (E_Base) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [999.0] WHITE UP POINTING INDEX (E_Base) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u261D\\uD83C\\uDFFB\\u261D\",\n                     new String[] { \"\\u261D\\uD83C\\uDFFB\", \"\\u261D\" });\n\n    // ÷ 1F466 × 1F3FB ÷  #  ÷ [0.2] BOY (EBG) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\uD83C\\uDFFB\",\n                     new String[] { \"\\uD83D\\uDC66\\uD83C\\uDFFB\" });\n\n    // ÷ 200D × 1F466 × 1F3FB ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [3.3] BOY (EBG) × [14.0] EMOJI MODIFIER FITZPATRICK TYPE-1-2 (E_Modifier) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\uD83D\\uDC66\\uD83C\\uDFFB\",\n                     new String[] { \"\\u200D\\uD83D\\uDC66\\uD83C\\uDFFB\" });\n\n    // ÷ 200D × 2764 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [3.3] HEAVY BLACK HEART (Glue_After_Zwj) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\u2764\",\n                     new String[] { \"\\u200D\\u2764\" });\n\n    // ÷ 200D × 1F466 ÷  #  ÷ [0.2] ZERO WIDTH JOINER (ZWJ_FE) × [3.3] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u200D\\uD83D\\uDC66\",\n                     new String[] { \"\\u200D\\uD83D\\uDC66\" });\n\n    // ÷ 1F466 ÷ 1F466 ÷  #  ÷ [0.2] BOY (EBG) ÷ [999.0] BOY (EBG) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83D\\uDC66\\uD83D\\uDC66\",\n                     new String[] { \"\\uD83D\\uDC66\", \"\\uD83D\\uDC66\" });\n\n    // ÷ 0061 × 0308 × 200D × 0308 × 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] ZERO WIDTH JOINER (ZWJ_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0308\\u200D\\u0308\\u0062\",\n                     new String[] { \"\\u0061\\u0308\\u200D\\u0308\\u0062\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0031 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0031\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 005F × 0061 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u005F\\u0061\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0031\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 003A ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u003A\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002E ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002E\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 003A ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u003A\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 003A ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u003A\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 002E ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u002E\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 002E ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u002E\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0031\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 002C ÷ 0031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u002C\\u0031\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0031 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0031\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0031\", \"\\u0061\" });\n\n    // ÷ 0061 × 005F × 0061 ÷ 002C ÷ 002C ÷ 0061 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u005F\\u0061\\u002C\\u002C\\u0061\",\n                     new String[] { \"\\u0061\\u005F\\u0061\", \"\\u0061\" });\n\n  }\n\n","sourceOld":"  public void test(Analyzer analyzer) throws Exception {\n    // ÷ 0001 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0001 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000D ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 000B ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 × 0308 ÷ 3031 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0001 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 × 0308 ÷ 0041 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0001 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 002E ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 × 0308 ÷ 0030 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0001 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 005F ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0001 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0022 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0001 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 00AD ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 × 0308 × 0300 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0001 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0001 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <START OF HEADING> (Other) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0001\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\r\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000D × 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) × [3.0] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000D ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000D ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000D ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000D ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 00AD ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0308 × 0300 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000D ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000D ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000D ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000D ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <CARRIAGE RETURN (CR)> (CR) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\r\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000A ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000A ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000A ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000A ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000A ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000A ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE FEED (LF)> (LF) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\n\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0001 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000D ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 000B ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 3031 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 000B ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0041 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 000B ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 002E ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0030 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 000B ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 005F ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0308 ÷ 05D0 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 000B ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0022 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 00AD ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0308 × 0300 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 000B ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 000B ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 000B ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 000B ÷ 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] <LINE TABULATION> (Newline) ÷ [3.1] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u000B\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0001\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0001 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0001\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\r\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000D ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\r\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\n\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\n\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u000B\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 000B ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u000B\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u3031\",\n                     new String[] { \"\\u3031\\u3031\" });\n\n    // ÷ 3031 × 0308 × 3031 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u3031\",\n                     new String[] { \"\\u3031\\u0308\\u3031\" });\n\n    // ÷ 3031 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0041\",\n                     new String[] { \"\\u3031\", \"\\u0041\" });\n\n    // ÷ 3031 × 0308 ÷ 0041 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0041\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0041\" });\n\n    // ÷ 3031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u003A\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u003A\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002C\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002C\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u002E\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 002E ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u002E\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0030\",\n                     new String[] { \"\\u3031\", \"\\u0030\" });\n\n    // ÷ 3031 × 0308 ÷ 0030 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0030\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0030\" });\n\n    // ÷ 3031 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u005F\",\n                     new String[] { \"\\u3031\\u005F\" });\n\n    // ÷ 3031 × 0308 × 005F ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u005F\",\n                     new String[] { \"\\u3031\\u0308\\u005F\" });\n\n    // ÷ 3031 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u05D0\",\n                     new String[] { \"\\u3031\", \"\\u05D0\" });\n\n    // ÷ 3031 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u05D0\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u05D0\" });\n\n    // ÷ 3031 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\\"\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0022 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\\"\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0027\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 3031 × 0308 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0027\",\n                     new String[] { \"\\u3031\\u0308\" });\n\n    // ÷ 3031 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u00AD\",\n                     new String[] { \"\\u3031\\u00AD\" });\n\n    // ÷ 3031 × 0308 × 00AD ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u00AD\",\n                     new String[] { \"\\u3031\\u0308\\u00AD\" });\n\n    // ÷ 3031 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0300\",\n                     new String[] { \"\\u3031\\u0300\" });\n\n    // ÷ 3031 × 0308 × 0300 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0300\",\n                     new String[] { \"\\u3031\\u0308\\u0300\" });\n\n    // ÷ 3031 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\\u2060\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0061\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0061\" });\n\n    // ÷ 3031 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0061\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u003A\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u0027\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002C\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 3031 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\", \"\\u0031\" });\n\n    // ÷ 3031 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] VERTICAL KANA REPEAT MARK (Katakana) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u3031\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u3031\\u0308\", \"\\u0031\" });\n\n    // ÷ 0041 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0001\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0001\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\r\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\r\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\n\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\n\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u000B\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u000B\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u3031\",\n                     new String[] { \"\\u0041\", \"\\u3031\" });\n\n    // ÷ 0041 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u3031\",\n                     new String[] { \"\\u0041\\u0308\", \"\\u3031\" });\n\n    // ÷ 0041 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0041\",\n                     new String[] { \"\\u0041\\u0041\" });\n\n    // ÷ 0041 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0041\",\n                     new String[] { \"\\u0041\\u0308\\u0041\" });\n\n    // ÷ 0041 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u003A\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u003A\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002C\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002C\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u002E\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u002E\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0030\",\n                     new String[] { \"\\u0041\\u0030\" });\n\n    // ÷ 0041 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0030\",\n                     new String[] { \"\\u0041\\u0308\\u0030\" });\n\n    // ÷ 0041 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u005F\",\n                     new String[] { \"\\u0041\\u005F\" });\n\n    // ÷ 0041 × 0308 × 005F ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u005F\",\n                     new String[] { \"\\u0041\\u0308\\u005F\" });\n\n    // ÷ 0041 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u05D0\",\n                     new String[] { \"\\u0041\\u05D0\" });\n\n    // ÷ 0041 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u05D0\",\n                     new String[] { \"\\u0041\\u0308\\u05D0\" });\n\n    // ÷ 0041 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\\"\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\\"\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0027\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0041 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0027\",\n                     new String[] { \"\\u0041\\u0308\" });\n\n    // ÷ 0041 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u00AD\",\n                     new String[] { \"\\u0041\\u00AD\" });\n\n    // ÷ 0041 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u00AD\",\n                     new String[] { \"\\u0041\\u0308\\u00AD\" });\n\n    // ÷ 0041 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0300\",\n                     new String[] { \"\\u0041\\u0300\" });\n\n    // ÷ 0041 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0300\",\n                     new String[] { \"\\u0041\\u0308\\u0300\" });\n\n    // ÷ 0041 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0041 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0061\" });\n\n    // ÷ 0041 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0061\" });\n\n    // ÷ 0041 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 0041 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0031\" });\n\n    // ÷ 0041 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN CAPITAL LETTER A (ALetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0041\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0041\\u0308\\u0031\" });\n\n    // ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\r\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\n\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 003A ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 003A ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 003A × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 003A × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\r\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\n\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002C ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002C ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002C × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002C × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0001 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\r\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000D ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\n\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 000B ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E × 0308 ÷ 3031 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 002E ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E × 0308 ÷ 0041 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 002E ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 002E ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E × 0308 ÷ 0030 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 002E ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 005F ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E × 0308 ÷ 05D0 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 002E ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0022 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 002E × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 00AD ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 002E × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E × 0308 × 0300 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 002E ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 002E ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 002E ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 002E × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] FULL STOP (MidNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u002E\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0030 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0001\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0001\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\r\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\r\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\n\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\n\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u000B\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u000B\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u3031\",\n                     new String[] { \"\\u0030\", \"\\u3031\" });\n\n    // ÷ 0030 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u3031\",\n                     new String[] { \"\\u0030\\u0308\", \"\\u3031\" });\n\n    // ÷ 0030 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0041\",\n                     new String[] { \"\\u0030\\u0041\" });\n\n    // ÷ 0030 × 0308 × 0041 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0041\",\n                     new String[] { \"\\u0030\\u0308\\u0041\" });\n\n    // ÷ 0030 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u003A\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u003A\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002C\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002C\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u002E\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u002E\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0030\",\n                     new String[] { \"\\u0030\\u0030\" });\n\n    // ÷ 0030 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0030\",\n                     new String[] { \"\\u0030\\u0308\\u0030\" });\n\n    // ÷ 0030 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u005F\",\n                     new String[] { \"\\u0030\\u005F\" });\n\n    // ÷ 0030 × 0308 × 005F ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u005F\",\n                     new String[] { \"\\u0030\\u0308\\u005F\" });\n\n    // ÷ 0030 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u05D0\",\n                     new String[] { \"\\u0030\\u05D0\" });\n\n    // ÷ 0030 × 0308 × 05D0 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u05D0\",\n                     new String[] { \"\\u0030\\u0308\\u05D0\" });\n\n    // ÷ 0030 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\\"\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\\"\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0027\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0030 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0027\",\n                     new String[] { \"\\u0030\\u0308\" });\n\n    // ÷ 0030 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u00AD\",\n                     new String[] { \"\\u0030\\u00AD\" });\n\n    // ÷ 0030 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u00AD\",\n                     new String[] { \"\\u0030\\u0308\\u00AD\" });\n\n    // ÷ 0030 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0300\",\n                     new String[] { \"\\u0030\\u0300\" });\n\n    // ÷ 0030 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0300\",\n                     new String[] { \"\\u0030\\u0308\\u0300\" });\n\n    // ÷ 0030 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0030 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0061\" });\n\n    // ÷ 0030 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0061\" });\n\n    // ÷ 0030 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 0030 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0031\" });\n\n    // ÷ 0030 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ZERO (Numeric) × [4.0] COMBINING DIAERESIS (Extend_FE) × [8.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0030\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0030\\u0308\\u0031\" });\n\n    // ÷ 005F ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0001 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\r\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000D ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\n\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 000B ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 005F × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u3031\",\n                     new String[] { \"\\u005F\\u3031\" });\n\n    // ÷ 005F × 0308 × 3031 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u3031\",\n                     new String[] { \"\\u005F\\u0308\\u3031\" });\n\n    // ÷ 005F × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0041\",\n                     new String[] { \"\\u005F\\u0041\" });\n\n    // ÷ 005F × 0308 × 0041 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0041\",\n                     new String[] { \"\\u005F\\u0308\\u0041\" });\n\n    // ÷ 005F ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 002E ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 005F × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0030\",\n                     new String[] { \"\\u005F\\u0030\" });\n\n    // ÷ 005F × 0308 × 0030 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0030\",\n                     new String[] { \"\\u005F\\u0308\\u0030\" });\n\n    // ÷ 005F × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 005F ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 005F × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u05D0\",\n                     new String[] { \"\\u005F\\u05D0\" });\n\n    // ÷ 005F × 0308 × 05D0 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u05D0\",\n                     new String[] { \"\\u005F\\u0308\\u05D0\" });\n\n    // ÷ 005F ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0022 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 005F ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 005F × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 00AD ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 005F × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0308 × 0300 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 005F × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0061\\u2060\" });\n\n    // ÷ 005F × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\\u2060\" });\n\n    // ÷ 005F × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0061\" });\n\n    // ÷ 005F × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0061\" });\n\n    // ÷ 005F × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 005F × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0031\" });\n\n    // ÷ 005F × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LOW LINE (ExtendNumLet) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u005F\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u005F\\u0308\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0001 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000D ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 000B ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 3031 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 1F1E6 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0041 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 1F1E6 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 002E ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0030 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 1F1E6 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 005F ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 1F1E6 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 1F1E6 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0022 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 00AD ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 0308 × 0300 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 1F1E6 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 05D0 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0001\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0001 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0001\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\r\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000D ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\r\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\n\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\n\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u000B\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 000B ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u000B\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u3031\",\n                     new String[] { \"\\u05D0\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0308 ÷ 3031 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u3031\",\n                     new String[] { \"\\u05D0\\u0308\", \"\\u3031\" });\n\n    // ÷ 05D0 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0041\",\n                     new String[] { \"\\u05D0\\u0041\" });\n\n    // ÷ 05D0 × 0308 × 0041 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0041\",\n                     new String[] { \"\\u05D0\\u0308\\u0041\" });\n\n    // ÷ 05D0 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u003A\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002C\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u002E\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 002E ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u002E\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0030\",\n                     new String[] { \"\\u05D0\\u0030\" });\n\n    // ÷ 05D0 × 0308 × 0030 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0030\",\n                     new String[] { \"\\u05D0\\u0308\\u0030\" });\n\n    // ÷ 05D0 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u005F\",\n                     new String[] { \"\\u05D0\\u005F\" });\n\n    // ÷ 05D0 × 0308 × 005F ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u005F\",\n                     new String[] { \"\\u05D0\\u0308\\u005F\" });\n\n    // ÷ 05D0 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u05D0\",\n                     new String[] { \"\\u05D0\\u05D0\" });\n\n    // ÷ 05D0 × 0308 × 05D0 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\\u0308\\u05D0\" });\n\n    // ÷ 05D0 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\\"\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 05D0 × 0308 ÷ 0022 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\\"\",\n                     new String[] { \"\\u05D0\\u0308\" });\n\n    // ÷ 05D0 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0027\",\n                     new String[] { \"\\u05D0\\u0027\" });\n\n    // ÷ 05D0 × 0308 × 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.1] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0027\" });\n\n    // ÷ 05D0 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u00AD\",\n                     new String[] { \"\\u05D0\\u00AD\" });\n\n    // ÷ 05D0 × 0308 × 00AD ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u00AD\",\n                     new String[] { \"\\u05D0\\u0308\\u00AD\" });\n\n    // ÷ 05D0 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0300\",\n                     new String[] { \"\\u05D0\\u0300\" });\n\n    // ÷ 05D0 × 0308 × 0300 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0300\",\n                     new String[] { \"\\u05D0\\u0308\\u0300\" });\n\n    // ÷ 05D0 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\\u2060\" });\n\n    // ÷ 05D0 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0061\" });\n\n    // ÷ 05D0 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0061\" });\n\n    // ÷ 05D0 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 05D0 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0031\" });\n\n    // ÷ 05D0 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] HEBREW LETTER ALEF (Hebrew_Letter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u05D0\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u05D0\\u0308\\u0031\" });\n\n    // ÷ 0022 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0001 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000D ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 000B ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 × 0308 ÷ 3031 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0022 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 × 0308 ÷ 0041 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0022 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 002E ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 × 0308 ÷ 0030 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0022 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 005F ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0022 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0022 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0022 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 00AD ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 × 0308 × 0300 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0022 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0022 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] QUOTATION MARK (Double_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\\"\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0027 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0001 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000D ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 000B ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD × 0308 ÷ 3031 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 00AD ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD × 0308 ÷ 0041 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 00AD ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 002E ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD × 0308 ÷ 0030 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 00AD ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 005F ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD × 0308 ÷ 05D0 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 00AD ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0022 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 00AD × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 00AD ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD × 0308 × 0300 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 00AD ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 00AD × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] SOFT HYPHEN (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u00AD\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0001 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0001\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000D ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\r\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\n\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 000B ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u000B\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 × 0308 ÷ 3031 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u3031\",\n                     new String[] { \"\\u3031\" });\n\n    // ÷ 0300 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 × 0308 ÷ 0041 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0041\",\n                     new String[] { \"\\u0041\" });\n\n    // ÷ 0300 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u003A\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002C\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 002E ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u002E\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 × 0308 ÷ 0030 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0030\",\n                     new String[] { \"\\u0030\" });\n\n    // ÷ 0300 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 005F ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u005F\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\uD83C\\uDDE6\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u05D0\",\n                     new String[] { \"\\u05D0\" });\n\n    // ÷ 0300 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0022 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\\"\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0027\",\n                     new String[] {  });\n\n    // ÷ 0300 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 00AD ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u00AD\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 × 0308 × 0300 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0300\",\n                     new String[] {  });\n\n    // ÷ 0300 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0300 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] COMBINING GRAVE ACCENT (Extend_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0300\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0061 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0001\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\r\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\n\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u000B\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u3031\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\\u2060\\u0308\", \"\\u3031\" });\n\n    // ÷ 0061 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0041\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u003A\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002C\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u002E\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0030\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0061 × 2060 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u005F\" });\n\n    // ÷ 0061 × 2060 × 0308 × 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [13.1] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u005F\" });\n\n    // ÷ 0061 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\\"\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0027\",\n                     new String[] { \"\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\" });\n\n    // ÷ 0061 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u00AD\" });\n\n    // ÷ 0061 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0300\" });\n\n    // ÷ 0061 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [5.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0031\" });\n\n    // ÷ 0061 × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [9.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 003A × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0041\" });\n\n    // ÷ 0061 × 003A × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u05D0\" });\n\n    // ÷ 0061 × 003A × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 × 003A × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0061\" });\n\n    // ÷ 0061 × 003A × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u003A\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0041\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0061\" });\n\n    // ÷ 0061 × 0027 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0041\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0041\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u05D0\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u05D0\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u2060\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0061\" });\n\n    // ÷ 0061 × 0027 × 2060 × 0308 × 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [7.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\\u0027\\u2060\\u0308\\u0061\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 0027 × 2060 × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0027\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0061\", \"\\u3031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0061\", \"\\u0041\" });\n\n    // ÷ 0061 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0030 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0061\", \"\\u0030\" });\n\n    // ÷ 0061 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0061\", \"\\u05D0\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\\u2060\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0061\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0061 ÷ 002C × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0061\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 003A ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0030\",\n                     new String[] { \"\\u0031\", \"\\u0030\" });\n\n    // ÷ 0031 ÷ 003A ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 003A × 0308 ÷ 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u003A\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0030\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 0027 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0031\" });\n\n    // ÷ 0031 × 0027 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] APOSTROPHE (Single_Quote) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u0027\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u0027\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002C ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002C × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0030\" });\n\n    // ÷ 0031 × 002C × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002C ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002C × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002C × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0031\" });\n\n    // ÷ 0031 × 002C × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] COMMA (MidNum) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002C\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002C\\u0308\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0001 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] <START OF HEADING> (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0001\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000D ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <CARRIAGE RETURN (CR)> (CR) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\r\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE FEED (LF)> (LF) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\n\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 000B ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [3.2] <LINE TABULATION> (Newline) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u000B\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 3031 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] VERTICAL KANA REPEAT MARK (Katakana) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u3031\",\n                     new String[] { \"\\u0031\", \"\\u3031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0041 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN CAPITAL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0041\",\n                     new String[] { \"\\u0031\", \"\\u0041\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u003A\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002C\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 002E ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] FULL STOP (MidNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u002E\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0030\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0030 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ZERO (Numeric) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0030\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0030\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 005F ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LOW LINE (ExtendNumLet) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u005F\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 1F1E6 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\uD83C\\uDDE6\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 05D0 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] HEBREW LETTER ALEF (Hebrew_Letter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u05D0\",\n                     new String[] { \"\\u0031\", \"\\u05D0\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0022 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] QUOTATION MARK (Double_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\\"\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0027\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 00AD ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] SOFT HYPHEN (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u00AD\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 × 0300 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [4.0] COMBINING GRAVE ACCENT (Extend_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0300\",\n                     new String[] { \"\\u0031\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\\u2060\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u003A\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 0027 × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u0027\\u2060\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 ÷ 002E × 2060 × 0308 ÷ 0061 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0061\\u002C\",\n                     new String[] { \"\\u0031\", \"\\u0061\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 003A ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COLON (MidLetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u003A\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 0027 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] APOSTROPHE (Single_Quote) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u0027\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002C ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] COMMA (MidNum) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002C\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0031\" });\n\n    // ÷ 0031 × 002E × 2060 × 0308 × 0031 ÷ 002E × 2060 ÷  #  ÷ [0.2] DIGIT ONE (Numeric) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [4.0] COMBINING DIAERESIS (Extend_FE) × [11.0] DIGIT ONE (Numeric) ÷ [999.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0031\\u002E\\u2060\\u0308\\u0031\\u002E\\u2060\",\n                     new String[] { \"\\u0031\\u002E\\u2060\\u0308\\u0031\" });\n\n    // ÷ 0063 × 0061 × 006E × 0027 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] APOSTROPHE (Single_Quote) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u0027\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u0027\\u0074\" });\n\n    // ÷ 0063 × 0061 × 006E × 2019 × 0074 ÷  #  ÷ [0.2] LATIN SMALL LETTER C (ALetter) × [5.0] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER N (ALetter) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [7.0] LATIN SMALL LETTER T (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0063\\u0061\\u006E\\u2019\\u0074\",\n                     new String[] { \"\\u0063\\u0061\\u006E\\u2019\\u0074\" });\n\n    // ÷ 0061 × 0062 × 00AD × 0062 × 0079 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] SOFT HYPHEN (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [5.0] LATIN SMALL LETTER Y (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0062\\u00AD\\u0062\\u0079\",\n                     new String[] { \"\\u0061\\u0062\\u00AD\\u0062\\u0079\" });\n\n    // ÷ 0061 ÷ 0024 ÷ 002D ÷ 0033 × 0034 × 002C × 0035 × 0036 × 0037 × 002E × 0031 × 0034 ÷ 0025 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] DOLLAR SIGN (Other) ÷ [999.0] HYPHEN-MINUS (Other) ÷ [999.0] DIGIT THREE (Numeric) × [8.0] DIGIT FOUR (Numeric) × [12.0] COMMA (MidNum) × [11.0] DIGIT FIVE (Numeric) × [8.0] DIGIT SIX (Numeric) × [8.0] DIGIT SEVEN (Numeric) × [12.0] FULL STOP (MidNumLet) × [11.0] DIGIT ONE (Numeric) × [8.0] DIGIT FOUR (Numeric) ÷ [999.0] PERCENT SIGN (Other) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\u0024\\u002D\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\\u0025\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0033\\u0034\\u002C\\u0035\\u0036\\u0037\\u002E\\u0031\\u0034\", \"\\u0062\" });\n\n    // ÷ 0033 × 0061 ÷  #  ÷ [0.2] DIGIT THREE (Numeric) × [10.0] LATIN SMALL LETTER A (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0033\\u0061\",\n                     new String[] { \"\\u0033\\u0061\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 0027 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] APOSTROPHE (Single_Quote) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u0027\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0063 × 2060 × 0061 × 2060 × 006E × 2060 × 2019 × 2060 × 0074 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER C (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER N (ALetter) × [4.0] WORD JOINER (Format_FE) × [6.0] RIGHT SINGLE QUOTATION MARK (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [7.0] LATIN SMALL LETTER T (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\",\n                     new String[] { \"\\u0063\\u2060\\u0061\\u2060\\u006E\\u2060\\u2019\\u2060\\u0074\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 × 0062 × 2060 × 00AD × 2060 × 0062 × 2060 × 0079 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] SOFT HYPHEN (Format_FE) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [5.0] LATIN SMALL LETTER Y (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\\u0062\\u2060\\u00AD\\u2060\\u0062\\u2060\\u0079\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0061 × 2060 ÷ 0024 × 2060 ÷ 002D × 2060 ÷ 0033 × 2060 × 0034 × 2060 × 002C × 2060 × 0035 × 2060 × 0036 × 2060 × 0037 × 2060 × 002E × 2060 × 0031 × 2060 × 0034 × 2060 ÷ 0025 × 2060 ÷ 0062 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DOLLAR SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] HYPHEN-MINUS (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] COMMA (MidNum) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT FIVE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SIX (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT SEVEN (Numeric) × [4.0] WORD JOINER (Format_FE) × [12.0] FULL STOP (MidNumLet) × [4.0] WORD JOINER (Format_FE) × [11.0] DIGIT ONE (Numeric) × [4.0] WORD JOINER (Format_FE) × [8.0] DIGIT FOUR (Numeric) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] PERCENT SIGN (Other) × [4.0] WORD JOINER (Format_FE) ÷ [999.0] LATIN SMALL LETTER B (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0061\\u2060\\u0024\\u2060\\u002D\\u2060\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\\u0025\\u2060\\u0062\\u2060\\u2060\",\n                     new String[] { \"\\u0061\\u2060\", \"\\u0033\\u2060\\u0034\\u2060\\u002C\\u2060\\u0035\\u2060\\u0036\\u2060\\u0037\\u2060\\u002E\\u2060\\u0031\\u2060\\u0034\\u2060\", \"\\u0062\\u2060\\u2060\" });\n\n    // ÷ 2060 ÷ 0033 × 2060 × 0061 × 2060 × 2060 ÷  #  ÷ [0.2] WORD JOINER (Format_FE) ÷ [999.0] DIGIT THREE (Numeric) × [4.0] WORD JOINER (Format_FE) × [10.0] LATIN SMALL LETTER A (ALetter) × [4.0] WORD JOINER (Format_FE) × [4.0] WORD JOINER (Format_FE) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u2060\\u0033\\u2060\\u0061\\u2060\\u2060\",\n                     new String[] { \"\\u0033\\u2060\\u0061\\u2060\\u2060\" });\n\n    // ÷ 0061 ÷ 1F1E6 ÷ 0062 ÷  #  ÷ [0.2] LATIN SMALL LETTER A (ALetter) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) ÷ [999.0] LATIN SMALL LETTER B (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0061\\uD83C\\uDDE6\\u0062\",\n                     new String[] { \"\\u0061\", \"\\u0062\" });\n\n    // ÷ 1F1F7 × 1F1FA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA × 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1F7 × 1F1FA ÷ 200B ÷ 1F1F8 × 1F1EA ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER R (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER U (Regional_Indicator) ÷ [999.0] ZERO WIDTH SPACE (Other) ÷ [999.0] REGIONAL INDICATOR SYMBOL LETTER S (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER E (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDF7\\uD83C\\uDDFA\\u200B\\uD83C\\uDDF8\\uD83C\\uDDEA\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 200D × 1F1E7 × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\u200D\\uD83C\\uDDE7\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 1F1E6 × 1F1E7 × 200D × 1F1E8 ÷  #  ÷ [0.2] REGIONAL INDICATOR SYMBOL LETTER A (Regional_Indicator) × [13.3] REGIONAL INDICATOR SYMBOL LETTER B (Regional_Indicator) × [4.0] ZERO WIDTH JOINER (Extend_FE) × [13.3] REGIONAL INDICATOR SYMBOL LETTER C (Regional_Indicator) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\uD83C\\uDDE6\\uD83C\\uDDE7\\u200D\\uD83C\\uDDE8\",\n                     new String[] {  });\n\n    // ÷ 0020 × 200D ÷ 0646 ÷  #  ÷ [0.2] SPACE (Other) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] ARABIC LETTER NOON (ALetter) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0020\\u200D\\u0646\",\n                     new String[] { \"\\u0646\" });\n\n    // ÷ 0646 × 200D ÷ 0020 ÷  #  ÷ [0.2] ARABIC LETTER NOON (ALetter) × [4.0] ZERO WIDTH JOINER (Extend_FE) ÷ [999.0] SPACE (Other) ÷ [0.3]\n    assertAnalyzesTo(analyzer, \"\\u0646\\u200D\\u0020\",\n                     new String[] { \"\\u0646\\u200D\" });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8c6c25f6bab8e32b731127f3516a593af8a3305":["b266fe0ac2172d4ad87cff12bd9bf9f8c8247345"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b266fe0ac2172d4ad87cff12bd9bf9f8c8247345":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b266fe0ac2172d4ad87cff12bd9bf9f8c8247345"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b8c6c25f6bab8e32b731127f3516a593af8a3305"]},"commit2Childs":{"b8c6c25f6bab8e32b731127f3516a593af8a3305":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b266fe0ac2172d4ad87cff12bd9bf9f8c8247345","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b266fe0ac2172d4ad87cff12bd9bf9f8c8247345":["b8c6c25f6bab8e32b731127f3516a593af8a3305","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}