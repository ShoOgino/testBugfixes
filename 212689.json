{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#_corruptFiles(Collection[String]).mjava","commits":[{"id":"e2b17cf57d8de6b9abb848ee5f3848a631c539ca","date":1466499034,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#_corruptFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private synchronized void _corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"214256b5eeeaba88b8293b37d30460b462b19562","date":1468250146,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#_corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#_corruptFiles(Collection[String]).mjava","sourceNew":"  private synchronized void _corruptFiles(Collection<String> files) throws IOException {\n\n    // TODO: we should also mess with any recent file renames, file deletions, if\n    // syncMetaData was not called!!\n    \n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void _corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#_corruptFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private synchronized void _corruptFiles(Collection<String> files) throws IOException {\n\n    // TODO: we should also mess with any recent file renames, file deletions, if\n    // syncMetaData was not called!!\n    \n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"214256b5eeeaba88b8293b37d30460b462b19562":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2b17cf57d8de6b9abb848ee5f3848a631c539ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","214256b5eeeaba88b8293b37d30460b462b19562"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["214256b5eeeaba88b8293b37d30460b462b19562"]},"commit2Childs":{"214256b5eeeaba88b8293b37d30460b462b19562":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e2b17cf57d8de6b9abb848ee5f3848a631c539ca":["214256b5eeeaba88b8293b37d30460b462b19562"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}