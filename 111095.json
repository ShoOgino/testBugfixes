{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","commits":[{"id":"b2e70b697d9f5a6130848741a4f0cdc08a1fe258","date":1168661303,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"/dev/null","sourceNew":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse()) {\r\n        Document doc = null;\r\n        if (hits != null && hits.length() > 0) {\r\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n\r\n            if (withRetrieve()) {\r\n              doc = ir.document(id);\r\n              res += (doc==null ? 0 : 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ebcfbd9662f54e73fdfe1f4d675ea39531fb9b0","date":1174485154,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse() && hits!=null) {\n        Document doc = null;\r\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n\r\n            if (withRetrieve()) {\r\n              doc = ir.document(id);\r\n              res += (doc==null ? 0 : 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","sourceOld":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse()) {\r\n        Document doc = null;\r\n        if (hits != null && hits.length() > 0) {\r\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n\r\n            if (withRetrieve()) {\r\n              doc = ir.document(id);\r\n              res += (doc==null ? 0 : 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1","date":1174621692,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse() && hits!=null) {\r\n        int traversalSize = Math.min(hits.length(), traversalSize());\r\n        if (traversalSize > 0) {\r\n          boolean retrieve = withRetrieve();\r\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n            if (retrieve) {\r\n              res += retrieveDoc(ir, id);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","sourceOld":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse() && hits!=null) {\n        Document doc = null;\r\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n\r\n            if (withRetrieve()) {\r\n              doc = ir.document(id);\r\n              res += (doc==null ? 0 : 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738fa43eaa87dc7b393fe98b04cde1019e20bac","date":1175557034,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n    \n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n    \n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc==null ? 0 : 1);\n        }\n      }\n    }\n    \n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Hits hits = searcher.search(q);\n      //System.out.println(\"searched: \"+q);\n      \n      if (withTraverse() && hits!=null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          for (int m = 0; m < hits.length(); m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              res += retrieveDoc(ir, id);\n            }\n          }\n        }\n      }\n      \n      searcher.close();\n    }\n    \n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\r\n    int res = 0;\r\n    boolean closeReader = false;\r\n    \r\n    // open reader or use existing one\r\n    IndexReader ir = getRunData().getIndexReader();\r\n    if (ir == null) {\r\n      Directory dir = getRunData().getDirectory();\r\n      ir = IndexReader.open(dir);\r\n      closeReader = true;\r\n      //res++; //this is confusing, comment it out\r\n    }\r\n    \r\n    // optionally warm and add num docs traversed to count\r\n    if (withWarm()) {\r\n      Document doc = null;\r\n      for (int m = 0; m < ir.maxDoc(); m++) {\r\n        if (!ir.isDeleted(m)) {\r\n          doc = ir.document(m);\r\n          res += (doc==null ? 0 : 1);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (withSearch()) {\r\n      res++;\r\n      IndexSearcher searcher = new IndexSearcher(ir);\r\n      QueryMaker queryMaker = getQueryMaker();\r\n      Query q = queryMaker.makeQuery();\r\n      Hits hits = searcher.search(q);\r\n      //System.out.println(\"searched: \"+q);\r\n      \r\n      if (withTraverse() && hits!=null) {\r\n        int traversalSize = Math.min(hits.length(), traversalSize());\r\n        if (traversalSize > 0) {\r\n          boolean retrieve = withRetrieve();\r\n          for (int m = 0; m < hits.length(); m++) {\r\n            int id = hits.id(m);\r\n            res++;\r\n            if (retrieve) {\r\n              res += retrieveDoc(ir, id);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      searcher.close();\r\n    }\r\n    \r\n    if (closeReader) {\r\n      ir.close();\r\n    }\r\n    return res;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cef13333102a2c287543f5141a0f24ccca005b2e","date":1201185584,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Hits hits = searcher.search(q);\n      //System.out.println(\"searched: \"+q);\n\n      if (withTraverse() && hits != null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          int numHighlight = Math.min(numToHighlight(), hits.length());\n          Analyzer analyzer = getRunData().getAnalyzer();\n          Highlighter highlighter = null;\n          int maxFrags = 1;\n          if (numHighlight > 0) {\n            highlighter = getHighlighter(q);\n            maxFrags = maxNumFragments();\n          }\n          boolean merge = isMergeContiguousFragments();\n          for (int m = 0; m < traversalSize; m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              Document document = retrieveDoc(ir, id);\n              res += document != null ? 1 : 0;\n              if (numHighlight > 0 && m < numHighlight) {\n                Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                  String field = (String) iterator.next();\n                  String text = document.get(field);\n                  TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                  res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n    \n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n    \n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc==null ? 0 : 1);\n        }\n      }\n    }\n    \n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Hits hits = searcher.search(q);\n      //System.out.println(\"searched: \"+q);\n      \n      if (withTraverse() && hits!=null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          for (int m = 0; m < hits.length(); m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              res += retrieveDoc(ir, id);\n            }\n          }\n        }\n      }\n      \n      searcher.close();\n    }\n    \n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c135b907ec07be761fc0f0c3501a038a2a28f3bc","date":1220975801,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      Hits hits;\n      if(sort != null) {\n        hits = searcher.search(q, sort);\n      } else {\n        hits = searcher.search(q);\n      }\n      //System.out.println(\"searched: \"+q);\n\n      if (withTraverse() && hits != null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          int numHighlight = Math.min(numToHighlight(), hits.length());\n          Analyzer analyzer = getRunData().getAnalyzer();\n          Highlighter highlighter = null;\n          int maxFrags = 1;\n          if (numHighlight > 0) {\n            highlighter = getHighlighter(q);\n            maxFrags = maxNumFragments();\n          }\n          boolean merge = isMergeContiguousFragments();\n          for (int m = 0; m < traversalSize; m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              Document document = retrieveDoc(ir, id);\n              res += document != null ? 1 : 0;\n              if (numHighlight > 0 && m < numHighlight) {\n                Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                  String field = (String) iterator.next();\n                  String text = document.get(field);\n                  TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                  res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Hits hits = searcher.search(q);\n      //System.out.println(\"searched: \"+q);\n\n      if (withTraverse() && hits != null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          int numHighlight = Math.min(numToHighlight(), hits.length());\n          Analyzer analyzer = getRunData().getAnalyzer();\n          Highlighter highlighter = null;\n          int maxFrags = 1;\n          if (numHighlight > 0) {\n            highlighter = getHighlighter(q);\n            maxFrags = maxNumFragments();\n          }\n          boolean merge = isMergeContiguousFragments();\n          for (int m = 0; m < traversalSize; m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              Document document = retrieveDoc(ir, id);\n              res += document != null ? 1 : 0;\n              if (numHighlight > 0 && m < numHighlight) {\n                Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                  String field = (String) iterator.next();\n                  String text = document.get(field);\n                  TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                  res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef9d14bdd95088e15ae1d78425f395fbc4063215","date":1229440186,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      Hits hits;\n      if(sort != null) {\n        hits = searcher.search(q, sort);\n      } else {\n        hits = searcher.search(q);\n      }\n      //System.out.println(\"searched: \"+q);\n\n      if (withTraverse() && hits != null) {\n        int traversalSize = Math.min(hits.length(), traversalSize());\n        if (traversalSize > 0) {\n          boolean retrieve = withRetrieve();\n          int numHighlight = Math.min(numToHighlight(), hits.length());\n          Analyzer analyzer = getRunData().getAnalyzer();\n          Highlighter highlighter = null;\n          int maxFrags = 1;\n          if (numHighlight > 0) {\n            highlighter = getHighlighter(q);\n            maxFrags = maxNumFragments();\n          }\n          boolean merge = isMergeContiguousFragments();\n          for (int m = 0; m < traversalSize; m++) {\n            int id = hits.id(m);\n            res++;\n            if (retrieve) {\n              Document document = retrieveDoc(ir, id);\n              res += document != null ? 1 : 0;\n              if (numHighlight > 0 && m < numHighlight) {\n                Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                  String field = (String) iterator.next();\n                  String text = document.get(field);\n                  TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                  res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3215ae1377fc1ca1790921d75dd39cb764743b85","date":1237371771,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n        if (first) {\n          System.out.println(\"NUMHITS=\" + hits.totalHits);\n\n          for(int i=0;i<10;i++) {\n            if (i >= hits.totalHits) {\n              break;\n            }\n            System.out.println(\"  \" + i + \": score=\" + hits.scoreDocs[i].score + \" doc=\" + hits.scoreDocs[i].doc);\n          }\n          first = false;\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c482d1e63332617181729a225b215c452d8a79","date":1237396006,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n        if (first) {\n          System.out.println(\"NUMHITS=\" + hits.totalHits);\n\n          for(int i=0;i<10;i++) {\n            if (i >= hits.totalHits) {\n              break;\n            }\n            System.out.println(\"  \" + i + \": score=\" + hits.scoreDocs[i].score + \" doc=\" + hits.scoreDocs[i].doc);\n          }\n          first = false;\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2127ef10691b355c0af0b8ff0250a1abafdf6fa","date":1239020442,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      IndexSearcher searcher = new IndexSearcher(ir);\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore());\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          hits = searcher.search(q, null, numHits, sort);\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc","date":1241865401,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore());\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e38bd919fdf4e07a8864d275baeee5e40d6198","date":1249417442,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            Highlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            boolean merge = isMergeContiguousFragments();\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    TokenStream ts = TokenSources.getAnyTokenStream(ir, id, field, document, analyzer);\n                    res += doHighlight(ts, text, highlighter, merge, maxFrags);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b93eda87f01d8ad7de73f8ef0fbdab8dff201e86","date":1249474188,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            int maxFrags = 1;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n              maxFrags = maxNumFragments();\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4256bc1b3c94786287ccdfc751230374521843cf","date":1254612273,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e1ce9be74263e9659aad8a6ee1f213193710b71","date":1256298843,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);\n                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {\n                    String field = (String) iterator.next();\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3878d3c6c3f8e9fefbbe59fe12a7c4207aa6c232","date":1257624480,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44f4a7f902453364ad6a696f4cf2dc4cb775ca0d","date":1257628238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","sourceOld":"  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3353540ef2debe4c4c017e9d86e2c60f9e784336","date":1258197258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n\n    // open reader or use existing one\n    IndexSearcher searcher = getRunData().getIndexSearcher();\n\n    IndexReader reader;\n\n    final boolean closeSearcher;\n    if (searcher == null) {\n      // open our own reader\n      Directory dir = getRunData().getDirectory();\n      reader = IndexReader.open(dir, true);\n      searcher = new IndexSearcher(reader);\n      closeSearcher = true;\n    } else {\n      // use existing one; this passes +1 ref to us\n      reader = searcher.getIndexReader();\n      closeSearcher = false;\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < reader.maxDoc(); m++) {\n        if (!reader.isDeleted(m)) {\n          doc = reader.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          Weight w = q.weight(searcher);\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n                                                                 true, withScore(),\n                                                                 withMaxScore(),\n                                                                 !w.scoresDocsOutOfOrder());\n          searcher.search(w, null, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + reader.maxDoc());\n          System.out.println(\"numDocs() = \" + reader.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = reader.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(reader, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(reader, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (closeSearcher) {\n      searcher.close();\n    } else {\n      // Release our +1 ref from above\n      reader.decRef();\n    }\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n    boolean closeReader = false;\n\n    // open reader or use existing one\n    IndexReader ir = getRunData().getIndexReader();\n    if (ir == null) {\n      Directory dir = getRunData().getDirectory();\n      ir = IndexReader.open(dir, true);\n      closeReader = true;\n      //res++; //this is confusing, comment it out\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < ir.maxDoc(); m++) {\n        if (!ir.isDeleted(m)) {\n          doc = ir.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      final IndexSearcher searcher;\n      if (closeReader) {\n        searcher = new IndexSearcher(ir);\n      } else {\n        searcher = getRunData().getIndexSearcher();\n      }\n      QueryMaker queryMaker = getQueryMaker();\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          // TODO: change the following to create TFC with in/out-of order\n          // according to whether the query's Scorer.\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n              true, withScore(), withMaxScore(), false);\n          searcher.search(q, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          final IndexReader r = searcher.getIndexReader();\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + r.maxDoc());\n          System.out.println(\"numDocs() = \" + r.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = r.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        //System.out.println(\"q=\" + q + \":\" + hits.totalHits + \" total hits\"); \n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(ir, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(ir, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      searcher.close();\n    }\n\n    if (closeReader) {\n      ir.close();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["406e7055a3e99d3fa6ce49a555a51dd18b321806"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4973f5a2c1ccd81e5d1e82d75c20a27212f2e509","date":1260188274,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n\n    // open reader or use existing one\n    IndexSearcher searcher = getRunData().getIndexSearcher();\n\n    IndexReader reader;\n\n    final boolean closeSearcher;\n    if (searcher == null) {\n      // open our own reader\n      Directory dir = getRunData().getDirectory();\n      reader = IndexReader.open(dir, true);\n      searcher = new IndexSearcher(reader);\n      closeSearcher = true;\n    } else {\n      // use existing one; this passes +1 ref to us\n      reader = searcher.getIndexReader();\n      closeSearcher = false;\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < reader.maxDoc(); m++) {\n        if (!reader.isDeleted(m)) {\n          doc = reader.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          Weight w = q.weight(searcher);\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n                                                                 true, withScore(),\n                                                                 withMaxScore(),\n                                                                 !w.scoresDocsOutOfOrder());\n          searcher.search(w, null, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + reader.maxDoc());\n          System.out.println(\"numDocs() = \" + reader.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = reader.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(reader, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(reader, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (closeSearcher) {\n      searcher.close();\n      reader.close();\n    } else {\n      // Release our +1 ref from above\n      reader.decRef();\n    }\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n\n    // open reader or use existing one\n    IndexSearcher searcher = getRunData().getIndexSearcher();\n\n    IndexReader reader;\n\n    final boolean closeSearcher;\n    if (searcher == null) {\n      // open our own reader\n      Directory dir = getRunData().getDirectory();\n      reader = IndexReader.open(dir, true);\n      searcher = new IndexSearcher(reader);\n      closeSearcher = true;\n    } else {\n      // use existing one; this passes +1 ref to us\n      reader = searcher.getIndexReader();\n      closeSearcher = false;\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < reader.maxDoc(); m++) {\n        if (!reader.isDeleted(m)) {\n          doc = reader.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          Weight w = q.weight(searcher);\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n                                                                 true, withScore(),\n                                                                 withMaxScore(),\n                                                                 !w.scoresDocsOutOfOrder());\n          searcher.search(w, null, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + reader.maxDoc());\n          System.out.println(\"numDocs() = \" + reader.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = reader.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(reader, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(reader, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (closeSearcher) {\n      searcher.close();\n    } else {\n      // Release our +1 ref from above\n      reader.decRef();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask#doLogic().mjava","sourceNew":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n\n    // open reader or use existing one\n    IndexSearcher searcher = getRunData().getIndexSearcher();\n\n    IndexReader reader;\n\n    final boolean closeSearcher;\n    if (searcher == null) {\n      // open our own reader\n      Directory dir = getRunData().getDirectory();\n      reader = IndexReader.open(dir, true);\n      searcher = new IndexSearcher(reader);\n      closeSearcher = true;\n    } else {\n      // use existing one; this passes +1 ref to us\n      reader = searcher.getIndexReader();\n      closeSearcher = false;\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < reader.maxDoc(); m++) {\n        if (!reader.isDeleted(m)) {\n          doc = reader.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          Weight w = q.weight(searcher);\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n                                                                 true, withScore(),\n                                                                 withMaxScore(),\n                                                                 !w.scoresDocsOutOfOrder());\n          searcher.search(w, null, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + reader.maxDoc());\n          System.out.println(\"numDocs() = \" + reader.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = reader.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(reader, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(reader, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (closeSearcher) {\n      searcher.close();\n      reader.close();\n    } else {\n      // Release our +1 ref from above\n      reader.decRef();\n    }\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public int doLogic() throws Exception {\n    int res = 0;\n\n    // open reader or use existing one\n    IndexSearcher searcher = getRunData().getIndexSearcher();\n\n    IndexReader reader;\n\n    final boolean closeSearcher;\n    if (searcher == null) {\n      // open our own reader\n      Directory dir = getRunData().getDirectory();\n      reader = IndexReader.open(dir, true);\n      searcher = new IndexSearcher(reader);\n      closeSearcher = true;\n    } else {\n      // use existing one; this passes +1 ref to us\n      reader = searcher.getIndexReader();\n      closeSearcher = false;\n    }\n\n    // optionally warm and add num docs traversed to count\n    if (withWarm()) {\n      Document doc = null;\n      for (int m = 0; m < reader.maxDoc(); m++) {\n        if (!reader.isDeleted(m)) {\n          doc = reader.document(m);\n          res += (doc == null ? 0 : 1);\n        }\n      }\n    }\n\n    if (withSearch()) {\n      res++;\n      Query q = queryMaker.makeQuery();\n      Sort sort = getSort();\n      TopDocs hits;\n      final int numHits = numHits();\n      if (numHits > 0) {\n        if (sort != null) {\n          Weight w = q.weight(searcher);\n          TopFieldCollector collector = TopFieldCollector.create(sort, numHits,\n                                                                 true, withScore(),\n                                                                 withMaxScore(),\n                                                                 !w.scoresDocsOutOfOrder());\n          searcher.search(w, null, collector);\n          hits = collector.topDocs();\n        } else {\n          hits = searcher.search(q, numHits);\n        }\n\n        final String printHitsField = getRunData().getConfig().get(\"print.hits.field\", null);\n        if (printHitsField != null && printHitsField.length() > 0) {\n          if (q instanceof MultiTermQuery) {\n            System.out.println(\"MultiTermQuery term count = \" + ((MultiTermQuery) q).getTotalNumberOfTerms());\n          }\n          System.out.println(\"totalHits = \" + hits.totalHits);\n          System.out.println(\"maxDoc()  = \" + reader.maxDoc());\n          System.out.println(\"numDocs() = \" + reader.numDocs());\n          for(int i=0;i<hits.scoreDocs.length;i++) {\n            final int docID = hits.scoreDocs[i].doc;\n            final Document doc = reader.document(docID);\n            System.out.println(\"  \" + i + \": doc=\" + docID + \" score=\" + hits.scoreDocs[i].score + \" \" + printHitsField + \" =\" + doc.get(printHitsField));\n          }\n        }\n\n        if (withTraverse()) {\n          final ScoreDoc[] scoreDocs = hits.scoreDocs;\n          int traversalSize = Math.min(scoreDocs.length, traversalSize());\n\n          if (traversalSize > 0) {\n            boolean retrieve = withRetrieve();\n            int numHighlight = Math.min(numToHighlight(), scoreDocs.length);\n            Analyzer analyzer = getRunData().getAnalyzer();\n            BenchmarkHighlighter highlighter = null;\n            if (numHighlight > 0) {\n              highlighter = getBenchmarkHighlighter(q);\n            }\n            for (int m = 0; m < traversalSize; m++) {\n              int id = scoreDocs[m].doc;\n              res++;\n              if (retrieve) {\n                Document document = retrieveDoc(reader, id);\n                res += document != null ? 1 : 0;\n                if (numHighlight > 0 && m < numHighlight) {\n                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);\n                  for (final String field : fieldsToHighlight) {\n                    String text = document.get(field);\n                    res += highlighter.doHighlight(reader, id, field, document, analyzer, text);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (closeSearcher) {\n      searcher.close();\n      reader.close();\n    } else {\n      // Release our +1 ref from above\n      reader.decRef();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cef13333102a2c287543f5141a0f24ccca005b2e":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["4256bc1b3c94786287ccdfc751230374521843cf"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["f2127ef10691b355c0af0b8ff0250a1abafdf6fa"],"3878d3c6c3f8e9fefbbe59fe12a7c4207aa6c232":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1":["1ebcfbd9662f54e73fdfe1f4d675ea39531fb9b0"],"3215ae1377fc1ca1790921d75dd39cb764743b85":["ef9d14bdd95088e15ae1d78425f395fbc4063215"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["44f4a7f902453364ad6a696f4cf2dc4cb775ca0d"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4973f5a2c1ccd81e5d1e82d75c20a27212f2e509":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"f2127ef10691b355c0af0b8ff0250a1abafdf6fa":["09c482d1e63332617181729a225b215c452d8a79"],"4256bc1b3c94786287ccdfc751230374521843cf":["b93eda87f01d8ad7de73f8ef0fbdab8dff201e86"],"3353540ef2debe4c4c017e9d86e2c60f9e784336":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"b93eda87f01d8ad7de73f8ef0fbdab8dff201e86":["b7e38bd919fdf4e07a8864d275baeee5e40d6198"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"1ebcfbd9662f54e73fdfe1f4d675ea39531fb9b0":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"ef9d14bdd95088e15ae1d78425f395fbc4063215":["c135b907ec07be761fc0f0c3501a038a2a28f3bc"],"b7e38bd919fdf4e07a8864d275baeee5e40d6198":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"44f4a7f902453364ad6a696f4cf2dc4cb775ca0d":["3878d3c6c3f8e9fefbbe59fe12a7c4207aa6c232"],"09c482d1e63332617181729a225b215c452d8a79":["3215ae1377fc1ca1790921d75dd39cb764743b85"],"c135b907ec07be761fc0f0c3501a038a2a28f3bc":["cef13333102a2c287543f5141a0f24ccca005b2e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4973f5a2c1ccd81e5d1e82d75c20a27212f2e509"]},"commit2Childs":{"cef13333102a2c287543f5141a0f24ccca005b2e":["c135b907ec07be761fc0f0c3501a038a2a28f3bc"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["3878d3c6c3f8e9fefbbe59fe12a7c4207aa6c232"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"3878d3c6c3f8e9fefbbe59fe12a7c4207aa6c232":["44f4a7f902453364ad6a696f4cf2dc4cb775ca0d"],"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"3215ae1377fc1ca1790921d75dd39cb764743b85":["09c482d1e63332617181729a225b215c452d8a79"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["cef13333102a2c287543f5141a0f24ccca005b2e"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["1ebcfbd9662f54e73fdfe1f4d675ea39531fb9b0"],"4973f5a2c1ccd81e5d1e82d75c20a27212f2e509":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"f2127ef10691b355c0af0b8ff0250a1abafdf6fa":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"4256bc1b3c94786287ccdfc751230374521843cf":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"1ebcfbd9662f54e73fdfe1f4d675ea39531fb9b0":["bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1"],"3353540ef2debe4c4c017e9d86e2c60f9e784336":["4973f5a2c1ccd81e5d1e82d75c20a27212f2e509"],"b93eda87f01d8ad7de73f8ef0fbdab8dff201e86":["4256bc1b3c94786287ccdfc751230374521843cf"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["b7e38bd919fdf4e07a8864d275baeee5e40d6198"],"ef9d14bdd95088e15ae1d78425f395fbc4063215":["3215ae1377fc1ca1790921d75dd39cb764743b85"],"b7e38bd919fdf4e07a8864d275baeee5e40d6198":["b93eda87f01d8ad7de73f8ef0fbdab8dff201e86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"44f4a7f902453364ad6a696f4cf2dc4cb775ca0d":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"09c482d1e63332617181729a225b215c452d8a79":["f2127ef10691b355c0af0b8ff0250a1abafdf6fa"],"c135b907ec07be761fc0f0c3501a038a2a28f3bc":["ef9d14bdd95088e15ae1d78425f395fbc4063215"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}