{"path":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","commits":[{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + creationTime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57fd66a0ac275d391b497ca54072054913800985","date":1462047384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","sourceNew":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + ctime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","sourceOld":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + creationTime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"435efa290969c9932f8977555a3078a0182338e2","date":1462097391,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","sourceNew":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + ctime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","sourceOld":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + creationTime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.NativeFSLock#ensureValid().mjava","sourceNew":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + ctime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","sourceOld":"    @Override\n    public void ensureValid() throws IOException {\n      if (closed) {\n        throw new AlreadyClosedException(\"Lock instance already released: \" + this);\n      }\n      // check we are still in the locks map (some debugger or something crazy didn't remove us)\n      if (!LOCK_HELD.contains(path.toString())) {\n        throw new AlreadyClosedException(\"Lock path unexpectedly cleared from map: \" + this);\n      }\n      // check our lock wasn't invalidated.\n      if (!lock.isValid()) {\n        throw new AlreadyClosedException(\"FileLock invalidated by an external force: \" + this);\n      }\n      // try to validate the underlying file descriptor.\n      // this will throw IOException if something is wrong.\n      long size = channel.size();\n      if (size != 0) {\n        throw new AlreadyClosedException(\"Unexpected lock file size: \" + size + \", (lock=\" + this + \")\");\n      }\n      // try to validate the backing file name, that it still exists,\n      // and has the same creation time as when we obtained the lock. \n      // if it differs, someone deleted our lock file (and we are ineffective)\n      FileTime ctime = Files.readAttributes(path, BasicFileAttributes.class).creationTime(); \n      if (!creationTime.equals(ctime)) {\n        throw new AlreadyClosedException(\"Underlying file changed by an external force at \" + creationTime + \", (lock=\" + this + \")\");\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"618635065f043788c9e034f96ca5cd5cea1b4592":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"435efa290969c9932f8977555a3078a0182338e2":["618635065f043788c9e034f96ca5cd5cea1b4592","57fd66a0ac275d391b497ca54072054913800985"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57fd66a0ac275d391b497ca54072054913800985":["618635065f043788c9e034f96ca5cd5cea1b4592"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["435efa290969c9932f8977555a3078a0182338e2"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["618635065f043788c9e034f96ca5cd5cea1b4592","435efa290969c9932f8977555a3078a0182338e2"]},"commit2Childs":{"618635065f043788c9e034f96ca5cd5cea1b4592":["435efa290969c9932f8977555a3078a0182338e2","57fd66a0ac275d391b497ca54072054913800985","55b50463286869f584cf849d1587a0fcd54d1dfa"],"435efa290969c9932f8977555a3078a0182338e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["618635065f043788c9e034f96ca5cd5cea1b4592"],"57fd66a0ac275d391b497ca54072054913800985":["435efa290969c9932f8977555a3078a0182338e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}