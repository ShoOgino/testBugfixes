{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","commits":[{"id":"d9ccfe45460d496c5e5e1b70396521dac842d966","date":1516798975,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer)autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441","date":1516881857,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer)autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f0e33082a86447f4f2b59a1a5f69a310500276a","date":1519970482,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer)autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad60b6945c360ff89899d716d9cdec8dd674e2a0","date":1528114819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        rf = coll.getReplicas().size() / coll.getSlices().size();\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        rf = coll.getReplicas().size() / coll.getSlices().size();\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        rf = coll.getReplicas().size() / coll.getSlices().size();\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> totalRF.addAndGet(coll.getReplicationFactor() * coll.getSlices().size()));\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        if (coll.getSlices().isEmpty()) {\n          rf = 1; // ???\n        } else {\n          rf = coll.getReplicas().size() / coll.getSlices().size();\n        }\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        rf = coll.getReplicas().size() / coll.getSlices().size();\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        if (coll.getSlices().isEmpty()) {\n          rf = 1; // ???\n        } else {\n          rf = coll.getReplicas().size() / coll.getSlices().size();\n        }\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '{}' event property: {}, using default {}\", AutoScalingParams.MAX_COMPUTE_OPERATIONS, o, maxOp);\n      return maxOp;\n    }\n  }\n\n","sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        if (coll.getSlices().isEmpty()) {\n          rf = 1; // ???\n        } else {\n          rf = coll.getReplicas().size() / coll.getSlices().size();\n        }\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '\" + AutoScalingParams.MAX_COMPUTE_OPERATIONS + \"' event property: \" + o + \", using default \" + maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ComputePlanAction#getMaxNumOps(TriggerEvent,AutoScalingConfig,ClusterState).mjava","sourceNew":null,"sourceOld":"  protected int getMaxNumOps(TriggerEvent event, AutoScalingConfig autoScalingConfig, ClusterState clusterState) {\n    // estimate a maximum default limit that should be sufficient for most purposes:\n    // number of nodes * total number of replicas * 3\n    AtomicInteger totalRF = new AtomicInteger();\n    clusterState.forEachCollection(coll -> {\n      Integer rf = coll.getReplicationFactor();\n      if (rf == null) {\n        if (coll.getSlices().isEmpty()) {\n          rf = 1; // ???\n        } else {\n          rf = coll.getReplicas().size() / coll.getSlices().size();\n        }\n      }\n      totalRF.addAndGet(rf * coll.getSlices().size());\n    });\n    int totalMax = clusterState.getLiveNodes().size() * totalRF.get() * 3;\n    int maxOp = (Integer) autoScalingConfig.getProperties().getOrDefault(AutoScalingParams.MAX_COMPUTE_OPERATIONS, totalMax);\n    Object o = event.getProperty(AutoScalingParams.MAX_COMPUTE_OPERATIONS, maxOp);\n    try {\n      return Integer.parseInt(String.valueOf(o));\n    } catch (Exception e) {\n      log.warn(\"Invalid '{}' event property: {}, using default {}\", AutoScalingParams.MAX_COMPUTE_OPERATIONS, o, maxOp);\n      return maxOp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"3f504512a03d978990cbff30db0522b354e846db":["e35f2dde06b35aa9904949a3a93fabd090371077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["9f0e33082a86447f4f2b59a1a5f69a310500276a","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"e35f2dde06b35aa9904949a3a93fabd090371077":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"f592209545c71895260367152601e9200399776d":["9f0e33082a86447f4f2b59a1a5f69a310500276a","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d9ccfe45460d496c5e5e1b70396521dac842d966"],"d9ccfe45460d496c5e5e1b70396521dac842d966":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e35f2dde06b35aa9904949a3a93fabd090371077"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441","d9ccfe45460d496c5e5e1b70396521dac842d966"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"e35f2dde06b35aa9904949a3a93fabd090371077":["3f504512a03d978990cbff30db0522b354e846db"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["b70042a8a492f7054d480ccdd2be9796510d4327","ad60b6945c360ff89899d716d9cdec8dd674e2a0","f592209545c71895260367152601e9200399776d"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d9ccfe45460d496c5e5e1b70396521dac842d966":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}