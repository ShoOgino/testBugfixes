{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle(List<String> pivotFields,\n                                                                  String refinements) throws IOException {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle(List<String> pivotFields,\n                                                                  String refinements) throws IOException {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}