{"path":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","commits":[{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    finishSegmentStates(segmentStates);\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4987206dabc9f3576bb1df72e987094a7dad6e4f","date":1527510516,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getOriginalSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","bugFix":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"bugIntro":["183c6c48c88f771980fbee167337abf9932c6f80"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aef2a94da918b657d107b616a643e1759db43b6a","date":1527706131,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getDelCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.getDelCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getOriginalSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getOriginalSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["183c6c48c88f771980fbee167337abf9932c6f80"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"183c6c48c88f771980fbee167337abf9932c6f80","date":1558625128,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    try {\n      for (BufferedUpdatesStream.SegmentState segState : segStates) {\n        if (success) {\n          totDelCount += segState.rld.getDelCount() - segState.startDelCount;\n          int fullDelCount = segState.rld.getDelCount();\n          assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n          if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(segState.reader.getOriginalSegmentInfo());\n          }\n        }\n      }\n    } finally {\n      IOUtils.close(segStates);\n    }\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<BufferedUpdatesStream.SegmentState> segmentStates = Arrays.asList(segStates);\n    for (BufferedUpdatesStream.SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getDelCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.getDelCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getOriginalSegmentInfo());\n        }\n      }\n    }\n    IOUtils.close(segmentStates);\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","bugFix":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","4987206dabc9f3576bb1df72e987094a7dad6e4f","aef2a94da918b657d107b616a643e1759db43b6a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f21f1920c232db2352489eed260fe5c1f39e5a0","date":1587748041,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeSegmentStates(BufferedUpdatesStream.SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#closeSegmentStates(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  private BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    try {\n      for (BufferedUpdatesStream.SegmentState segState : segStates) {\n        if (success) {\n          totDelCount += segState.rld.getDelCount() - segState.startDelCount;\n          int fullDelCount = segState.rld.getDelCount();\n          assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n          if (segState.rld.isFullyDeleted() && getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(segState.reader.getOriginalSegmentInfo());\n          }\n        }\n      }\n    } finally {\n      IOUtils.close(segStates);\n    }\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + bufferedUpdatesStream.getPendingUpdatesCount() +  \" packets; bytesUsed=\" + readerPool.ramBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public static BufferedUpdatesStream.ApplyDeletesResult closeSegmentStates(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    try {\n      for (BufferedUpdatesStream.SegmentState segState : segStates) {\n        if (success) {\n          totDelCount += segState.rld.getDelCount() - segState.startDelCount;\n          int fullDelCount = segState.rld.getDelCount();\n          assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n          if (segState.rld.isFullyDeleted() && writer.getConfig().getMergePolicy().keepFullyDeletedSegment(() -> segState.reader) == false) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<>();\n            }\n            allDeleted.add(segState.reader.getOriginalSegmentInfo());\n          }\n        }\n      }\n    } finally {\n      IOUtils.close(segStates);\n    }\n    if (writer.infoStream.isEnabled(\"BD\")) {\n      writer.infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + writer.getPendingUpdatesCount()+ \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new BufferedUpdatesStream.ApplyDeletesResult(totDelCount > 0, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"183c6c48c88f771980fbee167337abf9932c6f80":["aef2a94da918b657d107b616a643e1759db43b6a"],"9f21f1920c232db2352489eed260fe5c1f39e5a0":["183c6c48c88f771980fbee167337abf9932c6f80"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aef2a94da918b657d107b616a643e1759db43b6a":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f21f1920c232db2352489eed260fe5c1f39e5a0"]},"commit2Childs":{"183c6c48c88f771980fbee167337abf9932c6f80":["9f21f1920c232db2352489eed260fe5c1f39e5a0"],"9f21f1920c232db2352489eed260fe5c1f39e5a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"aef2a94da918b657d107b616a643e1759db43b6a":["183c6c48c88f771980fbee167337abf9932c6f80"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["aef2a94da918b657d107b616a643e1759db43b6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}