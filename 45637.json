{"path":"lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.BM25FWeight#scorer(LeafReaderContext).mjava","commits":[{"id":"15c07295375e0ec8be1c0ec46de21292455b3af8","date":1542792270,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/BM25FQuery.BM25FWeight#scorer(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      List<PostingsEnum> iterators = new ArrayList<>();\n      List<FieldAndWeight> fields = new ArrayList<>();\n      for (int i = 0; i < fieldTerms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(fieldTerms[i].field()).iterator();\n          termsEnum.seekExact(fieldTerms[i].bytes(), state);\n          PostingsEnum postingsEnum = termsEnum.postings(null, PostingsEnum.FREQS);\n          iterators.add(postingsEnum);\n          fields.add(fieldAndWeights.get(fieldTerms[i].field()));\n        }\n      }\n\n      if (iterators.isEmpty()) {\n        return null;\n      }\n\n      // we must optimize this case (term not in segment), disjunctions require >= 2 subs\n      if (iterators.size() == 1) {\n        final LeafSimScorer scoringSimScorer =\n            new LeafSimScorer(simWeight, context.reader(), fields.get(0).field, true);\n        return new TermScorer(this, iterators.get(0), scoringSimScorer);\n      }\n      final MultiNormsLeafSimScorer scoringSimScorer =\n          new MultiNormsLeafSimScorer(simWeight, context.reader(), fields, true);\n      LeafSimScorer nonScoringSimScorer = new LeafSimScorer(simWeight, context.reader(), \"pseudo_field\", false);\n      // we use termscorers + disjunction as an impl detail\n      DisiPriorityQueue queue = new DisiPriorityQueue(iterators.size());\n      for (int i = 0; i < iterators.size(); i++) {\n        float weight = fields.get(i).weight;\n        queue.add(new WeightedDisiWrapper(new TermScorer(this, iterators.get(i), nonScoringSimScorer), weight));\n      }\n      // Even though it is called approximation, it is accurate since none of\n      // the sub iterators are two-phase iterators.\n      DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);\n      return new BM25FScorer(this, queue, iterator, scoringSimScorer);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15c07295375e0ec8be1c0ec46de21292455b3af8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15c07295375e0ec8be1c0ec46de21292455b3af8"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15c07295375e0ec8be1c0ec46de21292455b3af8"],"15c07295375e0ec8be1c0ec46de21292455b3af8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}