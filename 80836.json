{"path":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","commits":[{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    final String splitKey = \"a!\";\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", shardKey + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey + \"!\"))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_routekey_test_targetCollection\";\n\n    HashMap<String, List<Integer>> collectionInfos = new HashMap<String, List<Integer>>();\n    CloudSolrServer client = null;\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          REPLICATION_FACTOR, 1,\n          MAX_SHARDS_PER_NODE, 5,\n          NUM_SLICES, 1);\n\n      createCollection(collectionInfos, targetCollection, props, client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(targetCollection);\n    checkForCollection(targetCollection, list, null);\n\n    waitForRecoveriesToFinish(targetCollection, false);\n\n    class Indexer extends Thread {\n      final int seconds;\n\n      public Indexer(int seconds) {\n        this.seconds = seconds;\n      }\n\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        for (int id = 26*3; id < 500 && System.currentTimeMillis() - start <= seconds*1000; id++) {\n          String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", shardKey + \"!\" + id);\n          doc.addField(\"n_ti\", id);\n          try {\n            cloudClient.add(doc);\n            if (splitKey.equals(shardKey + \"!\"))\n              splitKeyCount[0]++;\n          } catch (Exception e) {\n            log.error(\"Exception while adding document id: \" + doc.getField(\"id\"), e);\n          }\n          try {\n            Thread.sleep(50);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n    Thread indexer = new Indexer(30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionParams.CollectionAction.MIGRATE.toString());\n    params.set(\"collection\", AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n    params.set(\"target.collection\", targetCollection);\n    params.set(\"split.key\", splitKey);\n    params.set(\"forward.timeout\", 45);\n\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n\n    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n\n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000 * 5);\n    baseServer.request(request);\n    baseServer.shutdown();\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n\n    try {\n      cloudClient.deleteById(\"a!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey));\n\n    boolean ruleRemoved = false;\n    while (System.currentTimeMillis() - finishTime < 60000) {\n      getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n      state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n      slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      Map<String,RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules == null || routingRules.isEmpty() || !routingRules.containsKey(splitKey)) {\n        ruleRemoved = true;\n        break;\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", splitKey + System.currentTimeMillis());\n      cloudClient.add(doc);\n      Thread.sleep(1000);\n    }\n\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on shard1_0 does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    printLayout();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ef0a91e147ef5c263ff965642f847b554b13ba2","date":1386676110,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    final String splitKey = \"a!\";\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", shardKey + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey + \"!\"))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_routekey_test_targetCollection\";\n\n    HashMap<String, List<Integer>> collectionInfos = new HashMap<String, List<Integer>>();\n    CloudSolrServer client = null;\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          REPLICATION_FACTOR, 1,\n          MAX_SHARDS_PER_NODE, 5,\n          NUM_SLICES, 1);\n\n      createCollection(collectionInfos, targetCollection, props, client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(targetCollection);\n    checkForCollection(targetCollection, list, null);\n\n    waitForRecoveriesToFinish(targetCollection, false);\n\n    class Indexer extends Thread {\n      final int seconds;\n\n      public Indexer(int seconds) {\n        this.seconds = seconds;\n      }\n\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        for (int id = 26*3; id < 500 && System.currentTimeMillis() - start <= seconds*1000; id++) {\n          String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", shardKey + \"!\" + id);\n          doc.addField(\"n_ti\", id);\n          try {\n            cloudClient.add(doc);\n            if (splitKey.equals(shardKey + \"!\"))\n              splitKeyCount[0]++;\n          } catch (Exception e) {\n            log.error(\"Exception while adding document id: \" + doc.getField(\"id\"), e);\n          }\n          try {\n            Thread.sleep(50);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n    Thread indexer = new Indexer(30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionParams.CollectionAction.MIGRATE.toString());\n    params.set(\"collection\", AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n    params.set(\"target.collection\", targetCollection);\n    params.set(\"split.key\", splitKey);\n    params.set(\"forward.timeout\", 45);\n\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n\n    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n\n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000 * 5);\n    baseServer.request(request);\n    baseServer.shutdown();\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n\n    try {\n      cloudClient.deleteById(\"a!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey));\n\n    boolean ruleRemoved = false;\n    while (System.currentTimeMillis() - finishTime < 60000) {\n      getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n      state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n      slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      Map<String,RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules == null || routingRules.isEmpty() || !routingRules.containsKey(splitKey)) {\n        ruleRemoved = true;\n        break;\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", splitKey + System.currentTimeMillis());\n      cloudClient.add(doc);\n      Thread.sleep(1000);\n    }\n\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on shard1_0 does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    final String splitKey = \"a!\";\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", shardKey + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey + \"!\"))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_routekey_test_targetCollection\";\n\n    HashMap<String, List<Integer>> collectionInfos = new HashMap<String, List<Integer>>();\n    CloudSolrServer client = null;\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          REPLICATION_FACTOR, 1,\n          MAX_SHARDS_PER_NODE, 5,\n          NUM_SLICES, 1);\n\n      createCollection(collectionInfos, targetCollection, props, client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(targetCollection);\n    checkForCollection(targetCollection, list, null);\n\n    waitForRecoveriesToFinish(targetCollection, false);\n\n    class Indexer extends Thread {\n      final int seconds;\n\n      public Indexer(int seconds) {\n        this.seconds = seconds;\n      }\n\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        for (int id = 26*3; id < 500 && System.currentTimeMillis() - start <= seconds*1000; id++) {\n          String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", shardKey + \"!\" + id);\n          doc.addField(\"n_ti\", id);\n          try {\n            cloudClient.add(doc);\n            if (splitKey.equals(shardKey + \"!\"))\n              splitKeyCount[0]++;\n          } catch (Exception e) {\n            log.error(\"Exception while adding document id: \" + doc.getField(\"id\"), e);\n          }\n          try {\n            Thread.sleep(50);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    }\n    Thread indexer = new Indexer(30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionParams.CollectionAction.MIGRATE.toString());\n    params.set(\"collection\", AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n    params.set(\"target.collection\", targetCollection);\n    params.set(\"split.key\", splitKey);\n    params.set(\"forward.timeout\", 45);\n\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n\n    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n\n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000 * 5);\n    baseServer.request(request);\n    baseServer.shutdown();\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n\n    try {\n      cloudClient.deleteById(\"a!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey));\n\n    boolean ruleRemoved = false;\n    while (System.currentTimeMillis() - finishTime < 60000) {\n      getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n      state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n      slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      Map<String,RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules == null || routingRules.isEmpty() || !routingRules.containsKey(splitKey)) {\n        ruleRemoved = true;\n        break;\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", splitKey + System.currentTimeMillis());\n      cloudClient.add(doc);\n      Thread.sleep(1000);\n    }\n\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on shard1_0 does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"679316dff7b219caf97c37f180bef79c64a1bfdd","date":1403698197,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    if (usually()) {\n      log.info(\"Using legacyCloud=false for cluster\");\n      CollectionsAPIDistributedZkTest.setClusterProp(cloudClient, \"legacyCloud\", \"false\");\n    }\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    if (usually()) {\n      log.info(\"Using legacyCloud=false for cluster\");\n      CollectionsAPIDistributedZkTest.setClusterProp(cloudClient, \"legacyCloud\", \"false\");\n    }\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    if (usually()) {\n      log.info(\"Using legacyCloud=false for cluster\");\n      CollectionsAPIDistributedZkTest.setClusterProp(cloudClient, \"legacyCloud\", \"false\");\n    }\n    multipleShardMigrateTest();\n    printLayout();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da888af1ab894358122a22229051215f58cf4d54":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"abb23fcc2461782ab204e61213240feb77d355aa":["679316dff7b219caf97c37f180bef79c64a1bfdd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","5ef0a91e147ef5c263ff965642f847b554b13ba2"],"679316dff7b219caf97c37f180bef79c64a1bfdd":["5ef0a91e147ef5c263ff965642f847b554b13ba2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["da888af1ab894358122a22229051215f58cf4d54"]},"commit2Childs":{"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","5ef0a91e147ef5c263ff965642f847b554b13ba2"],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["da888af1ab894358122a22229051215f58cf4d54"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"679316dff7b219caf97c37f180bef79c64a1bfdd":["abb23fcc2461782ab204e61213240feb77d355aa"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","679316dff7b219caf97c37f180bef79c64a1bfdd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}