{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toWriteableBufferList().mjava","commits":[{"id":"fad01f81cc24b33263ccec7dbff3fb907702f91e","date":1535461373,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toWriteableBufferList().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a list of writeable blocks over the (source) content buffers.\n   * \n   * This method returns the raw content of source buffers that may change over the lifetime \n   * of this object (blocks can be recycled or discarded, for example). Most applications \n   * should favor calling {@link #toBufferList()} which returns a read-only <i>view</i> over \n   * the content of the source buffers.\n   * \n   * The difference between {@link #toBufferList()} and {@link #toWriteableBufferList()} is that\n   * read-only view of source buffers will always return {@code false} from {@link ByteBuffer#hasArray()}\n   * (which sometimes may be required to avoid double copying).\n   */\n  public ArrayList<ByteBuffer> toWriteableBufferList() {\n    ArrayList<ByteBuffer> result = new ArrayList<>(Math.max(blocks.size(), 1));\n    if (blocks.isEmpty()) {\n      result.add(EMPTY);\n    } else {\n      for (ByteBuffer bb : blocks) {\n        bb = (ByteBuffer) bb.duplicate().flip(); // cast for jdk8 (covariant in jdk9+) \n        result.add(bb);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toWriteableBufferList().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toWriteableBufferList().mjava","sourceNew":"  /**\n   * Returns a list of writeable blocks over the (source) content buffers.\n   * \n   * This method returns the raw content of source buffers that may change over the lifetime \n   * of this object (blocks can be recycled or discarded, for example). Most applications \n   * should favor calling {@link #toBufferList()} which returns a read-only <i>view</i> over \n   * the content of the source buffers.\n   * \n   * The difference between {@link #toBufferList()} and {@link #toWriteableBufferList()} is that\n   * read-only view of source buffers will always return {@code false} from {@link ByteBuffer#hasArray()}\n   * (which sometimes may be required to avoid double copying).\n   */\n  public ArrayList<ByteBuffer> toWriteableBufferList() {\n    ArrayList<ByteBuffer> result = new ArrayList<>(Math.max(blocks.size(), 1));\n    if (blocks.isEmpty()) {\n      result.add(EMPTY);\n    } else {\n      for (ByteBuffer bb : blocks) {\n        bb = bb.duplicate().flip();\n        result.add(bb);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of writeable blocks over the (source) content buffers.\n   * \n   * This method returns the raw content of source buffers that may change over the lifetime \n   * of this object (blocks can be recycled or discarded, for example). Most applications \n   * should favor calling {@link #toBufferList()} which returns a read-only <i>view</i> over \n   * the content of the source buffers.\n   * \n   * The difference between {@link #toBufferList()} and {@link #toWriteableBufferList()} is that\n   * read-only view of source buffers will always return {@code false} from {@link ByteBuffer#hasArray()}\n   * (which sometimes may be required to avoid double copying).\n   */\n  public ArrayList<ByteBuffer> toWriteableBufferList() {\n    ArrayList<ByteBuffer> result = new ArrayList<>(Math.max(blocks.size(), 1));\n    if (blocks.isEmpty()) {\n      result.add(EMPTY);\n    } else {\n      for (ByteBuffer bb : blocks) {\n        bb = (ByteBuffer) bb.duplicate().flip(); // cast for jdk8 (covariant in jdk9+) \n        result.add(bb);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}