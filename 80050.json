{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","commits":[{"id":"edf5b262a72d10530eb2f01dc8f19060355b213e","date":1557765866,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, ReplicaInfo>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<ReplicaInfo>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Set<String> csCores = allReplicas.getOrDefault(collection, Collections.emptyMap()).keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k))\n            .collect(Collectors.toSet());\n        throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n            \"replica not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n            \"replica not in NodeStateProvider: \" + notInNodeProvider);\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d","date":1571856490,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, ReplicaInfo>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<ReplicaInfo>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Map<String, Replica> replicas = allReplicas.getOrDefault(collection, Collections.emptyMap());\n      Set<String> csCores = replicas.keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k) && replicas.get(k).isActive(solrCloudManager.getClusterStateProvider().getLiveNodes()))\n            .collect(Collectors.toSet());\n        if (!notInClusterState.isEmpty() || !notInNodeProvider.isEmpty()) {\n          throw new RuntimeException(\"Mismatched replica data for collection \" + collection + \" between ClusterState and NodeStateProvider:\\n\\t\" +\n              \"replica in NodeStateProvider but not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n              \"replica in ClusterState but not in NodeStateProvider: \" + notInNodeProvider);\n        }\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","sourceOld":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, ReplicaInfo>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<ReplicaInfo>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Set<String> csCores = allReplicas.getOrDefault(collection, Collections.emptyMap()).keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k))\n            .collect(Collectors.toSet());\n        throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n            \"replica not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n            \"replica not in NodeStateProvider: \" + notInNodeProvider);\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, Replica>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<Replica>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Map<String, Replica> replicas = allReplicas.getOrDefault(collection, Collections.emptyMap());\n      Set<String> csCores = replicas.keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k) && replicas.get(k).isActive(solrCloudManager.getClusterStateProvider().getLiveNodes()))\n            .collect(Collectors.toSet());\n        if (!notInClusterState.isEmpty() || !notInNodeProvider.isEmpty()) {\n          throw new RuntimeException(\"Mismatched replica data for collection \" + collection + \" between ClusterState and NodeStateProvider:\\n\\t\" +\n              \"replica in NodeStateProvider but not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n              \"replica in ClusterState but not in NodeStateProvider: \" + notInNodeProvider);\n        }\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.get(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.get(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","sourceOld":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, ReplicaInfo>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<ReplicaInfo>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Map<String, Replica> replicas = allReplicas.getOrDefault(collection, Collections.emptyMap());\n      Set<String> csCores = replicas.keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k) && replicas.get(k).isActive(solrCloudManager.getClusterStateProvider().getLiveNodes()))\n            .collect(Collectors.toSet());\n        if (!notInClusterState.isEmpty() || !notInNodeProvider.isEmpty()) {\n          throw new RuntimeException(\"Mismatched replica data for collection \" + collection + \" between ClusterState and NodeStateProvider:\\n\\t\" +\n              \"replica in NodeStateProvider but not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n              \"replica in ClusterState but not in NodeStateProvider: \" + notInNodeProvider);\n        }\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimUtils#checkConsistency(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":null,"sourceOld":"  /**\n   * Check consistency of data in a {@link SolrCloudManager}. This may be needed when constructing a simulated\n   * instance from potentially inconsistent data (eg. partial snapshots taken at different points in time).\n   * @param solrCloudManager source manager\n   * @param config optional {@link AutoScalingConfig} instance used to determine what node and replica metrics to check.\n   */\n  public static void checkConsistency(SolrCloudManager solrCloudManager, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = solrCloudManager.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> replicaTags = new HashSet<>(COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n\n    // verify replicas are consistent and data is available\n    Map<String, Map<String, Replica>> allReplicas = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getClusterState().forEachCollection(coll -> {\n      coll.getReplicas().forEach(r -> {\n        if (allReplicas.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in clusterState: \" + allReplicas.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicas.computeIfAbsent(coll.getName(), c -> new HashMap<>()).put(r.getName(), r);\n        }\n      });\n    });\n    Map<String, Map<String, Replica>> allReplicaInfos = new HashMap<>();\n    solrCloudManager.getClusterStateProvider().getLiveNodes().forEach(n -> {\n      Map<String, Map<String, List<Replica>>> infos = solrCloudManager.getNodeStateProvider().getReplicaInfo(n, replicaTags);\n      infos.forEach((coll, shards) -> shards.forEach((shard, replicas) -> replicas.forEach(r -> {\n        if (allReplicaInfos.containsKey(r.getName())) {\n          throw new RuntimeException(\"duplicate core_node name in NodeStateProvider: \" + allReplicaInfos.get(r.getName()) + \" versus \" + r);\n        } else {\n          allReplicaInfos.computeIfAbsent(coll, c -> new HashMap<>()).put(r.getName(), r);\n        }\n      })));\n    });\n    if (!allReplicaInfos.keySet().equals(allReplicas.keySet())) {\n      Set<String> notInClusterState = allReplicaInfos.keySet().stream()\n          .filter(k -> !allReplicas.containsKey(k))\n          .collect(Collectors.toSet());\n      Set<String> notInNodeProvider = allReplicas.keySet().stream()\n          .filter(k -> !allReplicaInfos.containsKey(k))\n          .collect(Collectors.toSet());\n      throw new RuntimeException(\"Mismatched replica data between ClusterState and NodeStateProvider:\\n\\t\" +\n          \"collection not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n          \"collection not in NodeStateProvider: \" + notInNodeProvider);\n    }\n    allReplicaInfos.keySet().forEach(collection -> {\n      Set<String> infosCores = allReplicaInfos.getOrDefault(collection, Collections.emptyMap()).keySet();\n      Map<String, Replica> replicas = allReplicas.getOrDefault(collection, Collections.emptyMap());\n      Set<String> csCores = replicas.keySet();\n      if (!infosCores.equals(csCores)) {\n        Set<String> notInClusterState = infosCores.stream()\n            .filter(k -> !csCores.contains(k))\n            .collect(Collectors.toSet());\n        Set<String> notInNodeProvider = csCores.stream()\n            .filter(k -> !infosCores.contains(k) && replicas.get(k).isActive(solrCloudManager.getClusterStateProvider().getLiveNodes()))\n            .collect(Collectors.toSet());\n        if (!notInClusterState.isEmpty() || !notInNodeProvider.isEmpty()) {\n          throw new RuntimeException(\"Mismatched replica data for collection \" + collection + \" between ClusterState and NodeStateProvider:\\n\\t\" +\n              \"replica in NodeStateProvider but not in ClusterState: \" + notInClusterState + \"\\n\\t\" +\n              \"replica in ClusterState but not in NodeStateProvider: \" + notInNodeProvider);\n        }\n      }\n    });\n    // verify all replicas have size info\n    allReplicaInfos.forEach((coll, replicas) -> replicas.forEach((core, ri) -> {\n          Number size = (Number) ri.get(Variable.Type.CORE_IDX.metricsAttribute);\n          if (size == null) {\n            size = (Number) ri.get(Variable.Type.CORE_IDX.tagName);\n            if (size == null) {\n//              for (String node : solrCloudManager.getClusterStateProvider().getLiveNodes()) {\n//                log.error(\"Check for missing values: {}: {}\", node, solrCloudManager.getNodeStateProvider().getReplicaInfo(node, SnapshotNodeStateProvider.REPLICA_TAGS));\n//              }\n              throw new RuntimeException(\"missing replica size information: \" + ri);\n            }\n          }\n        }\n    ));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["edf5b262a72d10530eb2f01dc8f19060355b213e"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}