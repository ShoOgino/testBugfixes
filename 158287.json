{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private synchronized void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ClusterState state = getClusterState();\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        Replica leader = s.getLeader();\n        if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n          LOG.trace(\"Running leader election for \" + dc.getName() + \" / \" + s.getName());\n          if (s.getReplicas().isEmpty()) { // no replicas - punt\n            return;\n          }\n          // mark all replicas as non-leader (probably not necessary) and collect all active and live\n          List<ReplicaInfo> active = new ArrayList<>();\n          s.getReplicas().forEach(r -> {\n            AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n            // find our ReplicaInfo for this replica\n            nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n              if (info.getName().equals(r.getName())) {\n                riRef.set(info);\n              }\n            });\n            ReplicaInfo ri = riRef.get();\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n                stateChanged.set(true);\n              }\n              if (r.isActive(liveNodes.get())) {\n                active.add(ri);\n              } else { // if it's on a node that is not live mark it down\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                }\n              }\n            }\n          });\n          if (active.isEmpty()) {\n            LOG.warn(\"-- can't find any active replicas for \" + dc.getName() + \" / \" + s.getName());\n            return;\n          }\n          // pick first active one\n          ReplicaInfo ri = null;\n          for (ReplicaInfo a : active) {\n            if (!a.getType().equals(Replica.Type.PULL)) {\n              ri = a;\n              break;\n            }\n          }\n          if (ri == null) {\n            LOG.warn(\"-- can't find any suitable replica type for \" + dc.getName() + \" / \" + s.getName());\n            return;\n          }\n          synchronized (ri) {\n            ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n          }\n          stateChanged.set(true);\n          LOG.debug(\"-- elected new leader for \" + dc.getName() + \" / \" + s.getName() + \": \" + ri);\n        } else {\n          LOG.trace(\"-- already has leader for {} / {}\", dc.getName(), s.getName());\n        }\n      });\n    });\n    if (saveClusterState || stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ClusterState state = getClusterState();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s ->\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        })\n      );\n    });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private synchronized void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ClusterState state = getClusterState();\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        Replica leader = s.getLeader();\n        if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n          LOG.trace(\"Running leader election for \" + dc.getName() + \" / \" + s.getName());\n          if (s.getReplicas().isEmpty()) { // no replicas - punt\n            return;\n          }\n          // mark all replicas as non-leader (probably not necessary) and collect all active and live\n          List<ReplicaInfo> active = new ArrayList<>();\n          s.getReplicas().forEach(r -> {\n            AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n            // find our ReplicaInfo for this replica\n            nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n              if (info.getName().equals(r.getName())) {\n                riRef.set(info);\n              }\n            });\n            ReplicaInfo ri = riRef.get();\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n                stateChanged.set(true);\n              }\n              if (r.isActive(liveNodes.get())) {\n                active.add(ri);\n              } else { // if it's on a node that is not live mark it down\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                }\n              }\n            }\n          });\n          if (active.isEmpty()) {\n            LOG.warn(\"-- can't find any active replicas for \" + dc.getName() + \" / \" + s.getName());\n            return;\n          }\n          // pick first active one\n          ReplicaInfo ri = null;\n          for (ReplicaInfo a : active) {\n            if (!a.getType().equals(Replica.Type.PULL)) {\n              ri = a;\n              break;\n            }\n          }\n          if (ri == null) {\n            LOG.warn(\"-- can't find any suitable replica type for \" + dc.getName() + \" / \" + s.getName());\n            return;\n          }\n          synchronized (ri) {\n            ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n          }\n          stateChanged.set(true);\n          LOG.debug(\"-- elected new leader for \" + dc.getName() + \" / \" + s.getName() + \": \" + ri);\n        } else {\n          LOG.trace(\"-- already has leader for {} / {}\", dc.getName(), s.getName());\n        }\n      });\n    });\n    if (saveClusterState || stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getLeader() != null) {\n          LOG.debug(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          LOG.debug(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        LOG.debug(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ClusterState state = getClusterState();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s ->\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        })\n      );\n    });\n  }\n\n","bugFix":["a4422b331d00607258b0ed3e43934306e67764aa","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getLeader() != null) {\n          log.debug(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.debug(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.debug(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getLeader() != null) {\n          LOG.debug(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          LOG.debug(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        LOG.debug(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getState() == Slice.State.INACTIVE) {\n          log.trace(\"-- slice state is {}, skip leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n          return;\n        }\n        if (s.getState() != Slice.State.ACTIVE) {\n          log.trace(\"-- slice state is {}, but I will run leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n        }\n        if (s.getLeader() != null) {\n          log.trace(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.trace(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getLeader() != null) {\n          log.debug(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.debug(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.debug(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"374cde0030d329720d59d1c6336d1089bbcd6fd9","date":1544808129,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      lock.lockInterruptibly();\n      try {\n        collectionsStatesRef.set(null);\n      } finally {\n        lock.unlock();\n      }\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getState() == Slice.State.INACTIVE) {\n          log.trace(\"-- slice state is {}, skip leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n          return;\n        }\n        if (s.getState() != Slice.State.ACTIVE) {\n          log.trace(\"-- slice state is {}, but I will run leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n        }\n        if (s.getLeader() != null) {\n          log.trace(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.trace(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      collectionsStatesRef.set(null);\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getState() == Slice.State.INACTIVE) {\n          log.trace(\"-- slice state is {}, skip leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n          return;\n        }\n        if (s.getState() != Slice.State.ACTIVE) {\n          log.trace(\"-- slice state is {}, but I will run leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n        }\n        if (s.getLeader() != null) {\n          log.trace(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.trace(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      lock.lockInterruptibly();\n      try {\n        collectionsStatesRef.set(null);\n      } finally {\n        lock.unlock();\n      }\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n        if (!collections.contains(dc.getName())) {\n          return;\n        }\n        dc.getSlices().forEach(s -> {\n            log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n            cloudManager.submit(() -> {\n                simRunLeaderElection(dc.getName(), s.getName(), saveClusterState);\n                return true;\n              });\n          });\n      });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      lock.lockInterruptibly();\n      try {\n        collectionsStatesRef.set(null);\n      } finally {\n        lock.unlock();\n      }\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n      if (!collections.contains(dc.getName())) {\n        return;\n      }\n      dc.getSlices().forEach(s -> {\n        if (s.getState() == Slice.State.INACTIVE) {\n          log.trace(\"-- slice state is {}, skip leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n          return;\n        }\n        if (s.getState() != Slice.State.ACTIVE) {\n          log.trace(\"-- slice state is {}, but I will run leader election {} / {}\", s.getState(), dc.getName(), s.getName());\n        }\n        if (s.getLeader() != null) {\n          log.trace(\"-- already has leader {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        if (s.getReplicas().isEmpty()) {\n          log.trace(\"-- no replicas in {} / {}\", dc.getName(), s.getName());\n          return;\n        }\n        log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n        cloudManager.submit(() -> {\n          simRunLeaderElection(dc.getName(), s, saveClusterState);\n          return true;\n        });\n      });\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(Collection[String],boolean).mjava","sourceNew":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      lock.lockInterruptibly();\n      try {\n        collectionsStatesRef.set(null);\n      } finally {\n        lock.unlock();\n      }\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n        if (!collections.contains(dc.getName())) {\n          return;\n        }\n        dc.getSlices().forEach(s -> {\n            log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n            cloudManager.submit(() -> {\n                simRunLeaderElection(dc.getName(), s.getName(), saveClusterState);\n                return true;\n              });\n          });\n      });\n  }\n\n","sourceOld":"  /**\n   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.\n   * If a new leader is elected the cluster state is saved.\n   * @param collections list of affected collections\n   * @param saveClusterState if true then save cluster state regardless of changes.\n   */\n  private void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {\n    ensureNotClosed();\n    if (saveClusterState) {\n      lock.lockInterruptibly();\n      try {\n        collectionsStatesRef.set(null);\n      } finally {\n        lock.unlock();\n      }\n    }\n    ClusterState state = getClusterState();\n    state.forEachCollection(dc -> {\n        if (!collections.contains(dc.getName())) {\n          return;\n        }\n        dc.getSlices().forEach(s -> {\n            log.trace(\"-- submit leader election for {} / {}\", dc.getName(), s.getName());\n            cloudManager.submit(() -> {\n                simRunLeaderElection(dc.getName(), s.getName(), saveClusterState);\n                return true;\n              });\n          });\n      });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["a4422b331d00607258b0ed3e43934306e67764aa"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a4422b331d00607258b0ed3e43934306e67764aa":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a4422b331d00607258b0ed3e43934306e67764aa":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a4422b331d00607258b0ed3e43934306e67764aa"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}