{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","commits":[{"id":"e8550173e67bccdaad7c5cbb85fb81886fecfcb7","date":1376943063,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d50d971859a3c7841c17117b0aac14e733441ebf","date":1384264257,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return reader;\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dac1db31006989ae24922811f00f909d30f1391d","date":1387560411,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(bytes));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        return reader;\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf","date":1402500925,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, maxDoc, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, maxDoc, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case UNCOMPRESSED:\n        final byte bytes[] = new byte[maxDoc];\n        data.readBytes(bytes, 0, bytes.length);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(bytes));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return bytes[docID];\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int quotientBlockSize = data.readVInt();\n        final BlockPackedReader quotientReader = new BlockPackedReader(data, entry.packedIntsVersion, quotientBlockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14ffaac9c4a4a2c750bf0cd956506802561e062","date":1402602036,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, maxDoc, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, maxDoc, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, maxDoc, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, maxDoc, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, maxDoc, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, maxDoc, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0936055c0eed56be3e4ae5c9db5b0e355390736a","date":1410874015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.number);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a70ce9bddc6f985feb8e5e182aebe20872328d4","date":1411172748,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, input=\" + data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":["e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f80fee115148a0e4a0574560be06b494de821","date":1412069872,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        ramBytesUsed.addAndGet(reader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n        numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e1de7ca6cb231a67006f9dc4842722d219629fb","date":1453654393,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"340c74377cb6e5e48360c014b3fc076221746443","date":1476809457,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad214b6ec1400de3c40b6c120126abe89d51a9ce","date":1476818670,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","sourceOld":"  private NumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return reader;\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new NumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f89e8a6aac05753cde4c83d62a74356098200d","date":1525768331,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer#loadNumeric(FieldInfo).mjava","sourceNew":null,"sourceOld":"  private LegacyNumericDocValues loadNumeric(FieldInfo field) throws IOException {\n    NumericEntry entry = numerics.get(field.name);\n    IndexInput data = this.data.clone();\n    data.seek(entry.offset + entry.missingBytes);\n    switch (entry.format) {\n      case TABLE_COMPRESSED:\n        int size = data.readVInt();\n        if (size > 256) {\n          throw new CorruptIndexException(\"TABLE_COMPRESSED cannot have more than 256 distinct values, got=\" + size, data);\n        }\n        final long decode[] = new long[size];\n        for (int i = 0; i < decode.length; i++) {\n          decode[i] = data.readLong();\n        }\n        final int formatID = data.readVInt();\n        final int bitsPerValue = data.readVInt();\n        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), entry.packedIntsVersion, (int)entry.count, bitsPerValue);\n        if (!merging) {\n          ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"table compressed\", ordsReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return decode[(int)ordsReader.get(docID)];\n          }\n        };\n      case DELTA_COMPRESSED:\n        final long minDelta = data.readLong();\n        final int formatIDDelta = data.readVInt();\n        final int bitsPerValueDelta = data.readVInt();\n        final PackedInts.Reader deltaReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDDelta), entry.packedIntsVersion, (int)entry.count, bitsPerValueDelta);\n        if (!merging) {\n          ramBytesUsed.addAndGet(deltaReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"delta compressed\", deltaReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return minDelta + deltaReader.get(docID);\n          }\n        };\n      case BLOCK_COMPRESSED:\n        final int blockSize = data.readVInt();\n        final BlockPackedReader reader = new BlockPackedReader(data, entry.packedIntsVersion, blockSize, entry.count, false);\n        if (!merging) {\n          ramBytesUsed.addAndGet(reader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"block compressed\", reader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return reader.get(docID);\n          }\n        };\n      case GCD_COMPRESSED:\n        final long min = data.readLong();\n        final long mult = data.readLong();\n        final int formatIDGCD = data.readVInt();\n        final int bitsPerValueGCD = data.readVInt();\n        final PackedInts.Reader quotientReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatIDGCD), entry.packedIntsVersion, (int)entry.count, bitsPerValueGCD);\n        if (!merging) {\n          ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());\n          numericInfo.put(field.name, Accountables.namedAccountable(\"gcd compressed\", quotientReader));\n        }\n        return new LegacyNumericDocValues() {\n          @Override\n          public long get(int docID) {\n            return min + mult * quotientReader.get(docID);\n          }\n        };\n      default:\n        throw new AssertionError();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf":["dac1db31006989ae24922811f00f909d30f1391d"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"340c74377cb6e5e48360c014b3fc076221746443":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3e1de7ca6cb231a67006f9dc4842722d219629fb","ad214b6ec1400de3c40b6c120126abe89d51a9ce"],"d50d971859a3c7841c17117b0aac14e733441ebf":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"ad214b6ec1400de3c40b6c120126abe89d51a9ce":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","340c74377cb6e5e48360c014b3fc076221746443"],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["0936055c0eed56be3e4ae5c9db5b0e355390736a"],"bc8f80fee115148a0e4a0574560be06b494de821":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"24f89e8a6aac05753cde4c83d62a74356098200d":["ad214b6ec1400de3c40b6c120126abe89d51a9ce"],"9bb9a29a5e71a90295f175df8919802993142c9a":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","bc8f80fee115148a0e4a0574560be06b494de821"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3e1de7ca6cb231a67006f9dc4842722d219629fb","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["3e1de7ca6cb231a67006f9dc4842722d219629fb"],"dac1db31006989ae24922811f00f909d30f1391d":["d50d971859a3c7841c17117b0aac14e733441ebf"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["d14ffaac9c4a4a2c750bf0cd956506802561e062"],"3e1de7ca6cb231a67006f9dc4842722d219629fb":["9bb9a29a5e71a90295f175df8919802993142c9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24f89e8a6aac05753cde4c83d62a74356098200d"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf"]},"commit2Childs":{"b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","d50d971859a3c7841c17117b0aac14e733441ebf"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"340c74377cb6e5e48360c014b3fc076221746443":["ad214b6ec1400de3c40b6c120126abe89d51a9ce"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d50d971859a3c7841c17117b0aac14e733441ebf":["dac1db31006989ae24922811f00f909d30f1391d"],"ad214b6ec1400de3c40b6c120126abe89d51a9ce":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","24f89e8a6aac05753cde4c83d62a74356098200d"],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["bc8f80fee115148a0e4a0574560be06b494de821","9bb9a29a5e71a90295f175df8919802993142c9a"],"bc8f80fee115148a0e4a0574560be06b494de821":["9bb9a29a5e71a90295f175df8919802993142c9a"],"24f89e8a6aac05753cde4c83d62a74356098200d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9bb9a29a5e71a90295f175df8919802993142c9a":["3e1de7ca6cb231a67006f9dc4842722d219629fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["340c74377cb6e5e48360c014b3fc076221746443","ad214b6ec1400de3c40b6c120126abe89d51a9ce"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"dac1db31006989ae24922811f00f909d30f1391d":["b3f1f6da1318f50d5d7c35654b84bf25cddc7ecf"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"3e1de7ca6cb231a67006f9dc4842722d219629fb":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","0936055c0eed56be3e4ae5c9db5b0e355390736a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c6f080a2ab37c464dd98db173f6cbf10dc74f211","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}