{"path":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","commits":[{"id":"e7a005111928c661ab5d236ed6a3a079b438d2cf","date":1205411670,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["317c809622a7a74e9257dd0eaf0b7c4dd7399bc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"317c809622a7a74e9257dd0eaf0b7c4dd7399bc7","date":1214673815,"type":3,"author":"Karl-Johan Wettin","isMerge":false,"pathNew":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","pathOld":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","sourceNew":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n\n\n  }\n\n","bugFix":["e7a005111928c661ab5d236ed6a3a079b438d2cf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c41356c8a19fd7493940c7a1d798ede2fe03ddf8","date":1260481087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","pathOld":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","sourceNew":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      // mimic SegmentTermDocs that positions at the last index\n      currentDocumentIndex = currentTerm.getAssociatedDocuments().length -1;\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","pathOld":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTermDocs#skipTo(int).mjava","sourceNew":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      // mimic SegmentTermDocs that positions at the last index\n      currentDocumentIndex = currentTerm.getAssociatedDocuments().length -1;\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":"  /**\n   * Skips entries to the first beyond the current whose document number is\n   * greater than or equal to <i>target</i>. <p>Returns true if there is such\n   * an entry.  <p>Behaves as if written: <pre>\n   *   boolean skipTo(int target) {\n   *     do {\n   *       if (!next())\n   * \t     return false;\n   *     } while (target > doc());\n   *     return true;\n   *   }\n   * </pre>\n   * This implementation is considerably more efficient than that.\n   *\n   */\n  public boolean skipTo(int target) {\n    if (currentTerm == null) {\n      return false;\n    }\n    \n    if (currentDocumentIndex >= target) {\n      return next();\n    }\n\n    int startOffset = currentDocumentIndex >= 0 ? currentDocumentIndex : 0;\n    int pos = currentTerm.seekCeilingDocumentInformationIndex(target, startOffset);\n\n    if (pos == -1) {\n      // mimic SegmentTermDocs that positions at the last index\n      currentDocumentIndex = currentTerm.getAssociatedDocuments().length -1;\n      return false;\n    }\n\n    currentDocumentInformation = currentTerm.getAssociatedDocuments()[pos];\n    currentDocumentIndex = pos;\n    if (reader.hasDeletions() && reader.isDeleted(currentDocumentInformation.getDocument().getDocumentNumber())) {\n      return next();\n    } else {\n      return true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c41356c8a19fd7493940c7a1d798ede2fe03ddf8":["317c809622a7a74e9257dd0eaf0b7c4dd7399bc7"],"317c809622a7a74e9257dd0eaf0b7c4dd7399bc7":["e7a005111928c661ab5d236ed6a3a079b438d2cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e7a005111928c661ab5d236ed6a3a079b438d2cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["c41356c8a19fd7493940c7a1d798ede2fe03ddf8"]},"commit2Childs":{"c41356c8a19fd7493940c7a1d798ede2fe03ddf8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"317c809622a7a74e9257dd0eaf0b7c4dd7399bc7":["c41356c8a19fd7493940c7a1d798ede2fe03ddf8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e7a005111928c661ab5d236ed6a3a079b438d2cf"],"e7a005111928c661ab5d236ed6a3a079b438d2cf":["317c809622a7a74e9257dd0eaf0b7c4dd7399bc7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}