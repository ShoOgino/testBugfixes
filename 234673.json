{"path":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","commits":[{"id":"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0","date":1383246815,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"/dev/null","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f8973f28b29873ff0d7a016e562c9036ae649a9","date":1428098193,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6554f36a4636755009195a7840518bf6b4f03d6c","date":1481906808,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;   // number of committers at a time... it should be <= maxWarmingSearchers\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5de502b5478255493125e7e801411ba17a6682ec","date":1490974101,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f20fd35e3055a0c5b387df0b986a68d65d86441","date":1491045405,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(field) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3714bcf66a68a1600e9dd11442fc1b33b62ef088","date":1556832005,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id=\" + id + \" found=\" + response + \" model\" + info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestStressUserVersions#testStressReorderVersions().mjava","sourceNew":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              @SuppressWarnings({\"rawtypes\"})\n              Map rsp = (Map) Utils.fromJSONString(response);\n              @SuppressWarnings({\"rawtypes\"})\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","sourceOld":"  // This version simulates user versions sometimes being reordered.\n  // It should fail (and currently does) if optimistic concurrency is disabled (cmd.setVersion(currVersion))\n  // in DocBasedVersionConstraintsProcessor.\n  @Test\n  public void testStressReorderVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); // what percent of the commits are soft\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(8);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    // query variables\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(10000);  // number of query operations to perform in total - ramp up for a longer test\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    /** // testing\n     final int commitPercent = 5;\n     final int softCommitPercent = 100; // what percent of the commits are soft\n     final int deletePercent = 0;\n     final int deleteByQueryPercent = 50;\n     final int ndocs = 1;\n     int nWriteThreads = 2;\n\n     final int maxConcurrentCommits = nWriteThreads;\n\n     // query variables\n     final int percentRealtimeQuery = 101;\n     final AtomicLong operations = new AtomicLong(50000);  // number of query operations to perform in total\n     int nReadThreads = 1;\n     **/\n\n\n    verbose(\"commitPercent\",commitPercent, \"softCommitPercent\",softCommitPercent, \"deletePercent\",deletePercent, \"deleteByQueryPercent\",deleteByQueryPercent\n        , \"ndocs\",ndocs,\"nWriteThreads\",nWriteThreads,\"percentRealtimeQuery\",percentRealtimeQuery,\"operations\",operations, \"nReadThreads\",nReadThreads);\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(TestStressUserVersions.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(TestStressUserVersions.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              // the version we set on the update should determine who wins\n              // These versions are not derived from the actual leader update handler hand hence this\n              // test may need to change depending on how we handle version numbers.\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(dversion, Long.toString(version)));\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), vfield, Long.toString(version)), null);\n\n                // only update model if the version is newer\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              // }   // end sync\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              // bias toward a recently changed doc\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              // when indexing, we update the index, then the model\n              // so when querying, we should first check the model, and then the index\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestStressUserVersions.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                // there's no info we can get back with a delete, so not much we can check without further synchronization\n              } else {\n                assertEquals(1, doclist.size());\n                boolean isLive = (Boolean)(((Map)doclist.get(0)).get(lfield));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(vfield));\n\n                if (isLive) {\n                  long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                  if (foundVer < Math.abs(info.version)\n                      || (foundVer == info.version && foundVal != info.val) ) {    // if the version matches, the val must\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                } else {\n                  // if the doc is deleted (via tombstone), it shouldn't have a value on it.\n                  assertNull( ((Map)doclist.get(0)).get(FIELD) );\n\n                  if (foundVer < Math.abs(info.version)) {\n                    log.error(\"ERROR, id={} found={} model {}\", id, response, info);\n                    assertTrue(false);\n                  }\n                }\n\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            log.error(\"\",e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"5de502b5478255493125e7e801411ba17a6682ec":["6554f36a4636755009195a7840518bf6b4f03d6c"],"6554f36a4636755009195a7840518bf6b4f03d6c":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["3f8973f28b29873ff0d7a016e562c9036ae649a9","6554f36a4636755009195a7840518bf6b4f03d6c"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":["6554f36a4636755009195a7840518bf6b4f03d6c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["5de502b5478255493125e7e801411ba17a6682ec"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"5de502b5478255493125e7e801411ba17a6682ec":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"6554f36a4636755009195a7840518bf6b4f03d6c":["5de502b5478255493125e7e801411ba17a6682ec","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","6f20fd35e3055a0c5b387df0b986a68d65d86441"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"6f20fd35e3055a0c5b387df0b986a68d65d86441":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["6554f36a4636755009195a7840518bf6b4f03d6c","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["e98520789adb1d5ad05afb4956eca0944a929688"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","6f20fd35e3055a0c5b387df0b986a68d65d86441","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}