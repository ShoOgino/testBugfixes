{"path":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","commits":[{"id":"50e7972fe4865715af8951d4ba15555e3426fc5d","date":1115024647,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"/dev/null","sourceNew":"\tprivate void run(String[] args) throws Throwable {\n\t\tint k = -1;\n\t\t\n\t\tint iters = 1;\n\t\tif (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n\t\t\n\t\tint runs = 1;\n\t\tif (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n\t\t\n\t\tString cmd = \"memram\";\n\t\tif (args.length > ++k) cmd = args[k];\n\t\tboolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n\t\tboolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n\t\t\n\t\tString[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n\t\tif (args.length > ++k) {\n\t\t\tString arg = args[k];\n\t\t\tif (arg.startsWith(\"@\")) \n\t\t\t\tqueries = readLines(new File(arg.substring(1)));\n\t\t\telse\n\t\t\t\tqueries = new String[] { arg };\n\t\t}\n\t\t\n\t\tFile[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n\t\tif (args.length > ++k) {\n\t\t\tfiles = new File[args.length - k];\n\t\t\tfor (int i=k; i < args.length; i++) {\n\t\t\t\tfiles[i-k] = new File(args[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean toLowerCase = true;\n//\t\tboolean toLowerCase = false;\n//\t\tSet stopWords = null;\n\t\tSet stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n\t\t\n\t\tAnalyzer[] analyzers = new Analyzer[] { \n\t\t\t\tnew SimpleAnalyzer(),\n\t\t\t\tnew StopAnalyzer(),\n\t\t\t\tnew StandardAnalyzer(),\n\t\t\t\tPatternAnalyzer.DEFAULT_ANALYZER,\n//\t\t\t\tnew WhitespaceAnalyzer(),\n//\t\t\t\tnew PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//\t\t\t\tnew PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),\t\t\t\t\n//\t\t\t\tnew SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n\t\t};\n\t\t\n\t\tfor (int iter=0; iter < iters; iter++) {\n\t\t\tSystem.out.println(\"\\n########### iteration=\" + iter);\n\t\t\tlong start = System.currentTimeMillis();\t\t\t\t\t\t\n\t\t\tlong bytes = 0;\n\t\t\t\n\t\t\tfor (int anal=0; anal < analyzers.length; anal++) {\n\t\t\t\tthis.analyzer = analyzers[anal];\n\t\t\t\t\n\t\t\t\tfor (int i=0; i < files.length; i++) {\n\t\t\t\t\tFile file = files[i];\n\t\t\t\t\tif (!file.exists() || file.isDirectory()) continue; // ignore\n\t\t\t\t\tbytes += file.length();\n\t\t\t\t\tString text = toString(new FileInputStream(file), null);\n\t\t\t\t\tDocument doc = createDocument(text);\n\t\t\t\t\tSystem.out.println(\"\\n*********** FILE=\" + file);\n\t\t\t\t\t\n\t\t\t\t\tfor (int q=0; q < queries.length; q++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tQuery query = parseQuery(queries[q]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (int run=0; run < runs; run++) {\n\t\t\t\t\t\t\t\tfloat score1 = 0.0f; float score2 = 0.0f;\n\t\t\t\t\t\t\t\tif (useMemIndex) score1 = query(createMemoryIndex(doc), query); \n\t\t\t\t\t\t\t\tif (useRAMIndex) score2 = query(createRAMIndex(doc), query);\n\t\t\t\t\t\t\t\tif (useMemIndex && useRAMIndex) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n\t\t\t\t\t\t\t\t\tif (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\tif (t instanceof OutOfMemoryError) t.printStackTrace();\n\t\t\t\t\t\t\tSystem.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n\t\t\t\t\t\t\tthrow t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong end = System.currentTimeMillis();\n\t\t\tSystem.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n\t\t\tSystem.out.println(\"queries/sec= \" + \n\t\t\t\t(1.0f * runs * queries.length * analyzers.length * files.length \n\t\t\t\t\t\t/ ((end-start)/1000.0f)));\n\t\t\tfloat mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n\t\t\tSystem.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n\t\t}\n\t\t\n\t\tif (useMemIndex && useRAMIndex) \n\t\t\tSystem.out.println(\"No bug found. done.\");\n\t\telse \n\t\t\tSystem.out.println(\"Done benchmarking (without checking correctness).\");\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f68e24227d5556d33ee6d586fd9010cd9ff8bec","date":1150091176,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex) score1 = query(createMemoryIndex(doc), query); \n                if (useRAMIndex) score2 = query(createRAMIndex(doc), query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"\tprivate void run(String[] args) throws Throwable {\n\t\tint k = -1;\n\t\t\n\t\tint iters = 1;\n\t\tif (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n\t\t\n\t\tint runs = 1;\n\t\tif (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n\t\t\n\t\tString cmd = \"memram\";\n\t\tif (args.length > ++k) cmd = args[k];\n\t\tboolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n\t\tboolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n\t\t\n\t\tString[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n\t\tif (args.length > ++k) {\n\t\t\tString arg = args[k];\n\t\t\tif (arg.startsWith(\"@\")) \n\t\t\t\tqueries = readLines(new File(arg.substring(1)));\n\t\t\telse\n\t\t\t\tqueries = new String[] { arg };\n\t\t}\n\t\t\n\t\tFile[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n\t\tif (args.length > ++k) {\n\t\t\tfiles = new File[args.length - k];\n\t\t\tfor (int i=k; i < args.length; i++) {\n\t\t\t\tfiles[i-k] = new File(args[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean toLowerCase = true;\n//\t\tboolean toLowerCase = false;\n//\t\tSet stopWords = null;\n\t\tSet stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n\t\t\n\t\tAnalyzer[] analyzers = new Analyzer[] { \n\t\t\t\tnew SimpleAnalyzer(),\n\t\t\t\tnew StopAnalyzer(),\n\t\t\t\tnew StandardAnalyzer(),\n\t\t\t\tPatternAnalyzer.DEFAULT_ANALYZER,\n//\t\t\t\tnew WhitespaceAnalyzer(),\n//\t\t\t\tnew PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//\t\t\t\tnew PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),\t\t\t\t\n//\t\t\t\tnew SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n\t\t};\n\t\t\n\t\tfor (int iter=0; iter < iters; iter++) {\n\t\t\tSystem.out.println(\"\\n########### iteration=\" + iter);\n\t\t\tlong start = System.currentTimeMillis();\t\t\t\t\t\t\n\t\t\tlong bytes = 0;\n\t\t\t\n\t\t\tfor (int anal=0; anal < analyzers.length; anal++) {\n\t\t\t\tthis.analyzer = analyzers[anal];\n\t\t\t\t\n\t\t\t\tfor (int i=0; i < files.length; i++) {\n\t\t\t\t\tFile file = files[i];\n\t\t\t\t\tif (!file.exists() || file.isDirectory()) continue; // ignore\n\t\t\t\t\tbytes += file.length();\n\t\t\t\t\tString text = toString(new FileInputStream(file), null);\n\t\t\t\t\tDocument doc = createDocument(text);\n\t\t\t\t\tSystem.out.println(\"\\n*********** FILE=\" + file);\n\t\t\t\t\t\n\t\t\t\t\tfor (int q=0; q < queries.length; q++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tQuery query = parseQuery(queries[q]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (int run=0; run < runs; run++) {\n\t\t\t\t\t\t\t\tfloat score1 = 0.0f; float score2 = 0.0f;\n\t\t\t\t\t\t\t\tif (useMemIndex) score1 = query(createMemoryIndex(doc), query); \n\t\t\t\t\t\t\t\tif (useRAMIndex) score2 = query(createRAMIndex(doc), query);\n\t\t\t\t\t\t\t\tif (useMemIndex && useRAMIndex) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n\t\t\t\t\t\t\t\t\tif (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\tif (t instanceof OutOfMemoryError) t.printStackTrace();\n\t\t\t\t\t\t\tSystem.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n\t\t\t\t\t\t\tthrow t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong end = System.currentTimeMillis();\n\t\t\tSystem.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n\t\t\tSystem.out.println(\"queries/sec= \" + \n\t\t\t\t(1.0f * runs * queries.length * analyzers.length * files.length \n\t\t\t\t\t\t/ ((end-start)/1000.0f)));\n\t\t\tfloat mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n\t\t\tSystem.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n\t\t}\n\t\t\n\t\tif (useMemIndex && useRAMIndex) \n\t\t\tSystem.out.println(\"No bug found. done.\");\n\t\telse \n\t\t\tSystem.out.println(\"Done benchmarking (without checking correctness).\");\n\t}\n\n","bugFix":null,"bugIntro":["512366c273bec3211f7d36ef75e58e3d32a06e26"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"836fa046f468f50b4b0932aa064f25982fccdb7a","date":1164182491,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex) score1 = query(createMemoryIndex(doc), query); \n                if (useRAMIndex) score2 = query(createRAMIndex(doc), query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43034241652edbe337a2a852ee9127b3b222c2e9","date":1180509509,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb426c20cf500a679bd484316a312efb5951b9fc","date":1195330757,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"512366c273bec3211f7d36ef75e58e3d32a06e26","date":1232894323,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n    \n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c881464041e282c06fdb34e91f883b83b8d97968","date":1247607562,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9","date":1256127131,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(true),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(),\n        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba1116b3450a9c1642c89445d131b37344055245","date":1256329517,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(true),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d8c222875ac4ef7e08f3e25d40508b821d711ff","date":1257374221,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90cb6b3f4e5652555b614adc90204287fbebd27c","date":1259494272,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              \n              boolean measureIndexing = false; // toggle this to measure query performance\n              MemoryIndex memind = null;\n              if (useMemIndex && !measureIndexing) memind = createMemoryIndex(doc);\n              \n              if (first) {\n                IndexSearcher s = memind.createSearcher();\n                TermDocs td = s.getIndexReader().termDocs(null);\n                assertTrue(td.next());\n                assertEquals(0, td.doc());\n                assertEquals(1, td.freq());\n                td.close();\n                s.close();\n                first = false;\n              }\n\n              RAMDirectory ramind = null;\n              if (useRAMIndex && !measureIndexing) ramind = createRAMIndex(doc);\n              \n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) memind = createMemoryIndex(doc);\n                if (useMemIndex) score1 = query(memind, query); \n                if (useRAMIndex && measureIndexing) ramind = createRAMIndex(doc);\n                if (useRAMIndex) score2 = query(ramind, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7848880b3c06f09f0f3ac50d0854b16efb0b815e","date":1260006234,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set<?> stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ced3401b9c4e7ed2be67711dbc83e48b81aa736","date":1265394056,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set<?> stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(Version.LUCENE_CURRENT),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(Version.LUCENE_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set<?> stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a","date":1267298041,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set<?> stopWords = StopAnalyzer.ENGLISH_STOP_WORDS_SET;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(Version.LUCENE_CURRENT),\n        new StopAnalyzer(Version.LUCENE_CURRENT),\n        new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT),\n//        new WhitespaceAnalyzer(Version.LUCENE_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42607aa380c892dc1ec0ab26e86a575c28e13618","date":1268641604,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (verbose) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (verbose) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n      System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n      float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n      System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n    }\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c881464041e282c06fdb34e91f883b83b8d97968":["512366c273bec3211f7d36ef75e58e3d32a06e26"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"6ced3401b9c4e7ed2be67711dbc83e48b81aa736":["7848880b3c06f09f0f3ac50d0854b16efb0b815e"],"7848880b3c06f09f0f3ac50d0854b16efb0b815e":["90cb6b3f4e5652555b614adc90204287fbebd27c"],"ba1116b3450a9c1642c89445d131b37344055245":["4b41b991de69ba7b72d5e90cfcee25699a1a7fc9"],"512366c273bec3211f7d36ef75e58e3d32a06e26":["eb426c20cf500a679bd484316a312efb5951b9fc"],"90cb6b3f4e5652555b614adc90204287fbebd27c":["0d8c222875ac4ef7e08f3e25d40508b821d711ff"],"43034241652edbe337a2a852ee9127b3b222c2e9":["836fa046f468f50b4b0932aa064f25982fccdb7a"],"0d8c222875ac4ef7e08f3e25d40508b821d711ff":["ba1116b3450a9c1642c89445d131b37344055245"],"836fa046f468f50b4b0932aa064f25982fccdb7a":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9":["c881464041e282c06fdb34e91f883b83b8d97968"],"50e7972fe4865715af8951d4ba15555e3426fc5d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"42607aa380c892dc1ec0ab26e86a575c28e13618":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["6ced3401b9c4e7ed2be67711dbc83e48b81aa736"],"eb426c20cf500a679bd484316a312efb5951b9fc":["43034241652edbe337a2a852ee9127b3b222c2e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["42607aa380c892dc1ec0ab26e86a575c28e13618"]},"commit2Childs":{"c881464041e282c06fdb34e91f883b83b8d97968":["4b41b991de69ba7b72d5e90cfcee25699a1a7fc9"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["836fa046f468f50b4b0932aa064f25982fccdb7a"],"6ced3401b9c4e7ed2be67711dbc83e48b81aa736":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"7848880b3c06f09f0f3ac50d0854b16efb0b815e":["6ced3401b9c4e7ed2be67711dbc83e48b81aa736"],"ba1116b3450a9c1642c89445d131b37344055245":["0d8c222875ac4ef7e08f3e25d40508b821d711ff"],"512366c273bec3211f7d36ef75e58e3d32a06e26":["c881464041e282c06fdb34e91f883b83b8d97968"],"90cb6b3f4e5652555b614adc90204287fbebd27c":["7848880b3c06f09f0f3ac50d0854b16efb0b815e"],"43034241652edbe337a2a852ee9127b3b222c2e9":["eb426c20cf500a679bd484316a312efb5951b9fc"],"0d8c222875ac4ef7e08f3e25d40508b821d711ff":["90cb6b3f4e5652555b614adc90204287fbebd27c"],"836fa046f468f50b4b0932aa064f25982fccdb7a":["43034241652edbe337a2a852ee9127b3b222c2e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"50e7972fe4865715af8951d4ba15555e3426fc5d":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9":["ba1116b3450a9c1642c89445d131b37344055245"],"42607aa380c892dc1ec0ab26e86a575c28e13618":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"eb426c20cf500a679bd484316a312efb5951b9fc":["512366c273bec3211f7d36ef75e58e3d32a06e26"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["42607aa380c892dc1ec0ab26e86a575c28e13618"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}