{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","commits":[{"id":"f5c96ee46366b5feece8b0b328368c6237fc087a","date":1400184255,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitions.length != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitions.length != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitions.length != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitions.length != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d238816bcdf9bbe4ec886226d89bd93834eb7e","date":1413925889,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    //xif (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        //if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            //xif (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    //if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    //xif (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        //if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            //xif (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    //if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d36b496b747a10405f5d42dfea257bbe0cf3399","date":1428484752,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n\n    //xif (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        //if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            //xif (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    //if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    //xif (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null && transitionCount != 0) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        //if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            //xif (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    //if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n\n    //xif (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (frameIndexData != null) {\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n        //if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            //xif (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    //if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n\n    // Necessary in case this ord previously was an auto-prefix\n    // term but now we recurse to a new leaf block\n    isAutoPrefixTerm = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    if (version >= BlockTreeTermsReader.VERSION_COMPRESSED_SUFFIXES) {\n      final long codeL = ite.in.readVLong();\n      isLeafBlock = (codeL & 0x04) != 0;\n      final int numSuffixBytes = (int) (codeL >>> 3);\n      if (suffixBytes.length < numSuffixBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numSuffixBytes, 1)];\n      }\n      final CompressionAlgorithm compressionAlg;\n      try {\n        compressionAlg = CompressionAlgorithm.byCode((int) codeL & 0x03);\n      } catch (IllegalArgumentException e) {\n        throw new CorruptIndexException(e.getMessage(), ite.in, e);\n      }\n      compressionAlg.read(ite.in, suffixBytes, numSuffixBytes);\n      suffixesReader.reset(suffixBytes, 0, numSuffixBytes);\n\n      int numSuffixLengthBytes = ite.in.readVInt();\n      final boolean allEqual = (numSuffixLengthBytes & 0x01) != 0;\n      numSuffixLengthBytes >>>= 1;\n      if (suffixLengthBytes.length < numSuffixLengthBytes) {\n        suffixLengthBytes = new byte[ArrayUtil.oversize(numSuffixLengthBytes, 1)];\n      }\n      if (allEqual) {\n        Arrays.fill(suffixLengthBytes, 0, numSuffixLengthBytes, ite.in.readByte());\n      } else {\n        LZ4.decompress(ite.in, numSuffixLengthBytes, suffixLengthBytes, 0);\n      }\n      suffixLengthsReader.reset(suffixLengthBytes, 0, numSuffixLengthBytes);\n    } else {\n      code = ite.in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      ite.in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n    }\n\n    // stats\n    int numBytes = ite.in.readVInt();\n    if (version >= BlockTreeTermsReader.VERSION_COMPRESSED_SUFFIXES) {\n      final boolean allOnes = (numBytes & 0x01) != 0;\n      numBytes >>>= 1;\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      if (allOnes) {\n        Arrays.fill(statBytes, 0, numBytes, (byte) 1);\n      } else {\n        LZ4.decompress(ite.in, numBytes, statBytes, 0);\n      }\n    } else {\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      ite.in.readBytes(statBytes, 0, numBytes);\n    }\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n\n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a356e37aed258bcd168680472f8d1dbc6f396935","date":1580233110,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnumFrame#load(BytesRef).mjava","sourceNew":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    if (version >= BlockTreeTermsReader.VERSION_COMPRESSED_SUFFIXES) {\n      final long codeL = ite.in.readVLong();\n      isLeafBlock = (codeL & 0x04) != 0;\n      final int numSuffixBytes = (int) (codeL >>> 3);\n      if (suffixBytes.length < numSuffixBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numSuffixBytes, 1)];\n      }\n      final CompressionAlgorithm compressionAlg;\n      try {\n        compressionAlg = CompressionAlgorithm.byCode((int) codeL & 0x03);\n      } catch (IllegalArgumentException e) {\n        throw new CorruptIndexException(e.getMessage(), ite.in, e);\n      }\n      compressionAlg.read(ite.in, suffixBytes, numSuffixBytes);\n      suffixesReader.reset(suffixBytes, 0, numSuffixBytes);\n\n      int numSuffixLengthBytes = ite.in.readVInt();\n      final boolean allEqual = (numSuffixLengthBytes & 0x01) != 0;\n      numSuffixLengthBytes >>>= 1;\n      if (suffixLengthBytes.length < numSuffixLengthBytes) {\n        suffixLengthBytes = new byte[ArrayUtil.oversize(numSuffixLengthBytes, 1)];\n      }\n      if (allEqual) {\n        Arrays.fill(suffixLengthBytes, 0, numSuffixLengthBytes, ite.in.readByte());\n      } else {\n        ite.in.readBytes(suffixLengthBytes, 0, numSuffixLengthBytes);\n      }\n      suffixLengthsReader.reset(suffixLengthBytes, 0, numSuffixLengthBytes);\n    } else {\n      code = ite.in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      ite.in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n    }\n\n    // stats\n    int numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    statsSingletonRunLength = 0;\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n\n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":"  void load(BytesRef frameIndexData) throws IOException {\n    if (frameIndexData != null) {\n      floorDataReader.reset(frameIndexData.bytes, frameIndexData.offset, frameIndexData.length);\n      // Skip first long -- has redundant fp, hasTerms\n      // flag, isFloor flag\n      final long code = floorDataReader.readVLong();\n      if ((code & BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        // Floor frame\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        // If current state is not accept, and has transitions, we must process\n        // first block in case it has empty suffix:\n        if (ite.runAutomaton.isAccept(state) == false && transitionCount != 0) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    if (version >= BlockTreeTermsReader.VERSION_COMPRESSED_SUFFIXES) {\n      final long codeL = ite.in.readVLong();\n      isLeafBlock = (codeL & 0x04) != 0;\n      final int numSuffixBytes = (int) (codeL >>> 3);\n      if (suffixBytes.length < numSuffixBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numSuffixBytes, 1)];\n      }\n      final CompressionAlgorithm compressionAlg;\n      try {\n        compressionAlg = CompressionAlgorithm.byCode((int) codeL & 0x03);\n      } catch (IllegalArgumentException e) {\n        throw new CorruptIndexException(e.getMessage(), ite.in, e);\n      }\n      compressionAlg.read(ite.in, suffixBytes, numSuffixBytes);\n      suffixesReader.reset(suffixBytes, 0, numSuffixBytes);\n\n      int numSuffixLengthBytes = ite.in.readVInt();\n      final boolean allEqual = (numSuffixLengthBytes & 0x01) != 0;\n      numSuffixLengthBytes >>>= 1;\n      if (suffixLengthBytes.length < numSuffixLengthBytes) {\n        suffixLengthBytes = new byte[ArrayUtil.oversize(numSuffixLengthBytes, 1)];\n      }\n      if (allEqual) {\n        Arrays.fill(suffixLengthBytes, 0, numSuffixLengthBytes, ite.in.readByte());\n      } else {\n        LZ4.decompress(ite.in, numSuffixLengthBytes, suffixLengthBytes, 0);\n      }\n      suffixLengthsReader.reset(suffixLengthBytes, 0, numSuffixLengthBytes);\n    } else {\n      code = ite.in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      ite.in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n    }\n\n    // stats\n    int numBytes = ite.in.readVInt();\n    if (version >= BlockTreeTermsReader.VERSION_COMPRESSED_SUFFIXES) {\n      final boolean allOnes = (numBytes & 0x01) != 0;\n      numBytes >>>= 1;\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      if (allOnes) {\n        Arrays.fill(statBytes, 0, numBytes, (byte) 1);\n      } else {\n        LZ4.decompress(ite.in, numBytes, statBytes, 0);\n      }\n    } else {\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      ite.in.readBytes(statBytes, 0, numBytes);\n    }\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n\n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd96a930cc08d72beee719cc11ce465b9d9861c3":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"f5c96ee46366b5feece8b0b328368c6237fc087a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a356e37aed258bcd168680472f8d1dbc6f396935":["9407318969e8504257b4c5764c65755a043e5404"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5c96ee46366b5feece8b0b328368c6237fc087a"],"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":["5c84485629d80d203608e8975a1139de9933cc38"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["5d36b496b747a10405f5d42dfea257bbe0cf3399"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","3e8715d826e588419327562287d5d6a8040d63d6"],"9407318969e8504257b4c5764c65755a043e5404":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["5c84485629d80d203608e8975a1139de9933cc38","c6d238816bcdf9bbe4ec886226d89bd93834eb7e"],"3e8715d826e588419327562287d5d6a8040d63d6":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"5c84485629d80d203608e8975a1139de9933cc38":["4d637064d608752565d4f9f41b2497dfdfdde50e","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"5d36b496b747a10405f5d42dfea257bbe0cf3399":["3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a356e37aed258bcd168680472f8d1dbc6f396935"]},"commit2Childs":{"dd96a930cc08d72beee719cc11ce465b9d9861c3":["9407318969e8504257b4c5764c65755a043e5404"],"f5c96ee46366b5feece8b0b328368c6237fc087a":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a356e37aed258bcd168680472f8d1dbc6f396935":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5c96ee46366b5feece8b0b328368c6237fc087a","4d637064d608752565d4f9f41b2497dfdfdde50e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"9407318969e8504257b4c5764c65755a043e5404":["a356e37aed258bcd168680472f8d1dbc6f396935"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"5c84485629d80d203608e8975a1139de9933cc38":["c6d238816bcdf9bbe4ec886226d89bd93834eb7e","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","5d36b496b747a10405f5d42dfea257bbe0cf3399"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["5c84485629d80d203608e8975a1139de9933cc38"],"5d36b496b747a10405f5d42dfea257bbe0cf3399":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}