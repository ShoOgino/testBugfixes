{"path":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","commits":[{"id":"7b13106276bb5ea342253dbf6aae7b675adb38d3","date":1428054414,"type":0,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    restoreFuture = restoreExecutor.submit(restoreCore);\n    currentRestoreName = name;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    restoreFuture = restoreExecutor.submit(restoreCore);\n    currentRestoreName = name;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    restoreFuture = restoreExecutor.submit(restoreCore);\n    currentRestoreName = name;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","date":1466705968,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    String repoName = params.get(BackupRepository.REPOSITORY_PROPERTY_NAME);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    SolrResourceLoader rl = cc.getResourceLoader();\n    BackupRepository repo = null;\n    if(repoName != null) {\n      repo = cc.getBackupRepoFactory().newInstance(rl, repoName);\n      if (location == null) {\n        location = repo.getConfigProperty(ZkStateReader.BACKUP_LOCATION);\n        if(location == null) {\n          throw new IllegalArgumentException(\"location is required\");\n        }\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["af3193c66df8e8324d4bce9f66df967af9e8c602"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c623a7f72be34d6c45bee682028c50327d9e4b7","date":1467791293,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    String repoName = params.get(BackupRepository.REPOSITORY_PROPERTY_NAME);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    SolrResourceLoader rl = cc.getResourceLoader();\n    BackupRepository repo = null;\n    if(repoName != null) {\n      repo = cc.getBackupRepoFactory().newInstance(rl, repoName);\n      if (location == null) {\n        location = repo.getConfigProperty(ZkStateReader.BACKUP_LOCATION);\n        if(location == null) {\n          throw new IllegalArgumentException(\"location is required\");\n        }\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af3193c66df8e8324d4bce9f66df967af9e8c602","date":1472772499,"type":3,"author":"Hrishikesh Gadre","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da02fc41cfc83eaee66abb7c926f2c909bda6d26","date":1472818509,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      URI basePath = repo.createURI(location);\n      String[] filePaths = repo.listAll(basePath);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(basePath, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(LOCATION);\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      File[] files = new File(location).listFiles();\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (File f : files) {\n        OldBackupDirectory obd = new OldBackupDirectory(f);\n        if (obd.dir != null) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).dir.getName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(core, location, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreDescriptor().getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cb65c1c2f90852e718f86c8be09beb1c4dba408","date":1543785784,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n      rsp.add(STATUS, OK_STATUS);\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6b17e67903ace8abb1d4d602bfc40d1994692ff","date":1593429504,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n      //If location is not provided then assume that the restore index is present inside the data directory.\n      if (location == null) {\n        location = core.getDataDir();\n      }\n    }\n    if (\"file\".equals(repo.createURI(\"x\").getScheme())) {\n      core.getCoreContainer().assertPathAllowed(Paths.get(location));\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n      rsp.add(STATUS, OK_STATUS);\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n    }\n\n    //If location is not provided then assume that the restore index is present inside the data directory.\n    if (location == null) {\n      location = core.getDataDir();\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n      rsp.add(STATUS, OK_STATUS);\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58dba38d0c9777f300cca9dd3c150fe2d244742","date":1599661188,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#restore(SolrParams,SolrQueryResponse,SolrQueryRequest).mjava","sourceNew":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(repoName);\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n      //If location is not provided then assume that the restore index is present inside the data directory.\n      if (location == null) {\n        location = core.getDataDir();\n      }\n    }\n    if (\"file\".equals(repo.createURI(\"x\").getScheme())) {\n      core.getCoreContainer().assertPathAllowed(Paths.get(location));\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n      rsp.add(STATUS, OK_STATUS);\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","sourceOld":"  private void restore(SolrParams params, SolrQueryResponse rsp, SolrQueryRequest req) throws IOException {\n    if (restoreFuture != null && !restoreFuture.isDone()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Restore in progress. Cannot run multiple restore operations\" +\n          \"for the same core\");\n    }\n    String name = params.get(NAME);\n    String location = params.get(CoreAdminParams.BACKUP_LOCATION);\n    String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);\n    CoreContainer cc = core.getCoreContainer();\n    BackupRepository repo = null;\n    if (repoName != null) {\n      repo = cc.newBackupRepository(Optional.of(repoName));\n      location = repo.getBackupLocation(location);\n      if (location == null) {\n        throw new IllegalArgumentException(\"location is required\");\n      }\n    } else {\n      repo = new LocalFileSystemRepository();\n      //If location is not provided then assume that the restore index is present inside the data directory.\n      if (location == null) {\n        location = core.getDataDir();\n      }\n    }\n    if (\"file\".equals(repo.createURI(\"x\").getScheme())) {\n      core.getCoreContainer().assertPathAllowed(Paths.get(location));\n    }\n\n    URI locationUri = repo.createURI(location);\n\n    //If name is not provided then look for the last unnamed( the ones with the snapshot.timestamp format)\n    //snapshot folder since we allow snapshots to be taken without providing a name. Pick the latest timestamp.\n    if (name == null) {\n      String[] filePaths = repo.listAll(locationUri);\n      List<OldBackupDirectory> dirs = new ArrayList<>();\n      for (String f : filePaths) {\n        OldBackupDirectory obd = new OldBackupDirectory(locationUri, f);\n        if (obd.getTimestamp().isPresent()) {\n          dirs.add(obd);\n        }\n      }\n      Collections.sort(dirs);\n      if (dirs.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No backup name specified and none found in \" + core.getDataDir());\n      }\n      name = dirs.get(0).getDirName();\n    } else {\n      //\"snapshot.\" is prefixed by snapshooter\n      name = \"snapshot.\" + name;\n    }\n\n    RestoreCore restoreCore = new RestoreCore(repo, core, locationUri, name);\n    try {\n      MDC.put(\"RestoreCore.core\", core.getName());\n      MDC.put(\"RestoreCore.backupLocation\", location);\n      MDC.put(\"RestoreCore.backupName\", name);\n      restoreFuture = restoreExecutor.submit(restoreCore);\n      currentRestoreName = name;\n      rsp.add(STATUS, OK_STATUS);\n    } finally {\n      MDC.remove(\"RestoreCore.core\");\n      MDC.remove(\"RestoreCore.backupLocation\");\n      MDC.remove(\"RestoreCore.backupName\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c623a7f72be34d6c45bee682028c50327d9e4b7":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"da02fc41cfc83eaee66abb7c926f2c909bda6d26":["4c623a7f72be34d6c45bee682028c50327d9e4b7","af3193c66df8e8324d4bce9f66df967af9e8c602"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"bc8f206328a706450934717bec7ccc22ad166fc0":["4c623a7f72be34d6c45bee682028c50327d9e4b7","da02fc41cfc83eaee66abb7c926f2c909bda6d26"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["5cb65c1c2f90852e718f86c8be09beb1c4dba408"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4c623a7f72be34d6c45bee682028c50327d9e4b7","da02fc41cfc83eaee66abb7c926f2c909bda6d26"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"af3193c66df8e8324d4bce9f66df967af9e8c602":["4c623a7f72be34d6c45bee682028c50327d9e4b7"],"5cb65c1c2f90852e718f86c8be09beb1c4dba408":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"d58dba38d0c9777f300cca9dd3c150fe2d244742":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d58dba38d0c9777f300cca9dd3c150fe2d244742"]},"commit2Childs":{"4c623a7f72be34d6c45bee682028c50327d9e4b7":["da02fc41cfc83eaee66abb7c926f2c909bda6d26","bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","af3193c66df8e8324d4bce9f66df967af9e8c602"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"da02fc41cfc83eaee66abb7c926f2c909bda6d26":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["5cb65c1c2f90852e718f86c8be09beb1c4dba408"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["d58dba38d0c9777f300cca9dd3c150fe2d244742"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["4c623a7f72be34d6c45bee682028c50327d9e4b7"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"af3193c66df8e8324d4bce9f66df967af9e8c602":["da02fc41cfc83eaee66abb7c926f2c909bda6d26"],"5cb65c1c2f90852e718f86c8be09beb1c4dba408":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"d58dba38d0c9777f300cca9dd3c150fe2d244742":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","bc8f206328a706450934717bec7ccc22ad166fc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}