{"path":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","commits":[{"id":"9140d3568539d7cd892885f2979289c780ba93c8","date":1458041347,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      SolrParams params = SolrParams.toSolrParams(args);\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      inputFieldNames = fieldNames.split(\"\\\\,\");\n\n      classFieldName = params.get(CLASS_FIELD_PARAM);\n      checkNotNull(CLASS_FIELD_PARAM, classFieldName);\n\n      algorithm = params.get(ALGORITHM_PARAM);\n      if (algorithm == null)\n        algorithm = DEFAULT_ALGORITHM;\n\n      minTf = getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF);\n      minDf = getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF);\n      k = getIntParam(params, KNN_K_PARAM, DEFAULT_K);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f1ec46dc24c2330c5e9dd0edefaede91c962926","date":1480027437,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      SolrParams params = SolrParams.toSolrParams(args);\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      inputFieldNames = fieldNames.split(\"\\\\,\");\n\n      classFieldName = params.get(CLASS_FIELD_PARAM);\n      checkNotNull(CLASS_FIELD_PARAM, classFieldName);\n\n      algorithm = params.get(ALGORITHM_PARAM);\n      if (algorithm == null)\n        algorithm = DEFAULT_ALGORITHM;\n\n      minTf = getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF);\n      minDf = getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF);\n      k = getIntParam(params, KNN_K_PARAM, DEFAULT_K);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dc1d76b4fcf7b63851402bbca29dd33b1f7acda","date":1480032723,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need toUpperCase to match algorithm enum value\")\n  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75babd1dfc2521603bfeb0968042e921d8c6c652","date":1480042089,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need toUpperCase to match algorithm enum value\")\n  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      SolrParams params = SolrParams.toSolrParams(args);\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      inputFieldNames = fieldNames.split(\"\\\\,\");\n\n      classFieldName = params.get(CLASS_FIELD_PARAM);\n      checkNotNull(CLASS_FIELD_PARAM, classFieldName);\n\n      algorithm = params.get(ALGORITHM_PARAM);\n      if (algorithm == null)\n        algorithm = DEFAULT_ALGORITHM;\n\n      minTf = getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF);\n      minDf = getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF);\n      k = getIntParam(params, KNN_K_PARAM, DEFAULT_K);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1886fb7130df2c1389678e62a3c09875ccc78e97","date":1480321356,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need toUpperCase to match algorithm enum value\")\n  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      SolrParams params = SolrParams.toSolrParams(args);\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      inputFieldNames = fieldNames.split(\"\\\\,\");\n\n      classFieldName = params.get(CLASS_FIELD_PARAM);\n      checkNotNull(CLASS_FIELD_PARAM, classFieldName);\n\n      algorithm = params.get(ALGORITHM_PARAM);\n      if (algorithm == null)\n        algorithm = DEFAULT_ALGORITHM;\n\n      minTf = getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF);\n      minDf = getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF);\n      k = getIntParam(params, KNN_K_PARAM, DEFAULT_K);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"931cb705e783c7f07cdb110a0cb03bad79fe1b2b","date":1480386986,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need toUpperCase to match algorithm enum value\")\n  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase()) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase());\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"129e5b874f99ae4e04f39c337c940dda690f2d38","date":1524504409,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = args.toSolrParams();\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = SolrParams.toSolrParams(args);\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ClassificationUpdateProcessorFactory#init(NamedList).mjava","sourceNew":"  @Override\n  public void init(@SuppressWarnings({\"rawtypes\"})final NamedList args) {\n    if (args != null) {\n      params = args.toSolrParams();\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init(final NamedList args) {\n    if (args != null) {\n      params = args.toSolrParams();\n      classificationParams = new ClassificationUpdateProcessorParams();\n\n      String fieldNames = params.get(INPUT_FIELDS_PARAM);// must be a comma separated list of fields\n      checkNotNull(INPUT_FIELDS_PARAM, fieldNames);\n      classificationParams.setInputFieldNames(fieldNames.split(\"\\\\,\"));\n\n      String trainingClassField = (params.get(TRAINING_CLASS_FIELD_PARAM));\n      checkNotNull(TRAINING_CLASS_FIELD_PARAM, trainingClassField);\n      classificationParams.setTrainingClassField(trainingClassField);\n\n      String predictedClassField = (params.get(PREDICTED_CLASS_FIELD_PARAM));\n      if (predictedClassField == null || predictedClassField.isEmpty()) {\n        predictedClassField = trainingClassField;\n      }\n      classificationParams.setPredictedClassField(predictedClassField);\n\n      classificationParams.setMaxPredictedClasses(getIntParam(params, MAX_CLASSES_TO_ASSIGN_PARAM, DEFAULT_MAX_CLASSES_TO_ASSIGN));\n\n      String algorithmString = params.get(ALGORITHM_PARAM);\n      Algorithm classificationAlgorithm;\n      try {\n        if (algorithmString == null || Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT)) == null) {\n          classificationAlgorithm = DEFAULT_ALGORITHM;\n        } else {\n          classificationAlgorithm = Algorithm.valueOf(algorithmString.toUpperCase(Locale.ROOT));\n        }\n      } catch (IllegalArgumentException e) {\n        throw new SolrException\n            (SolrException.ErrorCode.SERVER_ERROR,\n                \"Classification UpdateProcessor Algorithm: '\" + algorithmString + \"' not supported\");\n      }\n      classificationParams.setAlgorithm(classificationAlgorithm);\n\n      classificationParams.setMinTf(getIntParam(params, KNN_MIN_TF_PARAM, DEFAULT_MIN_TF));\n      classificationParams.setMinDf(getIntParam(params, KNN_MIN_DF_PARAM, DEFAULT_MIN_DF));\n      classificationParams.setK(getIntParam(params, KNN_K_PARAM, DEFAULT_K));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9140d3568539d7cd892885f2979289c780ba93c8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9f1ec46dc24c2330c5e9dd0edefaede91c962926":["9140d3568539d7cd892885f2979289c780ba93c8"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["129e5b874f99ae4e04f39c337c940dda690f2d38"],"1886fb7130df2c1389678e62a3c09875ccc78e97":["75babd1dfc2521603bfeb0968042e921d8c6c652"],"727bb765ff2542275f6d31f67be18d7104bae148":["9140d3568539d7cd892885f2979289c780ba93c8","1886fb7130df2c1389678e62a3c09875ccc78e97"],"129e5b874f99ae4e04f39c337c940dda690f2d38":["931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"75babd1dfc2521603bfeb0968042e921d8c6c652":["9140d3568539d7cd892885f2979289c780ba93c8","3dc1d76b4fcf7b63851402bbca29dd33b1f7acda"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3dc1d76b4fcf7b63851402bbca29dd33b1f7acda":["9f1ec46dc24c2330c5e9dd0edefaede91c962926"],"931cb705e783c7f07cdb110a0cb03bad79fe1b2b":["75babd1dfc2521603bfeb0968042e921d8c6c652","1886fb7130df2c1389678e62a3c09875ccc78e97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"9140d3568539d7cd892885f2979289c780ba93c8":["9f1ec46dc24c2330c5e9dd0edefaede91c962926","727bb765ff2542275f6d31f67be18d7104bae148","75babd1dfc2521603bfeb0968042e921d8c6c652"],"9f1ec46dc24c2330c5e9dd0edefaede91c962926":["3dc1d76b4fcf7b63851402bbca29dd33b1f7acda"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1886fb7130df2c1389678e62a3c09875ccc78e97":["727bb765ff2542275f6d31f67be18d7104bae148","931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"129e5b874f99ae4e04f39c337c940dda690f2d38":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"75babd1dfc2521603bfeb0968042e921d8c6c652":["1886fb7130df2c1389678e62a3c09875ccc78e97","931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9140d3568539d7cd892885f2979289c780ba93c8"],"3dc1d76b4fcf7b63851402bbca29dd33b1f7acda":["75babd1dfc2521603bfeb0968042e921d8c6c652"],"931cb705e783c7f07cdb110a0cb03bad79fe1b2b":["129e5b874f99ae4e04f39c337c940dda690f2d38"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}