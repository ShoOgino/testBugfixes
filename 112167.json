{"path":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","commits":[{"id":"303ca293666286b4ae2b0b4dbf10d3bf60ed727c","date":1153866181,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E]).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invokation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!checkSuperType(componentClass, ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOGGER.isInfoEnabled())\n                    LOGGER.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (checkSuperType(componentClass, ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * @param <E> \n     * @param componentClass\n     * @throws RegistryException\n     */\n    @SuppressWarnings(\"unchecked\")\n    public  <E extends ServerComponent> void  registerComponent(final Class<E> componentClass)\n            throws RegistryException {\n        \n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n  \n        if(!checkImplementsServerComponent(componentClass))\n            throw new RegistryException(\"can not register component. the given class does not implement ServerComponent interface -- \"+componentClass.getName());\n        try {\n\n            Component annotation =  componentClass.getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n            \n            this.componentMap.put(type, bean);\n\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09fe963da2613c724ffe82353b4ca2364a1f93c6","date":1155249160,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invokation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!checkSuperType(componentClass, ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!checkSuperType(componentClass, superType))\n                throw new RegistryException(\"Considered Supertype <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOGGER.isInfoEnabled())\n                    LOGGER.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (checkSuperType(componentClass, ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"032a97fadd06b99cd75ebc3be22b74701f80e25d","date":1155763286,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5824af871ba6863399636aa5989bfc0ef2ea448c","date":1166013128,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"09fe963da2613c724ffe82353b4ca2364a1f93c6":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"032a97fadd06b99cd75ebc3be22b74701f80e25d":["09fe963da2613c724ffe82353b4ca2364a1f93c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5824af871ba6863399636aa5989bfc0ef2ea448c":["032a97fadd06b99cd75ebc3be22b74701f80e25d"],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5824af871ba6863399636aa5989bfc0ef2ea448c"]},"commit2Childs":{"09fe963da2613c724ffe82353b4ca2364a1f93c6":["032a97fadd06b99cd75ebc3be22b74701f80e25d"],"032a97fadd06b99cd75ebc3be22b74701f80e25d":["5824af871ba6863399636aa5989bfc0ef2ea448c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["303ca293666286b4ae2b0b4dbf10d3bf60ed727c"],"5824af871ba6863399636aa5989bfc0ef2ea448c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"303ca293666286b4ae2b0b4dbf10d3bf60ed727c":["09fe963da2613c724ffe82353b4ca2364a1f93c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}