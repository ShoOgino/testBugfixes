{"path":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","commits":[{"id":"938d1493cf2f269d3b9e66e932c07ee784e00022","date":1161902835,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments().mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments() throws IOException {\n    long lowerBound = -1;\n    long upperBound = minMergeDocs;\n\n    while (upperBound * mergeFactor <= maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws CorruptIndexException, IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":["938d1493cf2f269d3b9e66e932c07ee784e00022"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","sourceNew":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws CorruptIndexException, IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    /* new merge policy\n    if (upperBound == 0) upperBound = 10;\n    */\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws CorruptIndexException, IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(segmentInfos, minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#maybeMergeSegments(int).mjava","sourceNew":null,"sourceOld":"  /** Incremental segment merger.  */\n  private final void maybeMergeSegments(int startUpperBound) throws CorruptIndexException, IOException {\n    long lowerBound = -1;\n    long upperBound = startUpperBound;\n\n    /* new merge policy\n    if (upperBound == 0) upperBound = 10;\n    */\n\n    while (upperBound < maxMergeDocs) {\n      int minSegment = segmentInfos.size();\n      int maxSegment = -1;\n\n      // find merge-worthy segments\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n\n        if (maxSegment == -1 && si.docCount > lowerBound && si.docCount <= upperBound) {\n          // start from the rightmost* segment whose doc count is in bounds\n          maxSegment = minSegment;\n        } else if (si.docCount > upperBound) {\n          // until the segment whose doc count exceeds upperBound\n          break;\n        }\n      }\n\n      minSegment++;\n      maxSegment++;\n      int numSegments = maxSegment - minSegment;\n\n      if (numSegments < mergeFactor) {\n        break;\n      } else {\n        boolean exceedsUpperLimit = false;\n\n        // number of merge-worthy segments may exceed mergeFactor when\n        // mergeFactor and/or maxBufferedDocs change(s)\n        while (numSegments >= mergeFactor) {\n          // merge the leftmost* mergeFactor segments\n\n          int docCount = mergeSegments(minSegment, minSegment + mergeFactor);\n          numSegments -= mergeFactor;\n\n          if (docCount > upperBound) {\n            // continue to merge the rest of the worthy segments on this level\n            minSegment++;\n            exceedsUpperLimit = true;\n          } else {\n            // if the merged segment does not exceed upperBound, consider\n            // this segment for further merges on this same level\n            numSegments++;\n          }\n        }\n\n        if (!exceedsUpperLimit) {\n          // if none of the merged segments exceed upperBound, done\n          break;\n        }\n      }\n\n      lowerBound = upperBound;\n      upperBound *= mergeFactor;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"eeefd99c477417e5c7c574228461ebafe92469d4":["938d1493cf2f269d3b9e66e932c07ee784e00022"],"1b54a9bc667895a2095a886184bf69a3179e63df":["eeefd99c477417e5c7c574228461ebafe92469d4"],"938d1493cf2f269d3b9e66e932c07ee784e00022":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["1b54a9bc667895a2095a886184bf69a3179e63df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"]},"commit2Childs":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"eeefd99c477417e5c7c574228461ebafe92469d4":["1b54a9bc667895a2095a886184bf69a3179e63df"],"938d1493cf2f269d3b9e66e932c07ee784e00022":["eeefd99c477417e5c7c574228461ebafe92469d4"],"1b54a9bc667895a2095a886184bf69a3179e63df":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["938d1493cf2f269d3b9e66e932c07ee784e00022"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}