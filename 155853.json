{"path":"lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String,char).mjava","commits":[{"id":"519ac3b8f2711b5bfeb1c90c77bb007032270a41","date":1384456090,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String,char).mjava","pathOld":"/dev/null","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader, with\n   *  default {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field, char delimChar) throws IOException {\n\n    this.field = field;\n    this.separator = delimChar;\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fe35a54e036b5f516cb04b39f3eb96a55812376","date":1384725462,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String,char).mjava","sourceNew":null,"sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader, with\n   *  default {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field, char delimChar) throws IOException {\n\n    this.field = field;\n    this.separator = delimChar;\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"519ac3b8f2711b5bfeb1c90c77bb007032270a41":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9fe35a54e036b5f516cb04b39f3eb96a55812376":["519ac3b8f2711b5bfeb1c90c77bb007032270a41"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["519ac3b8f2711b5bfeb1c90c77bb007032270a41","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"519ac3b8f2711b5bfeb1c90c77bb007032270a41":["9fe35a54e036b5f516cb04b39f3eb96a55812376"],"9fe35a54e036b5f516cb04b39f3eb96a55812376":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9fe35a54e036b5f516cb04b39f3eb96a55812376","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}