{"path":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["e6e919043fa85ee891123768dd655a98edbbf63c"],"e6e919043fa85ee891123768dd655a98edbbf63c":["7b91922b55d15444d554721b352861d028eb8278"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["e6e919043fa85ee891123768dd655a98edbbf63c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e6e919043fa85ee891123768dd655a98edbbf63c":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}