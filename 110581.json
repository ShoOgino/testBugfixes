{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readLegacySegmentInfo(directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4356000e349e38c9fb48034695b7c309abd54557"],"4356000e349e38c9fb48034695b7c309abd54557":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"]},"commit2Childs":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4356000e349e38c9fb48034695b7c309abd54557":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}