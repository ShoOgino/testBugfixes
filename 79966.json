{"path":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCounts(RangeFacetRequest).mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCounts(RangeFacetRequest).mjava","pathOld":"/dev/null","sourceNew":"  private <T extends Comparable<T>> NamedList getFacetRangeCounts(final RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    // explicitly return the gap.\n    res.add(\"gap\", rfr.getGapObj());\n\n    DocSet docSet = computeDocSet(docsOrig, rfr.getExcludeTags());\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      if (range.other != null) {\n        // these are added to top-level NamedList\n        // and we always include them regardless of mincount\n        res.add(range.other.toString(), rangeCount(docSet, rfr, range));\n      } else {\n        final int count = rangeCount(docSet, rfr, range);\n        if (count >= rfr.getMinCount()) {\n          counts.add(range.lower, count);\n        }\n      }\n    }\n\n    // explicitly return the start and end so all the counts\n    // (including before/after/between) are meaningful - even if mincount\n    // has removed the neighboring ranges\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCounts(RangeFacetRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCounts(RangeFacetRequest).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private <T extends Comparable<T>> NamedList getFacetRangeCounts(final RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    // explicitly return the gap.\n    res.add(\"gap\", rfr.getGapObj());\n\n    DocSet docSet = computeDocSet(docsOrig, rfr.getExcludeTags());\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      if (range.other != null) {\n        // these are added to top-level NamedList\n        // and we always include them regardless of mincount\n        res.add(range.other.toString(), rangeCount(docSet, rfr, range));\n      } else {\n        final int count = rangeCount(docSet, rfr, range);\n        if (count >= rfr.getMinCount()) {\n          counts.add(range.lower, count);\n        }\n      }\n    }\n\n    // explicitly return the start and end so all the counts\n    // (including before/after/between) are meaningful - even if mincount\n    // has removed the neighboring ranges\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n\n    return res;\n  }\n\n","sourceOld":"  private <T extends Comparable<T>> NamedList getFacetRangeCounts(final RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    // explicitly return the gap.\n    res.add(\"gap\", rfr.getGapObj());\n\n    DocSet docSet = computeDocSet(docsOrig, rfr.getExcludeTags());\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      if (range.other != null) {\n        // these are added to top-level NamedList\n        // and we always include them regardless of mincount\n        res.add(range.other.toString(), rangeCount(docSet, rfr, range));\n      } else {\n        final int count = rangeCount(docSet, rfr, range);\n        if (count >= rfr.getMinCount()) {\n          counts.add(range.lower, count);\n        }\n      }\n    }\n\n    // explicitly return the start and end so all the counts\n    // (including before/after/between) are meaningful - even if mincount\n    // has removed the neighboring ranges\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}