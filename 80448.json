{"path":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8","date":1328775259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"645912c15f271d560e0209d875d19459c7dde975","date":1329734636,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final InvertedFields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final InvertedFields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e6790992d2af082e1f38621cce393d9596cdf23","date":1335147659,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  protected final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    final AtomicReaderContext[] leaves = topReaderContext.leaves();\n    for (AtomicReaderContext context : leaves) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    Comparator<BytesRef> lastTermComp = null;\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      // Check comparator compatibility:\n      final Comparator<BytesRef> newTermComp = termsEnum.getComparator();\n      if (lastTermComp != null && newTermComp != null && newTermComp != lastTermComp)\n        throw new RuntimeException(\"term comparator should not change between segments: \"+lastTermComp+\" != \"+newTermComp);\n      lastTermComp = newTermComp;\n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    for (LeafReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    for (AtomicReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite#collectTerms(IndexReader,MultiTermQuery,TermCollector).mjava","sourceNew":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    for (LeafReaderContext context : topReaderContext.leaves()) {\n      final Terms terms = context.reader().terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","sourceOld":"  final void collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {\n    IndexReaderContext topReaderContext = reader.getContext();\n    for (LeafReaderContext context : topReaderContext.leaves()) {\n      final Fields fields = context.reader().fields();\n      if (fields == null) {\n        // reader has no fields\n        continue;\n      }\n\n      final Terms terms = fields.terms(query.field);\n      if (terms == null) {\n        // field does not exist\n        continue;\n      }\n\n      final TermsEnum termsEnum = getTermsEnum(query, terms, collector.attributes);\n      assert termsEnum != null;\n\n      if (termsEnum == TermsEnum.EMPTY)\n        continue;\n      \n      collector.setReaderContext(topReaderContext, context);\n      collector.setNextEnum(termsEnum);\n      BytesRef bytes;\n      while ((bytes = termsEnum.next()) != null) {\n        if (!collector.collect(bytes))\n          return; // interrupt whole term collection, so also don't iterate other subReaders\n      }\n    }\n  }\n\n","bugFix":["744486748bc5bee772100e49230e5bca39bac99a","e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["5e6790992d2af082e1f38621cce393d9596cdf23"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["645912c15f271d560e0209d875d19459c7dde975"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"5e6790992d2af082e1f38621cce393d9596cdf23":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"645912c15f271d560e0209d875d19459c7dde975":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8028ab7a24273833d53d35eb160dba5b57283cf5"]},"commit2Childs":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3c188105a9aae04f56c24996f98f8333fc825d2e","211b1506e56f7860762fbd4698f6d1d1b57f672c","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["645912c15f271d560e0209d875d19459c7dde975"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"5e6790992d2af082e1f38621cce393d9596cdf23":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["5e6790992d2af082e1f38621cce393d9596cdf23"],"645912c15f271d560e0209d875d19459c7dde975":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}