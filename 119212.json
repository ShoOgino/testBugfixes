{"path":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageSelector#pickBest(CharSequence,List[#-extends-OffsetRange],int,int,List[OffsetRange]).mjava","commits":[{"id":"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c","date":1597407672,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageSelector#pickBest(CharSequence,List[#-extends-OffsetRange],int,int,List[OffsetRange]).mjava","pathOld":"/dev/null","sourceNew":"  public List<Passage> pickBest(\n      CharSequence value,\n      List<? extends OffsetRange> markers,\n      int maxPassageWindow,\n      int maxPassages,\n      List<OffsetRange> permittedPassageRanges) {\n    assert markers instanceof RandomAccess && permittedPassageRanges instanceof RandomAccess;\n\n    // Handle odd special cases early.\n    if (value.length() == 0 || maxPassageWindow == 0) {\n      return Collections.emptyList();\n    }\n\n    // Sort markers by their start offset, shortest first.\n    markers.sort(\n        (a, b) -> {\n          int v = Integer.compare(a.from, b.from);\n          return v != 0 ? v : Integer.compare(a.to, b.to);\n        });\n\n    // Determine a maximum offset window around each highlight marker and\n    // pick the best scoring passage candidates.\n    PriorityQueue<Passage> pq =\n        new PriorityQueue<>(maxPassages) {\n          @Override\n          protected boolean lessThan(Passage a, Passage b) {\n            return passageScorer.compare(a, b) < 0;\n          }\n        };\n\n    assert sortedAndNonOverlapping(permittedPassageRanges);\n\n    final int max = markers.size();\n    int markerIndex = 0;\n    nextRange:\n    for (OffsetRange range : permittedPassageRanges) {\n      final int rangeTo = Math.min(range.to, value.length());\n\n      // Skip ranges outside of the value window anyway.\n      if (range.from >= rangeTo) {\n        continue;\n      }\n\n      while (markerIndex < max) {\n        OffsetRange m = markers.get(markerIndex);\n\n        // Markers are sorted so if the current marker's start is past the range,\n        // we can advance, but we need to check the same marker against the new range.\n        if (m.from >= rangeTo) {\n          continue nextRange;\n        }\n\n        // Check if current marker falls within the range and is smaller than the largest allowed\n        // passage window.\n        if (m.from >= range.from && m.to <= rangeTo && m.length() <= maxPassageWindow) {\n\n          // Adjust the window range to center the highlight marker.\n          int from = (m.from + m.to - maxPassageWindow) / 2;\n          int to = (m.from + m.to + maxPassageWindow) / 2;\n          if (from < range.from) {\n            to += range.from - from;\n            from = range.from;\n          }\n          if (to > rangeTo) {\n            from -= to - rangeTo;\n            to = rangeTo;\n            if (from < range.from) {\n              from = range.from;\n            }\n          }\n\n          if (from < to && to <= value.length()) {\n            // Find other markers that are completely inside the passage window.\n            ArrayList<OffsetRange> inside = new ArrayList<>();\n            int i = markerIndex;\n            while (i > 0 && markers.get(i - 1).from >= from) {\n              i--;\n            }\n\n            OffsetRange c;\n            for (; i < max && (c = markers.get(i)).from < to; i++) {\n              if (c.to <= to) {\n                inside.add(c);\n              }\n            }\n\n            if (!inside.isEmpty()) {\n              pq.insertWithOverflow(new Passage(from, to, inside));\n            }\n          }\n        }\n\n        // Advance to the next marker.\n        markerIndex++;\n      }\n    }\n\n    // Collect from the priority queue (reverse the order so that highest-scoring are first).\n    Passage[] passages;\n    if (pq.size() > 0) {\n      passages = new Passage[pq.size()];\n      for (int i = pq.size(); --i >= 0; ) {\n        passages[i] = pq.pop();\n      }\n    } else {\n      // Handle the default, no highlighting markers case.\n      passages = pickDefaultPassage(value, maxPassageWindow, permittedPassageRanges);\n    }\n\n    // Correct passage boundaries from maxExclusive window. Typically shrink boundaries until we're\n    // on a proper word/sentence boundary.\n    if (passageAdjuster != null) {\n      passageAdjuster.currentValue(value);\n      for (int x = 0; x < passages.length; x++) {\n        Passage p = passages[x];\n        OffsetRange newRange = passageAdjuster.adjust(p);\n        if (newRange.from != p.from || newRange.to != p.to) {\n          assert newRange.from >= p.from && newRange.to <= p.to\n              : \"Adjusters must not expand the passage's range: was \"\n                  + p\n                  + \" => changed to \"\n                  + newRange;\n          passages[x] = new Passage(newRange.from, newRange.to, p.markers);\n        }\n      }\n    }\n\n    // Ensure there are no overlaps on passages. In case of conflicts, better score wins.\n    int last = 0;\n    for (int i = 0; i < passages.length; i++) {\n      Passage a = passages[i];\n      if (a != null && a.length() > 0) {\n        passages[last++] = a;\n        for (int j = i + 1; j < passages.length; j++) {\n          Passage b = passages[j];\n          if (b != null) {\n            if (adjecentOrOverlapping(a, b)) {\n              passages[j] = null;\n            }\n          }\n        }\n      }\n    }\n\n    // Remove nullified slots.\n    if (passages.length != last) {\n      passages = ArrayUtil.copyOfSubArray(passages, 0, last);\n    }\n\n    // Sort in the offset order again.\n    Arrays.sort(passages, (a, b) -> Integer.compare(a.from, b.from));\n\n    return Arrays.asList(passages);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"060cad2e7ae19bfe202be419234328acf680716c","date":1599747351,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageSelector#pickBest(CharSequence,List[#-extends-OffsetRange],int,int,List[OffsetRange]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageSelector#pickBest(CharSequence,List[#-extends-OffsetRange],int,int,List[OffsetRange]).mjava","sourceNew":"  public List<Passage> pickBest(\n      CharSequence value,\n      List<? extends OffsetRange> markers,\n      int maxPassageWindow,\n      int maxPassages,\n      List<OffsetRange> permittedPassageRanges) {\n    assert markers instanceof RandomAccess;\n    assert permittedPassageRanges instanceof RandomAccess;\n    assert sortedAndNonOverlapping(permittedPassageRanges);\n\n    // Handle odd special cases early.\n    if (value.length() == 0 || maxPassageWindow == 0) {\n      return Collections.emptyList();\n    }\n\n    // Best passages so far.\n    PriorityQueue<Passage> pq =\n        new PriorityQueue<>(maxPassages) {\n          @Override\n          protected boolean lessThan(Passage a, Passage b) {\n            return passageScorer.compare(a, b) < 0;\n          }\n        };\n\n    markers = splitOrTruncateToWindows(markers, maxPassageWindow, permittedPassageRanges);\n\n    // Sort markers by their start offset, shortest first.\n    markers.sort(Comparator.<OffsetRange> comparingInt(r -> r.from).thenComparingInt(r -> r.to));\n\n    final int max = markers.size();\n    int markerIndex = 0;\n    nextRange:\n    for (OffsetRange range : permittedPassageRanges) {\n      final int rangeTo = Math.min(range.to, value.length());\n\n      // Skip ranges outside of the value window anyway.\n      if (range.from >= rangeTo) {\n        continue;\n      }\n\n      while (markerIndex < max) {\n        OffsetRange m = markers.get(markerIndex);\n\n        // Markers are sorted so if the current marker's start is past the range,\n        // we can advance, but we need to check the same marker against the new range.\n        if (m.from >= rangeTo) {\n          continue nextRange;\n        }\n\n        // Check if current marker falls within the range and is smaller than the largest allowed\n        // passage window.\n        if (m.from >= range.from && m.to <= rangeTo && m.length() <= maxPassageWindow) {\n\n          // Adjust the window range to center the highlight marker.\n          int from = (m.from + m.to - maxPassageWindow) / 2;\n          int to = (m.from + m.to + maxPassageWindow) / 2;\n          if (from < range.from) {\n            to += range.from - from;\n            from = range.from;\n          }\n          if (to > rangeTo) {\n            from -= to - rangeTo;\n            to = rangeTo;\n            if (from < range.from) {\n              from = range.from;\n            }\n          }\n\n          if (from < to && to <= value.length()) {\n            // Find other markers that are completely inside the passage window.\n            ArrayList<OffsetRange> inside = new ArrayList<>();\n            int i = markerIndex;\n            while (i > 0 && markers.get(i - 1).from >= from) {\n              i--;\n            }\n\n            OffsetRange c;\n            for (; i < max && (c = markers.get(i)).from < to; i++) {\n              if (c.to <= to) {\n                inside.add(c);\n              }\n            }\n\n            if (!inside.isEmpty()) {\n              pq.insertWithOverflow(new Passage(from, to, inside));\n            }\n          }\n        }\n\n        // Advance to the next marker.\n        markerIndex++;\n      }\n    }\n\n    // Collect from the priority queue (reverse the order so that highest-scoring are first).\n    Passage[] passages;\n    if (pq.size() > 0) {\n      passages = new Passage[pq.size()];\n      for (int i = pq.size(); --i >= 0; ) {\n        passages[i] = pq.pop();\n      }\n    } else {\n      // Handle the default, no highlighting markers case.\n      passages = pickDefaultPassage(value, maxPassageWindow, maxPassages, permittedPassageRanges);\n    }\n\n    // Correct passage boundaries from maxExclusive window. Typically shrink boundaries until we're\n    // on a proper word/sentence boundary.\n    if (passageAdjuster != null) {\n      passageAdjuster.currentValue(value);\n      for (int x = 0; x < passages.length; x++) {\n        Passage p = passages[x];\n        OffsetRange newRange = passageAdjuster.adjust(p);\n        if (newRange.from != p.from || newRange.to != p.to) {\n          assert newRange.from >= p.from && newRange.to <= p.to\n              : \"Adjusters must not expand the passage's range: was \"\n                  + p\n                  + \" => changed to \"\n                  + newRange;\n          passages[x] = new Passage(newRange.from, newRange.to, p.markers);\n        }\n      }\n    }\n\n    // Ensure there are no overlaps on passages. In case of conflicts, better score wins.\n    int last = 0;\n    for (int i = 0; i < passages.length; i++) {\n      Passage a = passages[i];\n      if (a != null && a.length() > 0) {\n        passages[last++] = a;\n        for (int j = i + 1; j < passages.length; j++) {\n          Passage b = passages[j];\n          if (b != null) {\n            if (adjecentOrOverlapping(a, b)) {\n              passages[j] = null;\n            }\n          }\n        }\n      }\n    }\n\n    // Remove nullified slots.\n    if (passages.length != last) {\n      passages = ArrayUtil.copyOfSubArray(passages, 0, last);\n    }\n\n    // Sort in the offset order again.\n    Arrays.sort(passages, Comparator.comparingInt(a -> a.from));\n\n    return Arrays.asList(passages);\n  }\n\n","sourceOld":"  public List<Passage> pickBest(\n      CharSequence value,\n      List<? extends OffsetRange> markers,\n      int maxPassageWindow,\n      int maxPassages,\n      List<OffsetRange> permittedPassageRanges) {\n    assert markers instanceof RandomAccess && permittedPassageRanges instanceof RandomAccess;\n\n    // Handle odd special cases early.\n    if (value.length() == 0 || maxPassageWindow == 0) {\n      return Collections.emptyList();\n    }\n\n    // Sort markers by their start offset, shortest first.\n    markers.sort(\n        (a, b) -> {\n          int v = Integer.compare(a.from, b.from);\n          return v != 0 ? v : Integer.compare(a.to, b.to);\n        });\n\n    // Determine a maximum offset window around each highlight marker and\n    // pick the best scoring passage candidates.\n    PriorityQueue<Passage> pq =\n        new PriorityQueue<>(maxPassages) {\n          @Override\n          protected boolean lessThan(Passage a, Passage b) {\n            return passageScorer.compare(a, b) < 0;\n          }\n        };\n\n    assert sortedAndNonOverlapping(permittedPassageRanges);\n\n    final int max = markers.size();\n    int markerIndex = 0;\n    nextRange:\n    for (OffsetRange range : permittedPassageRanges) {\n      final int rangeTo = Math.min(range.to, value.length());\n\n      // Skip ranges outside of the value window anyway.\n      if (range.from >= rangeTo) {\n        continue;\n      }\n\n      while (markerIndex < max) {\n        OffsetRange m = markers.get(markerIndex);\n\n        // Markers are sorted so if the current marker's start is past the range,\n        // we can advance, but we need to check the same marker against the new range.\n        if (m.from >= rangeTo) {\n          continue nextRange;\n        }\n\n        // Check if current marker falls within the range and is smaller than the largest allowed\n        // passage window.\n        if (m.from >= range.from && m.to <= rangeTo && m.length() <= maxPassageWindow) {\n\n          // Adjust the window range to center the highlight marker.\n          int from = (m.from + m.to - maxPassageWindow) / 2;\n          int to = (m.from + m.to + maxPassageWindow) / 2;\n          if (from < range.from) {\n            to += range.from - from;\n            from = range.from;\n          }\n          if (to > rangeTo) {\n            from -= to - rangeTo;\n            to = rangeTo;\n            if (from < range.from) {\n              from = range.from;\n            }\n          }\n\n          if (from < to && to <= value.length()) {\n            // Find other markers that are completely inside the passage window.\n            ArrayList<OffsetRange> inside = new ArrayList<>();\n            int i = markerIndex;\n            while (i > 0 && markers.get(i - 1).from >= from) {\n              i--;\n            }\n\n            OffsetRange c;\n            for (; i < max && (c = markers.get(i)).from < to; i++) {\n              if (c.to <= to) {\n                inside.add(c);\n              }\n            }\n\n            if (!inside.isEmpty()) {\n              pq.insertWithOverflow(new Passage(from, to, inside));\n            }\n          }\n        }\n\n        // Advance to the next marker.\n        markerIndex++;\n      }\n    }\n\n    // Collect from the priority queue (reverse the order so that highest-scoring are first).\n    Passage[] passages;\n    if (pq.size() > 0) {\n      passages = new Passage[pq.size()];\n      for (int i = pq.size(); --i >= 0; ) {\n        passages[i] = pq.pop();\n      }\n    } else {\n      // Handle the default, no highlighting markers case.\n      passages = pickDefaultPassage(value, maxPassageWindow, permittedPassageRanges);\n    }\n\n    // Correct passage boundaries from maxExclusive window. Typically shrink boundaries until we're\n    // on a proper word/sentence boundary.\n    if (passageAdjuster != null) {\n      passageAdjuster.currentValue(value);\n      for (int x = 0; x < passages.length; x++) {\n        Passage p = passages[x];\n        OffsetRange newRange = passageAdjuster.adjust(p);\n        if (newRange.from != p.from || newRange.to != p.to) {\n          assert newRange.from >= p.from && newRange.to <= p.to\n              : \"Adjusters must not expand the passage's range: was \"\n                  + p\n                  + \" => changed to \"\n                  + newRange;\n          passages[x] = new Passage(newRange.from, newRange.to, p.markers);\n        }\n      }\n    }\n\n    // Ensure there are no overlaps on passages. In case of conflicts, better score wins.\n    int last = 0;\n    for (int i = 0; i < passages.length; i++) {\n      Passage a = passages[i];\n      if (a != null && a.length() > 0) {\n        passages[last++] = a;\n        for (int j = i + 1; j < passages.length; j++) {\n          Passage b = passages[j];\n          if (b != null) {\n            if (adjecentOrOverlapping(a, b)) {\n              passages[j] = null;\n            }\n          }\n        }\n      }\n    }\n\n    // Remove nullified slots.\n    if (passages.length != last) {\n      passages = ArrayUtil.copyOfSubArray(passages, 0, last);\n    }\n\n    // Sort in the offset order again.\n    Arrays.sort(passages, (a, b) -> Integer.compare(a.from, b.from));\n\n    return Arrays.asList(passages);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"060cad2e7ae19bfe202be419234328acf680716c":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["060cad2e7ae19bfe202be419234328acf680716c"]},"commit2Childs":{"060cad2e7ae19bfe202be419234328acf680716c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["060cad2e7ae19bfe202be419234328acf680716c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}