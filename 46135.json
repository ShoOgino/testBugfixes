{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","commits":[{"id":"9cf81bc8c6e4078e236f0e38b3a2d0271854f207","date":1364832963,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  public IndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    SolrResourceLoader loader = config.getResourceLoader();\n    this.loader = loader;\n    InputStream schemaInputStream = null;\n    boolean shouldUpgrade = false;\n    String loadedResource = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    try {\n      // Attempt to load the managed schema\n      schemaInputStream = loader.openSchema(managedSchemaResourceName);\n      loadedResource = managedSchemaResourceName;\n\n      // Check if the non-managed schema is also present\n      if ( ! resourceName.equals(managedSchemaResourceName)) {\n        if (nonManagedSchemaExists()) {\n          // Warn if the non-managed schema is present\n          log.warn(\"The schema has been upgraded to managed, but the non-managed schema \" + resourceName\n              + \" is still loadable.  PLEASE REMOVE THIS FILE.\");\n        }\n      }\n    } catch (IOException e) {\n      log.info(\"SolrConfig.isManagedSchema = true, but managed schema resource \" + managedSchemaResourceName\n          + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n    }\n    if (null == schemaInputStream) {\n      // The managed schema file could not be found - load the non-managed schema\n      try {\n        schemaInputStream = loader.openSchema(resourceName);\n        loadedResource = resourceName;\n        shouldUpgrade = true;\n      } catch (Exception e) {\n        try {\n          // Retry to load the managed schema, in case it was created since the first attempt\n          schemaInputStream = loader.openSchema(managedSchemaResourceName);\n          loadedResource = managedSchemaResourceName;\n        } catch (IOException e1) {\n          final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                           + managedSchemaResourceName + \"'\";\n          log.error(msg, e);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable);\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n    return schema;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["df151630bfbea5338a007b97bfd37e4ec94f873f","3c54b2e707ac07b7487f868bdb6e3619acc4bba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  public IndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    SolrResourceLoader loader = config.getResourceLoader();\n    this.loader = loader;\n    InputStream schemaInputStream = null;\n    boolean shouldUpgrade = false;\n    String loadedResource = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    try {\n      // Attempt to load the managed schema\n      schemaInputStream = loader.openSchema(managedSchemaResourceName);\n      loadedResource = managedSchemaResourceName;\n\n      // Check if the non-managed schema is also present\n      if ( ! resourceName.equals(managedSchemaResourceName)) {\n        if (nonManagedSchemaExists()) {\n          // Warn if the non-managed schema is present\n          log.warn(\"The schema has been upgraded to managed, but the non-managed schema \" + resourceName\n              + \" is still loadable.  PLEASE REMOVE THIS FILE.\");\n        }\n      }\n    } catch (IOException e) {\n      log.info(\"SolrConfig.isManagedSchema = true, but managed schema resource \" + managedSchemaResourceName\n          + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n    }\n    if (null == schemaInputStream) {\n      // The managed schema file could not be found - load the non-managed schema\n      try {\n        schemaInputStream = loader.openSchema(resourceName);\n        loadedResource = resourceName;\n        shouldUpgrade = true;\n      } catch (Exception e) {\n        try {\n          // Retry to load the managed schema, in case it was created since the first attempt\n          schemaInputStream = loader.openSchema(managedSchemaResourceName);\n          loadedResource = managedSchemaResourceName;\n        } catch (IOException e1) {\n          final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                           + managedSchemaResourceName + \"'\";\n          log.error(msg, e);\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable);\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17778d9c1f3a8a67383edebf24754bf30a5120f8","date":1415342366,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3999b5177c693481afc066e50b4719b31216cd7","date":1415343393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#collectionZkPath}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b5def504fd31bf228a682812a13b396c8f928cd","date":1475211800,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df151630bfbea5338a007b97bfd37e4ec94f873f","date":1553017904,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    try {\n      schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable, \n                                      managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207","08970e5b8411182a29412c177eff67ec1110095b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c54b2e707ac07b7487f868bdb6e3619acc4bba0","date":1554713249,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      synchronized (schema.getSchemaUpdateLock()) {\n        upgradeToManagedSchema();\n      }\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      upgradeToManagedSchema();\n    }\n\n    return schema;\n  }\n\n","bugFix":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openResource(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      synchronized (schema.getSchemaUpdateLock()) {\n        upgradeToManagedSchema();\n      }\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openSchema(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      synchronized (schema.getSchemaUpdateLock()) {\n        upgradeToManagedSchema();\n      }\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#create(String,SolrConfig).mjava","sourceNew":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource {} not found - loading non-managed schema {} instead\"\n            , managedSchemaResourceName, resourceName);\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openResource(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      synchronized (schema.getSchemaUpdateLock()) {\n        upgradeToManagedSchema();\n      }\n    }\n\n    return schema;\n  }\n\n","sourceOld":"  /**\n   * First, try to locate the managed schema file named in the managedSchemaResourceName\n   * param. If the managed schema file exists and is accessible, it is used to instantiate\n   * an IndexSchema.\n   *\n   * If the managed schema file can't be found, the resource named by the resourceName\n   * parameter is used to instantiate an IndexSchema.\n   *\n   * Once the IndexSchema is instantiated, if the managed schema file does not exist,\n   * the instantiated IndexSchema is persisted to the managed schema file named in the\n   * managedSchemaResourceName param, in the directory given by \n   * {@link org.apache.solr.core.SolrResourceLoader#getConfigDir()}, or if configs are\n   * in ZooKeeper, under {@link org.apache.solr.cloud.ZkSolrResourceLoader#getConfigSetZkPath()}.\n   *\n   * After the managed schema file is persisted, the original schema file is\n   * renamed by appending the extension named in {@link #UPGRADED_SCHEMA_EXTENSION}.\n   */\n  @Override\n  public ManagedIndexSchema create(String resourceName, SolrConfig config) {\n    this.resourceName = resourceName;\n    this.config = config;\n    this.loader = config.getResourceLoader();\n    InputStream schemaInputStream = null;\n\n    if (null == resourceName) {\n      resourceName = IndexSchema.DEFAULT_SCHEMA_FILE;\n    }\n\n    int schemaZkVersion = -1;\n    if ( ! (loader instanceof ZkSolrResourceLoader)) {\n      schemaInputStream = readSchemaLocally();\n    } else { // ZooKeeper\n      final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final SolrZkClient zkClient = zkLoader.getZkController().getZkClient();\n      final String managedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + managedSchemaResourceName;\n      Stat stat = new Stat();\n      try {\n        // Attempt to load the managed schema\n        byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n        schemaZkVersion = stat.getVersion();\n        schemaInputStream = new ByteArrayInputStream(data);\n        loadedResource = managedSchemaResourceName;\n        warnIfNonManagedSchemaExists();\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      } catch (KeeperException.NoNodeException e) {\n        log.info(\"The schema is configured as managed, but managed schema resource \" + managedSchemaResourceName\n                + \" not found - loading non-managed schema \" + resourceName + \" instead\");\n      } catch (KeeperException e) {\n        String msg = \"Error attempting to access \" + managedSchemaPath;\n        log.error(msg, e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, msg, e);\n      }\n      if (null == schemaInputStream) {\n        // The managed schema file could not be found - load the non-managed schema\n        try {\n          schemaInputStream = loader.openResource(resourceName);\n          loadedResource = resourceName;\n          shouldUpgrade = true;\n        } catch (Exception e) {\n          try {\n            // Retry to load the managed schema, in case it was created since the first attempt\n            byte[] data = zkClient.getData(managedSchemaPath, null, stat, true);\n            schemaZkVersion = stat.getVersion();\n            schemaInputStream = new ByteArrayInputStream(data);\n            loadedResource = managedSchemaPath;\n            warnIfNonManagedSchemaExists();\n          } catch (Exception e1) {\n            if (e1 instanceof InterruptedException) {\n              Thread.currentThread().interrupt(); // Restore the interrupted status\n            }\n            final String msg = \"Error loading both non-managed schema '\" + resourceName + \"' and managed schema '\"\n                             + managedSchemaResourceName + \"'\";\n            log.error(msg, e);\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n          }\n        }\n      }\n    }\n    InputSource inputSource = new InputSource(schemaInputStream);\n    inputSource.setSystemId(SystemIdResolver.createSystemIdFromResourceName(loadedResource));\n    schema = new ManagedIndexSchema(config, loadedResource, inputSource, isMutable,\n                                    managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    if (shouldUpgrade) {\n      // Persist the managed schema if it doesn't already exist\n      synchronized (schema.getSchemaUpdateLock()) {\n        upgradeToManagedSchema();\n      }\n    }\n\n    return schema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"17778d9c1f3a8a67383edebf24754bf30a5120f8":["08970e5b8411182a29412c177eff67ec1110095b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c3999b5177c693481afc066e50b4719b31216cd7","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c3999b5177c693481afc066e50b4719b31216cd7":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"08970e5b8411182a29412c177eff67ec1110095b":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"2b5def504fd31bf228a682812a13b396c8f928cd":["c3999b5177c693481afc066e50b4719b31216cd7"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["3c54b2e707ac07b7487f868bdb6e3619acc4bba0"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c3999b5177c693481afc066e50b4719b31216cd7","2b5def504fd31bf228a682812a13b396c8f928cd"],"3c54b2e707ac07b7487f868bdb6e3619acc4bba0":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9df8125ba9193a2e2e285ed92157810b1952a244":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"]},"commit2Childs":{"17778d9c1f3a8a67383edebf24754bf30a5120f8":["c3999b5177c693481afc066e50b4719b31216cd7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"08970e5b8411182a29412c177eff67ec1110095b":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"c3999b5177c693481afc066e50b4719b31216cd7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2b5def504fd31bf228a682812a13b396c8f928cd","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"2b5def504fd31bf228a682812a13b396c8f928cd":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["08970e5b8411182a29412c177eff67ec1110095b"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["3c54b2e707ac07b7487f868bdb6e3619acc4bba0"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","df151630bfbea5338a007b97bfd37e4ec94f873f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"3c54b2e707ac07b7487f868bdb6e3619acc4bba0":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}