{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","commits":[{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e","date":1487462440,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2209af2c265d2258ec4b29c8cc78622d36994a15":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e"]},"commit2Childs":{"2209af2c265d2258ec4b29c8cc78622d36994a15":["f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}