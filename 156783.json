{"path":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","commits":[{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndLiveDocs#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * dont (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * dont (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"730f45f9ea2d3058f9701d81a36c68424945b5a7","date":1402574060,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * dont (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36806c9f10b98eb6e3437d2db592d0418c97602c","date":1402575980,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * dont (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      assert reader.getLiveDocs() == liveDocs;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.getDocCount() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs in initWritableLiveDocs even if it's null\n    liveDocsShared = true;\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeleteCount);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs, info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72","date":1523453225,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    markAsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    markAsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    pendingDeletes.liveDocsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13bce432480722e4f48bce0da3623dab44dd8d9c","date":1525873214,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    markAsShared();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4987206dabc9f3576bb1df72e987094a7dad6e4f","date":1527510516,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(info, reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(reader.getSegmentInfo(), reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aef2a94da918b657d107b616a643e1759db43b6a","date":1527706131,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(info, reader, liveDocs, pendingDeletes.numDocs());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(info, reader, liveDocs,\n          info.info.maxDoc() - info.getDelCount() - pendingDeletes.numPendingDeletes());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"578a4d73d90ecd838846cc32bf1098aaa262b524","date":1532504076,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#getReadOnlyClone(IOContext).mjava","sourceNew":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(info, reader, liveDocs, pendingDeletes.getHardLiveDocs(), pendingDeletes.numDocs(), true);\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a ref to a clone. NOTE: you should decRef() the reader when you're\n   * done (ie do not call close()).\n   */\n  public synchronized SegmentReader getReadOnlyClone(IOContext context) throws IOException {\n    if (reader == null) {\n      getReader(context).decRef();\n      assert reader != null;\n    }\n    // force new liveDocs\n    Bits liveDocs = pendingDeletes.getLiveDocs();\n    if (liveDocs != null) {\n      return new SegmentReader(info, reader, liveDocs, pendingDeletes.numDocs());\n    } else {\n      // liveDocs == null and reader != null. That can only be if there are no deletes\n      assert reader.getLiveDocs() == null;\n      reader.incRef();\n      return reader;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"36806c9f10b98eb6e3437d2db592d0418c97602c":["730f45f9ea2d3058f9701d81a36c68424945b5a7"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"b0267c69e2456a3477a1ad785723f2135da3117e":["36806c9f10b98eb6e3437d2db592d0418c97602c"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["b0267c69e2456a3477a1ad785723f2135da3117e","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["b0267c69e2456a3477a1ad785723f2135da3117e"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["5ee0394b8176abd7c90a4be8c05465be1879db79","9ae87c7be37e537f40fa3bb2c35fa4a368d12a72"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","36806c9f10b98eb6e3437d2db592d0418c97602c"],"578a4d73d90ecd838846cc32bf1098aaa262b524":["aef2a94da918b657d107b616a643e1759db43b6a"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["13bce432480722e4f48bce0da3623dab44dd8d9c"],"730f45f9ea2d3058f9701d81a36c68424945b5a7":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["36806c9f10b98eb6e3437d2db592d0418c97602c","b0267c69e2456a3477a1ad785723f2135da3117e"],"13bce432480722e4f48bce0da3623dab44dd8d9c":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"b06445ae1731e049327712db0454e5643ca9b7fe":["36806c9f10b98eb6e3437d2db592d0418c97602c","b0267c69e2456a3477a1ad785723f2135da3117e"],"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aef2a94da918b657d107b616a643e1759db43b6a":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["578a4d73d90ecd838846cc32bf1098aaa262b524"]},"commit2Childs":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","730f45f9ea2d3058f9701d81a36c68424945b5a7"],"36806c9f10b98eb6e3437d2db592d0418c97602c":["b0267c69e2456a3477a1ad785723f2135da3117e","c6f080a2ab37c464dd98db173f6cbf10dc74f211","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["43345f1452f9510f8aaadae6156fe0c834e7d957","9ae87c7be37e537f40fa3bb2c35fa4a368d12a72"],"b0267c69e2456a3477a1ad785723f2135da3117e":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["13bce432480722e4f48bce0da3623dab44dd8d9c"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"578a4d73d90ecd838846cc32bf1098aaa262b524":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["aef2a94da918b657d107b616a643e1759db43b6a"],"730f45f9ea2d3058f9701d81a36c68424945b5a7":["36806c9f10b98eb6e3437d2db592d0418c97602c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"13bce432480722e4f48bce0da3623dab44dd8d9c":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"aef2a94da918b657d107b616a643e1759db43b6a":["578a4d73d90ecd838846cc32bf1098aaa262b524"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}