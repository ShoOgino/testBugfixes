{"path":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","commits":[{"id":"36f5a8c57e16c0f801006a52f87c75378427852e","date":1393256707,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/Sort#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRef scratch = new BytesRef();\n    while ((scratch.bytes = reader.read()) != null) {\n      scratch.length = scratch.bytes.length; \n      buffer.append(scratch);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (ramBufferSize.bytes < bufferBytesUsed.get()) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRef scratch = new BytesRef();\n    while ((scratch.bytes = reader.read()) != null) {\n      scratch.length = scratch.bytes.length; \n      buffer.append(scratch);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (ramBufferSize.bytes < bufferBytesUsed.get()) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/Sort#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRef scratch = new BytesRef();\n    while ((scratch.bytes = reader.read()) != null) {\n      scratch.length = scratch.bytes.length; \n      buffer.append(scratch);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (ramBufferSize.bytes < bufferBytesUsed.get()) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRef scratch = new BytesRef();\n    while ((scratch.bytes = reader.read()) != null) {\n      scratch.length = scratch.bytes.length; \n      buffer.append(scratch);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (ramBufferSize.bytes < bufferBytesUsed.get()) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRefBuilder scratch = new BytesRefBuilder();\n    while (reader.read(scratch)) {\n      buffer.append(scratch.get());\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRef scratch = new BytesRef();\n    while ((scratch.bytes = reader.read()) != null) {\n      scratch.length = scratch.bytes.length; \n      buffer.append(scratch);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (ramBufferSize.bytes < bufferBytesUsed.get()) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRefBuilder scratch = new BytesRefBuilder();\n    while (true) {\n      boolean result = false;\n      try {\n        result = reader.read(scratch);\n      } catch (Throwable t) {\n        verifyChecksum(t, reader);\n      }\n      if (result == false) {\n        break;\n      }\n      buffer.append(scratch.get());\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRefBuilder scratch = new BytesRefBuilder();\n    while (reader.read(scratch)) {\n      buffer.append(scratch.get());\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7849935cc625c020857f3b29be91b5d4323d19aa","date":1458978426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    while (true) {\n      BytesRef item = null;\n      try {\n        item = reader.next();\n      } catch (Throwable t) {\n        verifyChecksum(t, reader);\n      }\n      if (item == null) {\n        break;\n      }\n      buffer.append(item);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    final BytesRefBuilder scratch = new BytesRefBuilder();\n    while (true) {\n      boolean result = false;\n      try {\n        result = reader.read(scratch);\n      } catch (Throwable t) {\n        verifyChecksum(t, reader);\n      }\n      if (result == false) {\n        break;\n      }\n      buffer.append(scratch.get());\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee52259641568741fbc6ecc51284431e2a36475c","date":1459331525,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    while (true) {\n      BytesRef item = null;\n      try {\n        item = reader.next();\n      } catch (Throwable t) {\n        verifyChecksum(t, reader);\n      }\n      if (item == null) {\n        break;\n      }\n      buffer.append(item);\n      // Account for the created objects.\n      // (buffer slots do not account to buffer size.) \n      if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n        break;\n      }\n    }\n    sortInfo.readTime += (System.currentTimeMillis() - start);\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce0dc549cffe574c5e49b654c95a60713e0453c","date":1492031850,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":null,"sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dcb0432bcb41451b41e9aaaabe99f5d208258fe","date":1493203108,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    long start = System.currentTimeMillis();\n    SortableBytesRefArray buffer;\n    boolean exhausted = false;\n    int count;\n    if (valueLength != -1) {\n      // fixed length case\n      buffer = new FixedLengthBytesRefArray(valueLength);\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      Counter bufferBytesUsed = Counter.newCounter();\n      buffer = new BytesRefArray(bufferBytesUsed);\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTimeMS += System.currentTimeMillis() - start;\n\n    return new Partition(buffer, exhausted);\n  }\n\n","sourceOld":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36a23c6fa37610e466602f47f4ddf1e7a8e702e5","date":1493213774,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    boolean success = false;\n    try {\n      long start = System.currentTimeMillis();\n      SortableBytesRefArray buffer;\n      boolean exhausted = false;\n      int count;\n      if (valueLength != -1) {\n        // fixed length case\n        buffer = new FixedLengthBytesRefArray(valueLength);\n        int limit = ramBufferSize.bytes / valueLength;\n        for(int i=0;i<limit;i++) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n        }\n      } else {\n        Counter bufferBytesUsed = Counter.newCounter();\n        buffer = new BytesRefArray(bufferBytesUsed);\n        while (true) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n          // Account for the created objects.\n          // (buffer slots do not account to buffer size.) \n          if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n            break;\n          }\n        }\n      }\n      sortInfo.readTimeMS += System.currentTimeMillis() - start;\n      success = true;\n      return new Partition(buffer, exhausted);\n    } finally {\n      if (success == false && partitionsInRAM != null) {\n        partitionsInRAM.release();\n      }\n    }\n  }\n\n","sourceOld":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    long start = System.currentTimeMillis();\n    SortableBytesRefArray buffer;\n    boolean exhausted = false;\n    int count;\n    if (valueLength != -1) {\n      // fixed length case\n      buffer = new FixedLengthBytesRefArray(valueLength);\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      Counter bufferBytesUsed = Counter.newCounter();\n      buffer = new BytesRefArray(bufferBytesUsed);\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTimeMS += System.currentTimeMillis() - start;\n\n    return new Partition(buffer, exhausted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"/dev/null","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    boolean success = false;\n    try {\n      long start = System.currentTimeMillis();\n      SortableBytesRefArray buffer;\n      boolean exhausted = false;\n      int count;\n      if (valueLength != -1) {\n        // fixed length case\n        buffer = new FixedLengthBytesRefArray(valueLength);\n        int limit = ramBufferSize.bytes / valueLength;\n        for(int i=0;i<limit;i++) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n        }\n      } else {\n        Counter bufferBytesUsed = Counter.newCounter();\n        buffer = new BytesRefArray(bufferBytesUsed);\n        while (true) {\n          BytesRef item = null;\n          try {\n            item = reader.next();\n          } catch (Throwable t) {\n            verifyChecksum(t, reader);\n          }\n          if (item == null) {\n            exhausted = true;\n            break;\n          }\n          buffer.append(item);\n          // Account for the created objects.\n          // (buffer slots do not account to buffer size.) \n          if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n            break;\n          }\n        }\n      }\n      sortInfo.readTimeMS += System.currentTimeMillis() - start;\n      success = true;\n      return new Partition(buffer, exhausted);\n    } finally {\n      if (success == false && partitionsInRAM != null) {\n        partitionsInRAM.release();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ee52259641568741fbc6ecc51284431e2a36475c"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["9ce0dc549cffe574c5e49b654c95a60713e0453c"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","36f5a8c57e16c0f801006a52f87c75378427852e"],"36f5a8c57e16c0f801006a52f87c75378427852e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7849935cc625c020857f3b29be91b5d4323d19aa":["950b7a6881d14da782b60444c11295e3ec50d41a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee52259641568741fbc6ecc51284431e2a36475c":["7849935cc625c020857f3b29be91b5d4323d19aa"],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["ee52259641568741fbc6ecc51284431e2a36475c"],"950b7a6881d14da782b60444c11295e3ec50d41a":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["950b7a6881d14da782b60444c11295e3ec50d41a"],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"ba791bce8103c79e38f957e9c5a53a75871bd918":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"36f5a8c57e16c0f801006a52f87c75378427852e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba791bce8103c79e38f957e9c5a53a75871bd918","36f5a8c57e16c0f801006a52f87c75378427852e"],"7849935cc625c020857f3b29be91b5d4323d19aa":["ee52259641568741fbc6ecc51284431e2a36475c"],"ee52259641568741fbc6ecc51284431e2a36475c":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9ce0dc549cffe574c5e49b654c95a60713e0453c"],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"950b7a6881d14da782b60444c11295e3ec50d41a":["7849935cc625c020857f3b29be91b5d4323d19aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}