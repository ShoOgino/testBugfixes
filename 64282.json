{"path":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7347509fad0711ac30cb15a746e9a3830a38ebd","date":1275388513,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"200dc81344eedd33337ec942fb6203faebb1bb4b","date":1282312595,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6aab5206b894bf0ea232b059a45cf2de460726f","date":1284150281,"type":5,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    }    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true && theSuggestions.size()>0){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d6aab5206b894bf0ea232b059a45cf2de460726f":["200dc81344eedd33337ec942fb6203faebb1bb4b"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"200dc81344eedd33337ec942fb6203faebb1bb4b":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a7347509fad0711ac30cb15a746e9a3830a38ebd","d6aab5206b894bf0ea232b059a45cf2de460726f"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d6aab5206b894bf0ea232b059a45cf2de460726f"]},"commit2Childs":{"d6aab5206b894bf0ea232b059a45cf2de460726f":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1da8d55113b689b06716246649de6f62430f15c0":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"200dc81344eedd33337ec942fb6203faebb1bb4b":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["200dc81344eedd33337ec942fb6203faebb1bb4b","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}