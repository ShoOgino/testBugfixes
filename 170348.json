{"path":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","commits":[{"id":"165c3432cb3c4fcfc8e859af24323bbbd12084af","date":1532292166,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Matches matches(LeafReaderContext context, int doc) throws IOException {\n    return Matches.forField(field, () -> {\n      Spans spans = getSpans(context, Postings.OFFSETS);\n      if (spans == null) {\n        return null;\n      }\n      if (spans.advance(doc) != doc) {\n        return null;\n      }\n      return new MatchesIterator() {\n\n        int innerTermCount = 0;\n        int[][] innerTerms = new int[2][3];\n        SpanCollector termCollector = new SpanCollector() {\n          @Override\n          public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {\n            innerTermCount++;\n            if (innerTermCount > innerTerms.length) {\n              int[][] temp = new int[innerTermCount][3];\n              System.arraycopy(innerTerms, 0, temp, 0, innerTermCount - 1);\n              innerTerms = temp;\n            }\n            innerTerms[innerTermCount - 1][0] = position;\n            innerTerms[innerTermCount - 1][1] = postings.startOffset();\n            innerTerms[innerTermCount - 1][2] = postings.endOffset();\n          }\n\n          @Override\n          public void reset() {\n            innerTermCount = 0;\n          }\n        };\n\n        @Override\n        public boolean next() throws IOException {\n          innerTermCount = 0;\n          return spans.nextStartPosition() != Spans.NO_MORE_POSITIONS;\n        }\n\n        @Override\n        public int startPosition() {\n          return spans.startPosition();\n        }\n\n        @Override\n        public int endPosition() {\n          return spans.endPosition() - 1;\n        }\n\n        @Override\n        public int startOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[0][1];\n        }\n\n        @Override\n        public int endOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[innerTermCount - 1][2];\n        }\n\n        @Override\n        public MatchesIterator getSubMatches() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return new MatchesIterator() {\n\n            int upto = -1;\n\n            @Override\n            public boolean next() throws IOException {\n              upto++;\n              return upto < innerTermCount;\n            }\n\n            @Override\n            public int startPosition() {\n              return innerTerms[upto][0];\n            }\n\n            @Override\n            public int endPosition() {\n              return innerTerms[upto][0];\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return innerTerms[upto][1];\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return innerTerms[upto][2];\n            }\n\n            @Override\n            public MatchesIterator getSubMatches() throws IOException {\n              return MatchesIterator.EMPTY_ITERATOR;\n            }\n\n            @Override\n            public Object label() {\n              return this;\n            }\n          };\n        }\n\n        @Override\n        public Object label() {\n          return SpanWeight.this;\n        }\n\n        void collectInnerTerms() throws IOException {\n          termCollector.reset();\n          spans.collect(termCollector);\n          Arrays.sort(innerTerms, 0, innerTermCount, Comparator.comparing(a -> a[0]));\n        }\n      };\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62ba8124694976baa3b03705351de238ec5d4352","date":1532295406,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Matches matches(LeafReaderContext context, int doc) throws IOException {\n    return Matches.forField(field, () -> {\n      Spans spans = getSpans(context, Postings.OFFSETS);\n      if (spans == null) {\n        return null;\n      }\n      if (spans.advance(doc) != doc) {\n        return null;\n      }\n      return new MatchesIterator() {\n\n        int innerTermCount = 0;\n        int[][] innerTerms = new int[2][3];\n        SpanCollector termCollector = new SpanCollector() {\n          @Override\n          public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {\n            innerTermCount++;\n            if (innerTermCount > innerTerms.length) {\n              int[][] temp = new int[innerTermCount][3];\n              System.arraycopy(innerTerms, 0, temp, 0, innerTermCount - 1);\n              innerTerms = temp;\n            }\n            innerTerms[innerTermCount - 1][0] = position;\n            innerTerms[innerTermCount - 1][1] = postings.startOffset();\n            innerTerms[innerTermCount - 1][2] = postings.endOffset();\n          }\n\n          @Override\n          public void reset() {\n            innerTermCount = 0;\n          }\n        };\n\n        @Override\n        public boolean next() throws IOException {\n          innerTermCount = 0;\n          return spans.nextStartPosition() != Spans.NO_MORE_POSITIONS;\n        }\n\n        @Override\n        public int startPosition() {\n          return spans.startPosition();\n        }\n\n        @Override\n        public int endPosition() {\n          return spans.endPosition() - 1;\n        }\n\n        @Override\n        public int startOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[0][1];\n        }\n\n        @Override\n        public int endOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[innerTermCount - 1][2];\n        }\n\n        @Override\n        public MatchesIterator getSubMatches() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return new MatchesIterator() {\n\n            int upto = -1;\n\n            @Override\n            public boolean next() throws IOException {\n              upto++;\n              return upto < innerTermCount;\n            }\n\n            @Override\n            public int startPosition() {\n              return innerTerms[upto][0];\n            }\n\n            @Override\n            public int endPosition() {\n              return innerTerms[upto][0];\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return innerTerms[upto][1];\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return innerTerms[upto][2];\n            }\n\n            @Override\n            public MatchesIterator getSubMatches() throws IOException {\n              return MatchesIterator.EMPTY_ITERATOR;\n            }\n\n            @Override\n            public Object label() {\n              return this;\n            }\n          };\n        }\n\n        @Override\n        public Object label() {\n          return SpanWeight.this;\n        }\n\n        void collectInnerTerms() throws IOException {\n          termCollector.reset();\n          spans.collect(termCollector);\n          Arrays.sort(innerTerms, 0, innerTermCount, Comparator.comparing(a -> a[0]));\n        }\n      };\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41ebc07bccf12a902ca6a0077910d18ee38b695f","date":1532336521,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Matches matches(LeafReaderContext context, int doc) throws IOException {\n    return Matches.forField(field, () -> {\n      Spans spans = getSpans(context, Postings.OFFSETS);\n      if (spans == null || spans.advance(doc) != doc) {\n        return null;\n      }\n      return new MatchesIterator() {\n\n        int innerTermCount = 0;\n        TermMatch[] innerTerms = new TermMatch[0];\n\n        SpanCollector termCollector = new SpanCollector() {\n          @Override\n          public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {\n            innerTermCount++;\n            if (innerTermCount > innerTerms.length) {\n              TermMatch[] temp = new TermMatch[innerTermCount];\n              System.arraycopy(innerTerms, 0, temp, 0, innerTermCount - 1);\n              innerTerms = temp;\n              innerTerms[innerTermCount - 1] = new TermMatch();\n            }\n            innerTerms[innerTermCount - 1].term = term;\n            innerTerms[innerTermCount - 1].position = position;\n            innerTerms[innerTermCount - 1].startOffset = postings.startOffset();\n            innerTerms[innerTermCount - 1].endOffset = postings.endOffset();\n          }\n\n          @Override\n          public void reset() {\n            innerTermCount = 0;\n          }\n        };\n\n        @Override\n        public boolean next() throws IOException {\n          innerTermCount = 0;\n          return spans.nextStartPosition() != Spans.NO_MORE_POSITIONS;\n        }\n\n        @Override\n        public int startPosition() {\n          return spans.startPosition();\n        }\n\n        @Override\n        public int endPosition() {\n          return spans.endPosition() - 1;\n        }\n\n        @Override\n        public int startOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[0].startOffset;\n        }\n\n        @Override\n        public int endOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[innerTermCount - 1].endOffset;\n        }\n\n        @Override\n        public MatchesIterator getSubMatches() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return new MatchesIterator() {\n\n            int upto = -1;\n\n            @Override\n            public boolean next() throws IOException {\n              upto++;\n              return upto < innerTermCount;\n            }\n\n            @Override\n            public int startPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int endPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return innerTerms[upto].startOffset;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return innerTerms[upto].endOffset;\n            }\n\n            @Override\n            public MatchesIterator getSubMatches() throws IOException {\n              return null;\n            }\n\n            @Override\n            public Query getQuery() {\n              return new TermQuery(innerTerms[upto].term);\n            }\n          };\n        }\n\n        @Override\n        public Query getQuery() {\n          return SpanWeight.this.getQuery();\n        }\n\n        void collectInnerTerms() throws IOException {\n          termCollector.reset();\n          spans.collect(termCollector);\n          Arrays.sort(innerTerms, 0, innerTermCount, Comparator.comparing(a -> a.position));\n        }\n      };\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2375622520a4e480775e3104a2f9a423536755b4","date":1536005521,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight#matches(LeafReaderContext,int).mjava","sourceNew":"  @Override\n  public Matches matches(LeafReaderContext context, int doc) throws IOException {\n    return MatchesUtils.forField(field, () -> {\n      Spans spans = getSpans(context, Postings.OFFSETS);\n      if (spans == null || spans.advance(doc) != doc) {\n        return null;\n      }\n      return new MatchesIterator() {\n\n        int innerTermCount = 0;\n        TermMatch[] innerTerms = new TermMatch[0];\n\n        SpanCollector termCollector = new SpanCollector() {\n          @Override\n          public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {\n            innerTermCount++;\n            if (innerTermCount > innerTerms.length) {\n              TermMatch[] temp = new TermMatch[innerTermCount];\n              System.arraycopy(innerTerms, 0, temp, 0, innerTermCount - 1);\n              innerTerms = temp;\n              innerTerms[innerTermCount - 1] = new TermMatch();\n            }\n            innerTerms[innerTermCount - 1].term = term;\n            innerTerms[innerTermCount - 1].position = position;\n            innerTerms[innerTermCount - 1].startOffset = postings.startOffset();\n            innerTerms[innerTermCount - 1].endOffset = postings.endOffset();\n          }\n\n          @Override\n          public void reset() {\n            innerTermCount = 0;\n          }\n        };\n\n        @Override\n        public boolean next() throws IOException {\n          innerTermCount = 0;\n          return spans.nextStartPosition() != Spans.NO_MORE_POSITIONS;\n        }\n\n        @Override\n        public int startPosition() {\n          return spans.startPosition();\n        }\n\n        @Override\n        public int endPosition() {\n          return spans.endPosition() - 1;\n        }\n\n        @Override\n        public int startOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[0].startOffset;\n        }\n\n        @Override\n        public int endOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[innerTermCount - 1].endOffset;\n        }\n\n        @Override\n        public MatchesIterator getSubMatches() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return new MatchesIterator() {\n\n            int upto = -1;\n\n            @Override\n            public boolean next() throws IOException {\n              upto++;\n              return upto < innerTermCount;\n            }\n\n            @Override\n            public int startPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int endPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return innerTerms[upto].startOffset;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return innerTerms[upto].endOffset;\n            }\n\n            @Override\n            public MatchesIterator getSubMatches() throws IOException {\n              return null;\n            }\n\n            @Override\n            public Query getQuery() {\n              return new TermQuery(innerTerms[upto].term);\n            }\n          };\n        }\n\n        @Override\n        public Query getQuery() {\n          return SpanWeight.this.getQuery();\n        }\n\n        void collectInnerTerms() throws IOException {\n          termCollector.reset();\n          spans.collect(termCollector);\n          Arrays.sort(innerTerms, 0, innerTermCount, Comparator.comparing(a -> a.position));\n        }\n      };\n    });\n  }\n\n","sourceOld":"  @Override\n  public Matches matches(LeafReaderContext context, int doc) throws IOException {\n    return Matches.forField(field, () -> {\n      Spans spans = getSpans(context, Postings.OFFSETS);\n      if (spans == null || spans.advance(doc) != doc) {\n        return null;\n      }\n      return new MatchesIterator() {\n\n        int innerTermCount = 0;\n        TermMatch[] innerTerms = new TermMatch[0];\n\n        SpanCollector termCollector = new SpanCollector() {\n          @Override\n          public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {\n            innerTermCount++;\n            if (innerTermCount > innerTerms.length) {\n              TermMatch[] temp = new TermMatch[innerTermCount];\n              System.arraycopy(innerTerms, 0, temp, 0, innerTermCount - 1);\n              innerTerms = temp;\n              innerTerms[innerTermCount - 1] = new TermMatch();\n            }\n            innerTerms[innerTermCount - 1].term = term;\n            innerTerms[innerTermCount - 1].position = position;\n            innerTerms[innerTermCount - 1].startOffset = postings.startOffset();\n            innerTerms[innerTermCount - 1].endOffset = postings.endOffset();\n          }\n\n          @Override\n          public void reset() {\n            innerTermCount = 0;\n          }\n        };\n\n        @Override\n        public boolean next() throws IOException {\n          innerTermCount = 0;\n          return spans.nextStartPosition() != Spans.NO_MORE_POSITIONS;\n        }\n\n        @Override\n        public int startPosition() {\n          return spans.startPosition();\n        }\n\n        @Override\n        public int endPosition() {\n          return spans.endPosition() - 1;\n        }\n\n        @Override\n        public int startOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[0].startOffset;\n        }\n\n        @Override\n        public int endOffset() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return innerTerms[innerTermCount - 1].endOffset;\n        }\n\n        @Override\n        public MatchesIterator getSubMatches() throws IOException {\n          if (innerTermCount == 0) {\n            collectInnerTerms();\n          }\n          return new MatchesIterator() {\n\n            int upto = -1;\n\n            @Override\n            public boolean next() throws IOException {\n              upto++;\n              return upto < innerTermCount;\n            }\n\n            @Override\n            public int startPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int endPosition() {\n              return innerTerms[upto].position;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return innerTerms[upto].startOffset;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return innerTerms[upto].endOffset;\n            }\n\n            @Override\n            public MatchesIterator getSubMatches() throws IOException {\n              return null;\n            }\n\n            @Override\n            public Query getQuery() {\n              return new TermQuery(innerTerms[upto].term);\n            }\n          };\n        }\n\n        @Override\n        public Query getQuery() {\n          return SpanWeight.this.getQuery();\n        }\n\n        void collectInnerTerms() throws IOException {\n          termCollector.reset();\n          spans.collect(termCollector);\n          Arrays.sort(innerTerms, 0, innerTermCount, Comparator.comparing(a -> a.position));\n        }\n      };\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"165c3432cb3c4fcfc8e859af24323bbbd12084af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2375622520a4e480775e3104a2f9a423536755b4":["41ebc07bccf12a902ca6a0077910d18ee38b695f"],"62ba8124694976baa3b03705351de238ec5d4352":["165c3432cb3c4fcfc8e859af24323bbbd12084af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2375622520a4e480775e3104a2f9a423536755b4"],"41ebc07bccf12a902ca6a0077910d18ee38b695f":["62ba8124694976baa3b03705351de238ec5d4352"]},"commit2Childs":{"165c3432cb3c4fcfc8e859af24323bbbd12084af":["62ba8124694976baa3b03705351de238ec5d4352"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["165c3432cb3c4fcfc8e859af24323bbbd12084af"],"2375622520a4e480775e3104a2f9a423536755b4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"62ba8124694976baa3b03705351de238ec5d4352":["41ebc07bccf12a902ca6a0077910d18ee38b695f"],"41ebc07bccf12a902ca6a0077910d18ee38b695f":["2375622520a4e480775e3104a2f9a423536755b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}