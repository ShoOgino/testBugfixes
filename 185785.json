{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","commits":[{"id":"c659c37800c0dfd82fa025b5834f4ab065903d11","date":1361851047,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Node,\n     * com.spatial4j.core.shape.Shape)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          Shape cShape;\n          //if this cell represents a point, use the cell center vs the box\n          // (points never have isLeaf())\n          if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n            cShape = scanCell.getCenter();\n          else\n            cShape = scanCell.getShape();\n\n          visitScanned(scanCell, cShape);\n        }\n      }//term loop\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b","date":1364392557,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Node)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Node,\n     * com.spatial4j.core.shape.Shape)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          Shape cShape;\n          //if this cell represents a point, use the cell center vs the box\n          // (points never have isLeaf())\n          if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n            cShape = scanCell.getCenter();\n          else\n            cShape = scanCell.getShape();\n\n          visitScanned(scanCell, cShape);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Node)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efc64259f3c8f43dfc6841ffad77df3b9446e3a5","date":1395149462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel > scanDetailLevel)\n          continue;\n        if (termLevel == scanDetailLevel || scanCell.isLeaf()) {\n          visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4de14be4bd1b857ba37ca138b61c4661c6d1bed3","date":1396628861,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for ( ;\n          thisTerm != null;\n          thisTerm = termsEnum.next()) {\n        scanCell.readCell(thisTerm);\n        if (!curVNode.cell.isPrefixOf(scanCell))\n          break;\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for (;\n           thisTerm != null && curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n           thisTerm = termsEnum.next()) {\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6c7011603e29f861f395fd2799b2ac2aa6e46da","date":1399596428,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for ( ;\n          thisTerm != null;\n          thisTerm = termsEnum.next()) {\n        scanCell = grid.readCell(thisTerm, scanCell);\n        if (!curVNode.cell.isPrefixOf(scanCell))\n          break;\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for ( ;\n          thisTerm != null;\n          thisTerm = termsEnum.next()) {\n        scanCell.readCell(thisTerm);\n        if (!curVNode.cell.isPrefixOf(scanCell))\n          break;\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      //note: this can be a do-while instead in 6x; 5x has a back-compat with redundant leaves -- LUCENE-4942\n      while (curVNode.cell.isPrefixOf(indexedCell)) {\n        if (indexedCell.getLevel() == scanDetailLevel\n            || (indexedCell.getLevel() < scanDetailLevel && indexedCell.isLeaf())) {\n          visitScanned(indexedCell);\n        }\n        //advance\n        if (!nextTerm()) break;\n      }\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for ( ;\n          thisTerm != null;\n          thisTerm = termsEnum.next()) {\n        scanCell = grid.readCell(thisTerm, scanCell);\n        if (!curVNode.cell.isPrefixOf(scanCell))\n          break;\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      //note: this can be a do-while instead in 6x; 5x has a back-compat with redundant leaves -- LUCENE-4942\n      while (curVNode.cell.isPrefixOf(indexedCell)) {\n        if (indexedCell.getLevel() == scanDetailLevel\n            || (indexedCell.getLevel() < scanDetailLevel && indexedCell.isLeaf())) {\n          visitScanned(indexedCell);\n        }\n        //advance\n        if (!nextTerm()) break;\n      }\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      for ( ;\n          thisTerm != null;\n          thisTerm = termsEnum.next()) {\n        scanCell = grid.readCell(thisTerm, scanCell);\n        if (!curVNode.cell.isPrefixOf(scanCell))\n          break;\n\n        int termLevel = scanCell.getLevel();\n        if (termLevel < scanDetailLevel) {\n          if (scanCell.isLeaf())\n            visitScanned(scanCell);\n        } else if (termLevel == scanDetailLevel) {\n          if (!scanCell.isLeaf())//LUCENE-5529\n            visitScanned(scanCell);\n        }\n      }//term loop\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#scan(int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#scan(int).mjava","sourceNew":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      //note: this can be a do-while instead in 6x; 5x has a back-compat with redundant leaves -- LUCENE-4942\n      while (curVNode.cell.isPrefixOf(indexedCell)) {\n        if (indexedCell.getLevel() == scanDetailLevel\n            || (indexedCell.getLevel() < scanDetailLevel && indexedCell.isLeaf())) {\n          visitScanned(indexedCell);\n        }\n        //advance\n        if (!nextTerm()) break;\n      }\n    }\n\n","sourceOld":"    /**\n     * Scans ({@code termsEnum.next()}) terms until a term is found that does\n     * not start with curVNode's cell. If it finds a leaf cell or a cell at\n     * level {@code scanDetailLevel} then it calls {@link\n     * #visitScanned(org.apache.lucene.spatial.prefix.tree.Cell)}.\n     */\n    protected void scan(int scanDetailLevel) throws IOException {\n      //note: this can be a do-while instead in 6x; 5x has a back-compat with redundant leaves -- LUCENE-4942\n      while (curVNode.cell.isPrefixOf(indexedCell)) {\n        if (indexedCell.getLevel() == scanDetailLevel\n            || (indexedCell.getLevel() < scanDetailLevel && indexedCell.isLeaf())) {\n          visitScanned(indexedCell);\n        }\n        //advance\n        if (!nextTerm()) break;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["8259c159da2de2e8528524fb76b244b46cbded59"],"c6c7011603e29f861f395fd2799b2ac2aa6e46da":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8259c159da2de2e8528524fb76b244b46cbded59":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c6c7011603e29f861f395fd2799b2ac2aa6e46da","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"672b198fc3dce868916c727917cae58c2906763d":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["c6c7011603e29f861f395fd2799b2ac2aa6e46da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"c6c7011603e29f861f395fd2799b2ac2aa6e46da":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"8259c159da2de2e8528524fb76b244b46cbded59":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["c6c7011603e29f861f395fd2799b2ac2aa6e46da"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","672b198fc3dce868916c727917cae58c2906763d"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["8259c159da2de2e8528524fb76b244b46cbded59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c659c37800c0dfd82fa025b5834f4ab065903d11":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}