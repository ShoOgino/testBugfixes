{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","commits":[{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"/dev/null","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String shardZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      // wait until the leader sees us as down before we are willing to accept\n      // updates.\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setCheckLive(false);\n      \n      try {\n        server.request(prepCmd);\n      } catch (Exception e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not talk to the leader\", e);\n      }\n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String shardZkNodeName, boolean waitForNotLive) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      // wait until the leader sees us as down before we are willing to accept\n      // updates.\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(6000);\n      if (waitForNotLive){\n        prepCmd.setCheckLive(false);\n      }\n                          \n      \n      try {\n        server.request(prepCmd);\n      } catch (Exception e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not talk to the leader\", e);\n      }\n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String shardZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      // wait until the leader sees us as down before we are willing to accept\n      // updates.\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setCheckLive(false);\n      \n      try {\n        server.request(prepCmd);\n      } catch (Exception e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not talk to the leader\", e);\n      }\n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9813dd0748537c429b7c0a9b4723ea1ba496c047","date":1330304954,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String,boolean).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      for (int i = 0; i < 3; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String shardZkNodeName, boolean waitForNotLive) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      // wait until the leader sees us as down before we are willing to accept\n      // updates.\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(5000);\n      if (waitForNotLive){\n        prepCmd.setCheckLive(false);\n      }\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      for (int i = 0; i < 3; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31fa604286b18a4e8e580658c67fa46cb82b798f","date":1330379030,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      for (int i = 0; i < 3; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":["9f1bee4bba8988141f8357bda2ccd9405926c4e5","f9a98541130dbb2dd570f39bd89ced65760cad80","bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String shardZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps;\n    try {\n      // go straight to zk, not the cloud state - we must have current info\n      leaderProps = getLeaderProps(collection, shard);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    } catch (KeeperException e) {\n      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      // wait until the leader sees us as down before we are willing to accept\n      // updates.\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setCheckLive(false);\n      \n      try {\n        server.request(prepCmd);\n      } catch (Exception e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not talk to the leader\", e);\n      }\n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      CommonsHttpSolrServer server = null;\n      try {\n        server = new CommonsHttpSolrServer(leaderBaseUrl);\n      } catch (MalformedURLException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      prepCmd.setPauseFor(0);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9a98541130dbb2dd570f39bd89ced65760cad80","date":1355032328,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":["31fa604286b18a4e8e580658c67fa46cb82b798f"],"bugIntro":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(45000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99def2ca215ffcf401629e9f185688b38ce9d759","date":1359914812,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(15000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ad327d64bd0b99868e8be117f1a31f880fec381","date":1360103517,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(15000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(45000);\n      server.setSoTimeout(120000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.DOWN);\n      \n      // let's retry a couple times - perhaps the leader just went down,\n      // or perhaps he is just not quite ready for us yet\n      retries = 6;\n      for (int i = 0; i < retries; i++) {\n        try {\n          server.request(prepCmd);\n          break;\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem making a request to the leader\", e);\n          try {\n            Thread.sleep(2000);\n          } catch (InterruptedException e1) {\n            Thread.currentThread().interrupt();\n          }\n          if (i == retries - 1) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem making a request to the leader\");\n          }\n        }\n      }\n      \n      server.shutdown();\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20c336046cd588d43a52a02963b722c8366319ff","date":1360165061,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n    \n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(),\n        descriptor.getName());\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      HttpSolrServer server = null;\n      server = new HttpSolrServer(leaderBaseUrl);\n      try {\n        server.setConnectionTimeout(15000);\n        server.setSoTimeout(120000);\n        WaitForState prepCmd = new WaitForState();\n        prepCmd.setCoreName(leaderCoreName);\n        prepCmd.setNodeName(getNodeName());\n        prepCmd.setCoreNodeName(coreZkNodeName);\n        prepCmd.setState(ZkStateReader.DOWN);\n        \n        // let's retry a couple times - perhaps the leader just went down,\n        // or perhaps he is just not quite ready for us yet\n        retries = 6;\n        for (int i = 0; i < retries; i++) {\n          if (isClosed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"We have been closed\");\n          }\n          try {\n            server.request(prepCmd);\n            break;\n          } catch (Exception e) {\n            SolrException.log(log,\n                \"There was a problem making a request to the leader\", e);\n            try {\n              Thread.sleep(2000);\n            } catch (InterruptedException e1) {\n              Thread.currentThread().interrupt();\n            }\n            if (i == retries - 1) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"There was a problem making a request to the leader\");\n            }\n          }\n        }\n      } finally {\n        server.shutdown();\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":["9f1bee4bba8988141f8357bda2ccd9405926c4e5","bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07c824e7f6927860d366e4888be45e4db8c9e03b","date":1405193679,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n    \n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d14328dee83c3ec0478e7d711f7af48560ad5ef","date":1412617800,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrClient client = null;\n        client = new HttpSolrClient(leaderBaseUrl);\n        try {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          client.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrServer server = null;\n        server = new HttpSolrServer(leaderBaseUrl);\n        try {\n          server.setConnectionTimeout(15000);\n          server.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              server.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          server.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        HttpSolrClient client = null;\n        client = new HttpSolrClient(leaderBaseUrl);\n        try {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } finally {\n          client.shutdown();\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbcfc050b9f253136eaa5950b57248b2109eac11","date":1427308993,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n    \n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n        \n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n    \n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      \n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \"+myCoreNodeName+\n            \" is in leader-initiated recovery due to: \"+exc, exc);\n      }\n      \n      if (lirState != null) {\n        log.info(\"Replica \"+myCoreNodeName+\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n        \n        log.info(\"Replica \"+myCoreNodeName+\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n            \n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n          \n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \"+leaderProps.getNodeName()+\" hosting leader for \"+\n                          shard+\" in \"+collection+\" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      String lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(ZkStateReader.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f1bee4bba8988141f8357bda2ccd9405926c4e5","date":1449703835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 6;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we must have current info\n        leaderProps = getLeaderProps(collection, shard, 30000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 6;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":["f9a98541130dbb2dd570f39bd89ced65760cad80","14d5815ecbef89580f5c48990bcd433f04f8563a","31fa604286b18a4e8e580658c67fa46cb82b798f"],"bugIntro":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.info(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl).build()) {\n          client.setConnectionTimeout(15000);\n          client.setSoTimeout(120000);\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so,\n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null || !getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so, \n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null) {\n        log.debug(\"Replica \" + myCoreNodeName +\n            \" is already in leader-initiated recovery, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n\n      // detect if this core is in leader-initiated recovery and if so,\n      // then we don't need the leader to wait on seeing the down state\n      Replica.State lirState = null;\n      try {\n        lirState = getLeaderInitiatedRecoveryState(collection, shard, myCoreNodeName);\n      } catch (Exception exc) {\n        log.error(\"Failed to determine if replica \" + myCoreNodeName +\n            \" is in leader-initiated recovery due to: \" + exc, exc);\n      }\n\n      if (lirState != null || !getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica \" + myCoreNodeName +\n            \" NOT in leader-initiated recovery, need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n    \n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bbb0b5c5101d175049b4ced1462f4c266d32fc63","date":1559534216,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) throws SessionExpiredException {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (SessionExpiredException e) {\n        throw e;\n      } catch (Exception e) {\n        log.info(\"Did not find the leader in Zookeeper\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"replica={} is making a best effort attempt to wait for leader={} to see it's DOWN state.\", myCoreNodeName, leaderProps.getCoreUrl());\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(8000) // short timeouts, we may be in a storm and this is best effort and maybe we should be the leader now\n            .withSocketTimeout(30000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // lets give it another chance, but without taking too long\n          retries = 3;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (Exception e) {\n        SolrException.log(log, \"There was a problem finding the leader in zk\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"Replica need to wait for leader to see down state.\");\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(15000)\n            .withSocketTimeout(120000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // let's retry a couple times - perhaps the leader just went down,\n          // or perhaps he is just not quite ready for us yet\n          retries = 2;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":["9813dd0748537c429b7c0a9b4723ea1ba496c047","43d1e498704edd2bba13548a189eed4dfccff11b","14d5815ecbef89580f5c48990bcd433f04f8563a","b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","9f1bee4bba8988141f8357bda2ccd9405926c4e5","31fa604286b18a4e8e580658c67fa46cb82b798f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForLeaderToSeeDownState(CoreDescriptor,String).mjava","sourceNew":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) throws SessionExpiredException {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (SessionExpiredException e) {\n        throw e;\n      } catch (Exception e) {\n        log.info(\"Did not find the leader in Zookeeper\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica {} is already less than leader, so not waiting for leader to see down state.\"\n            , myCoreNodeName);\n      } else {\n\n        if (log.isInfoEnabled()) {\n          log.info(\"replica={} is making a best effort attempt to wait for leader={} to see it's DOWN state.\", myCoreNodeName, leaderProps.getCoreUrl());\n        }\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(8000) // short timeouts, we may be in a storm and this is best effort and maybe we should be the leader now\n            .withSocketTimeout(30000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // lets give it another chance, but without taking too long\n          retries = 3;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","sourceOld":"  private ZkCoreNodeProps waitForLeaderToSeeDownState(\n      CoreDescriptor descriptor, final String coreZkNodeName) throws SessionExpiredException {\n    // try not to wait too long here - if we are waiting too long, we should probably\n    // move along and join the election\n\n    CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n    String collection = cloudDesc.getCollectionName();\n    String shard = cloudDesc.getShardId();\n    ZkCoreNodeProps leaderProps = null;\n\n    int retries = 2;\n    for (int i = 0; i < retries; i++) {\n      try {\n        if (isClosed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"We have been closed\");\n        }\n\n        // go straight to zk, not the cloud state - we want current info\n        leaderProps = getLeaderProps(collection, shard, 5000);\n        break;\n      } catch (SessionExpiredException e) {\n        throw e;\n      } catch (Exception e) {\n        log.info(\"Did not find the leader in Zookeeper\", e);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n        if (i == retries - 1) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"There was a problem finding the leader in zk\");\n        }\n      }\n    }\n\n    String leaderBaseUrl = leaderProps.getBaseUrl();\n    String leaderCoreName = leaderProps.getCoreName();\n\n    String myCoreNodeName = cloudDesc.getCoreNodeName();\n    String myCoreName = descriptor.getName();\n    String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), myCoreName);\n\n    boolean isLeader = leaderProps.getCoreUrl().equals(ourUrl);\n    if (!isLeader && !SKIP_AUTO_RECOVERY) {\n      if (!getShardTerms(collection, shard).canBecomeLeader(myCoreNodeName)) {\n        log.debug(\"Term of replica \" + myCoreNodeName +\n            \" is already less than leader, so not waiting for leader to see down state.\");\n      } else {\n\n        log.info(\"replica={} is making a best effort attempt to wait for leader={} to see it's DOWN state.\", myCoreNodeName, leaderProps.getCoreUrl());\n\n        try (HttpSolrClient client = new Builder(leaderBaseUrl)\n            .withConnectionTimeout(8000) // short timeouts, we may be in a storm and this is best effort and maybe we should be the leader now\n            .withSocketTimeout(30000)\n            .build()) {\n          WaitForState prepCmd = new WaitForState();\n          prepCmd.setCoreName(leaderCoreName);\n          prepCmd.setNodeName(getNodeName());\n          prepCmd.setCoreNodeName(coreZkNodeName);\n          prepCmd.setState(Replica.State.DOWN);\n\n          // lets give it another chance, but without taking too long\n          retries = 3;\n          for (int i = 0; i < retries; i++) {\n            if (isClosed) {\n              throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                  \"We have been closed\");\n            }\n            try {\n              client.request(prepCmd);\n              break;\n            } catch (Exception e) {\n\n              // if the core container is shutdown, don't wait\n              if (cc.isShutDown()) {\n                throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                    \"Core container is shutdown.\");\n              }\n\n              Throwable rootCause = SolrException.getRootCause(e);\n              if (rootCause instanceof IOException) {\n                // if there was a communication error talking to the leader, see if the leader is even alive\n                if (!zkStateReader.getClusterState().liveNodesContain(leaderProps.getNodeName())) {\n                  throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                      \"Node \" + leaderProps.getNodeName() + \" hosting leader for \" +\n                          shard + \" in \" + collection + \" is not live!\");\n                }\n              }\n\n              SolrException.log(log,\n                  \"There was a problem making a request to the leader\", e);\n              try {\n                Thread.sleep(2000);\n              } catch (InterruptedException e1) {\n                Thread.currentThread().interrupt();\n              }\n              if (i == retries - 1) {\n                throw new SolrException(ErrorCode.SERVER_ERROR,\n                    \"There was a problem making a request to the leader\");\n              }\n            }\n          }\n        } catch (IOException e) {\n          SolrException.log(log, \"Error closing HttpSolrClient\", e);\n        }\n      }\n    }\n    return leaderProps;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","a69439d0df009e0bb0038d1e427159f449dd670d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["20c336046cd588d43a52a02963b722c8366319ff","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a80994db3380cd78c6f65b84515e2e931b6b3da","31fa604286b18a4e8e580658c67fa46cb82b798f"],"20c336046cd588d43a52a02963b722c8366319ff":["6ad327d64bd0b99868e8be117f1a31f880fec381"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6ad327d64bd0b99868e8be117f1a31f880fec381"],"a69439d0df009e0bb0038d1e427159f449dd670d":["f9a98541130dbb2dd570f39bd89ced65760cad80"],"ad4957cde742defe6db19689abdc267c5d948066":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"84f20f331d8001864545c7021812d8c6509c7593":["43d1e498704edd2bba13548a189eed4dfccff11b"],"bafca15d8e408346a67f4282ad1143b88023893b":["2d14328dee83c3ec0478e7d711f7af48560ad5ef"],"2d14328dee83c3ec0478e7d711f7af48560ad5ef":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["84f20f331d8001864545c7021812d8c6509c7593"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["fbcfc050b9f253136eaa5950b57248b2109eac11"],"43d1e498704edd2bba13548a189eed4dfccff11b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cc3b13b430571c2e169f98fe38e1e7666f88522d","fbcfc050b9f253136eaa5950b57248b2109eac11"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","43d1e498704edd2bba13548a189eed4dfccff11b"],"f9a98541130dbb2dd570f39bd89ced65760cad80":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","962cd4f5e313777f35da8f521265323e84184929"],"6ad327d64bd0b99868e8be117f1a31f880fec381":["99def2ca215ffcf401629e9f185688b38ce9d759"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"962cd4f5e313777f35da8f521265323e84184929":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"55980207f1977bd1463465de1659b821347e2fa8":["07c824e7f6927860d366e4888be45e4db8c9e03b","2d14328dee83c3ec0478e7d711f7af48560ad5ef"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a6378064655e76cd7b908b1cab4ce425b384b508","f9a98541130dbb2dd570f39bd89ced65760cad80"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["31fa604286b18a4e8e580658c67fa46cb82b798f"],"31fa604286b18a4e8e580658c67fa46cb82b798f":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["20c336046cd588d43a52a02963b722c8366319ff"],"a6378064655e76cd7b908b1cab4ce425b384b508":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"99def2ca215ffcf401629e9f185688b38ce9d759":["a69439d0df009e0bb0038d1e427159f449dd670d"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["9f1bee4bba8988141f8357bda2ccd9405926c4e5","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad4957cde742defe6db19689abdc267c5d948066"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["cc3b13b430571c2e169f98fe38e1e7666f88522d"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"20c336046cd588d43a52a02963b722c8366319ff":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"a69439d0df009e0bb0038d1e427159f449dd670d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","99def2ca215ffcf401629e9f185688b38ce9d759"],"ad4957cde742defe6db19689abdc267c5d948066":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"84f20f331d8001864545c7021812d8c6509c7593":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"2d14328dee83c3ec0478e7d711f7af48560ad5ef":["bafca15d8e408346a67f4282ad1143b88023893b","55980207f1977bd1463465de1659b821347e2fa8"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"43d1e498704edd2bba13548a189eed4dfccff11b":["84f20f331d8001864545c7021812d8c6509c7593","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"f9a98541130dbb2dd570f39bd89ced65760cad80":["a69439d0df009e0bb0038d1e427159f449dd670d","407687e67faf6e1f02a211ca078d8e3eed631027"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["43d1e498704edd2bba13548a189eed4dfccff11b","2ea161f828a3a7a6eb9410a431aecda6d7ab1065","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"6ad327d64bd0b99868e8be117f1a31f880fec381":["20c336046cd588d43a52a02963b722c8366319ff","3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fbcfc050b9f253136eaa5950b57248b2109eac11"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["ad4957cde742defe6db19689abdc267c5d948066"],"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["31fa604286b18a4e8e580658c67fa46cb82b798f"],"55980207f1977bd1463465de1659b821347e2fa8":[],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["a6378064655e76cd7b908b1cab4ce425b384b508"],"31fa604286b18a4e8e580658c67fa46cb82b798f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","14d5815ecbef89580f5c48990bcd433f04f8563a"],"a6378064655e76cd7b908b1cab4ce425b384b508":["f9a98541130dbb2dd570f39bd89ced65760cad80","407687e67faf6e1f02a211ca078d8e3eed631027"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["2d14328dee83c3ec0478e7d711f7af48560ad5ef","55980207f1977bd1463465de1659b821347e2fa8"],"99def2ca215ffcf401629e9f185688b38ce9d759":["6ad327d64bd0b99868e8be117f1a31f880fec381"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3e4d4ec39bf5396230748ca859ff05ab024b6fc5","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","2ea161f828a3a7a6eb9410a431aecda6d7ab1065","55980207f1977bd1463465de1659b821347e2fa8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}