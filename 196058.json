{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","commits":[{"id":"86c34ea6a885f625f2e464756450d45b72653ef3","date":1295256222,"type":1,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#addDocument(Document,Analyzer).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, docState.docID);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      consumer.processDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  public void addDocument(Document doc, Analyzer analyzer) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      consumer.processDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        }\n      }\n    }\n\n    success = false;\n    try {\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, docState.docID);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      consumer.processDocument(fieldInfos);\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, docState.docID);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      consumer.processDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","date":1298618128,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, numDocsInRAM);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n      consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, docState.docID);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      consumer.processDocument(fieldInfos);\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2ed1b9b7b46829fe3199afe9a8bc203f201b175","date":1301491807,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, numDocsInRAM);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, numDocsInRAM);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n      consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (delTerm != null) {\n      pendingDeletes.addTerm(delTerm, numDocsInRAM);\n    }\n\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n\n    success = false;\n    try {\n      numDocsInRAM++;\n      consumer.finishDocument();\n\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fe2fc74577855eadfb5eae3153c2fffdaaf791","date":1305237079,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00afe74a80796ed1f30a9509b150ff104746a1f","date":1312881735,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n      if (INFO_VERBOSE) {\n        message(Thread.currentThread().getName() + \" init seg=\" + segment + \" delQueue=\" + deleteQueue);  \n      }\n      \n    }\n    if (INFO_VERBOSE) {\n      message(Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segment);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n    }\n\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Iterable<? extends IndexableField> doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n      if (INFO_VERBOSE) {\n        message(Thread.currentThread().getName() + \" init seg=\" + segment + \" delQueue=\" + deleteQueue);  \n      }\n      \n    }\n    if (INFO_VERBOSE) {\n      message(Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segment);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Document doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segment == null) {\n      // this call is synchronized on IndexWriter.segmentInfos\n      segment = writer.newSegmentName();\n      assert numDocsInRAM == 0;\n      if (INFO_VERBOSE) {\n        message(Thread.currentThread().getName() + \" init seg=\" + segment + \" delQueue=\" + deleteQueue);  \n      }\n      \n    }\n    if (INFO_VERBOSE) {\n      message(Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segment);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n          fieldInfos.revertUncommitted();\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"86c34ea6a885f625f2e464756450d45b72653ef3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["86c34ea6a885f625f2e464756450d45b72653ef3","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1509f151d7692d84fae414b2b799ac06ba60fcb4"]},"commit2Childs":{"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["c00afe74a80796ed1f30a9509b150ff104746a1f","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["135621f3a0670a9394eb563224a3b76cc4dddc0f","b3e06be49006ecac364d39d12b9c9f74882f9b9f","a3776dccca01c11e7046323cfad46a3b4a471233","86c34ea6a885f625f2e464756450d45b72653ef3","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"86c34ea6a885f625f2e464756450d45b72653ef3":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}