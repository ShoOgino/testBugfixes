{"path":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c01638f4dd94981c1d3d52c4f7991246a5a24aba","date":1327876712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":["b11c8a388c6bc44e8a0e12c4f0597bf0134b344a","9b87acd61509ed222a7ae58c584568eca5a6243e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getVersion());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ae05237914af33835981f3271dd3c0d753a43be","date":1335201162,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c","date":1399457549,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a2d81cf6955f09cda03ed448bb9bb397d4b9742","date":1411570057,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPoint(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6","date":1423132645,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {            \n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }            \n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5c99ad021f3da085fcb66220598a8f91dc5e453","date":1462242046,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["7c0c76f8855bd391c39890131d8dbd56c3fdcef0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c7a21395bae9e2f61aeb639f47aaca771c426ed","date":1462255690,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, ReplicationHandler.this);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c0c76f8855bd391c39890131d8dbd56c3fdcef0","date":1512185429,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":["c5c99ad021f3da085fcb66220598a8f91dc5e453"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"670400747be2d99524159f3806d449ecfb0c2389","date":1512293281,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(currentCommitPoint, numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            log.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            LOG.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#getEventListener(boolean,boolean).mjava","sourceNew":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(@SuppressWarnings({\"rawtypes\"})NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            log.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Register a listener for postcommit/optimize\n   *\n   * @param snapshoot do a snapshoot\n   * @param getCommit get a commitpoint also\n   *\n   * @return an instance of the eventlistener\n   */\n  private SolrEventListener getEventListener(final boolean snapshoot, final boolean getCommit) {\n    return new SolrEventListener() {\n      @Override\n      public void init(NamedList args) {/*no op*/ }\n\n      /**\n       * This refreshes the latest replicateable index commit and optionally can create Snapshots as well\n       */\n      @Override\n      public void postCommit() {\n        IndexCommit currentCommitPoint = core.getDeletionPolicy().getLatestCommit();\n\n        if (getCommit) {\n          // IndexCommit oldCommitPoint = indexCommitPoint;\n          indexCommitPoint = currentCommitPoint;\n\n          // We don't need to save commit points for replication, the SolrDeletionPolicy\n          // always saves the last commit point (and the last optimized commit point, if needed)\n          /***\n          if (indexCommitPoint != null) {\n            core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n          }\n          if(oldCommitPoint != null){\n            core.getDeletionPolicy().releaseCommitPointAndExtendReserve(oldCommitPoint.getGeneration());\n          }\n          ***/\n        }\n        if (snapshoot) {\n          try {\n            int numberToKeep = numberBackupsToKeep;\n            if (numberToKeep < 1) {\n              numberToKeep = Integer.MAX_VALUE;\n            }\n            SnapShooter snapShooter = new SnapShooter(core, null, null);\n            snapShooter.validateCreateSnapshot();\n            snapShooter.createSnapAsync(numberToKeep, (nl) -> snapShootDetails = nl);\n          } catch (Exception e) {\n            log.error(\"Exception while snapshooting\", e);\n          }\n        }\n      }\n\n      @Override\n      public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) { /*no op*/}\n\n      @Override\n      public void postSoftCommit() {\n\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5c99ad021f3da085fcb66220598a8f91dc5e453":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["7ae05237914af33835981f3271dd3c0d753a43be","7530de27b87b961b51f01bd1299b7004d46e8823"],"7ae05237914af33835981f3271dd3c0d753a43be":["c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c":["7530de27b87b961b51f01bd1299b7004d46e8823"],"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6":["5a2d81cf6955f09cda03ed448bb9bb397d4b9742"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["86290366cefc1b9d4eced13b430858c4a4c0421d","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["c26f00b574427b55127e869b935845554afde1fa","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["86290366cefc1b9d4eced13b430858c4a4c0421d","c5c99ad021f3da085fcb66220598a8f91dc5e453"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"5a2d81cf6955f09cda03ed448bb9bb397d4b9742":["a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c0c76f8855bd391c39890131d8dbd56c3fdcef0":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"670400747be2d99524159f3806d449ecfb0c2389":["1c7a21395bae9e2f61aeb639f47aaca771c426ed","7c0c76f8855bd391c39890131d8dbd56c3fdcef0"],"5b6fdfce35d0adb18836cf8711abe487a934df33":["c26f00b574427b55127e869b935845554afde1fa","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["7ae05237914af33835981f3271dd3c0d753a43be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["670400747be2d99524159f3806d449ecfb0c2389"]},"commit2Childs":{"c5c99ad021f3da085fcb66220598a8f91dc5e453":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"7ae05237914af33835981f3271dd3c0d753a43be":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["7ae05237914af33835981f3271dd3c0d753a43be","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"c26f00b574427b55127e869b935845554afde1fa":["c01638f4dd94981c1d3d52c4f7991246a5a24aba","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c":["5a2d81cf6955f09cda03ed448bb9bb397d4b9742"],"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"55b50463286869f584cf849d1587a0fcd54d1dfa":[],"86290366cefc1b9d4eced13b430858c4a4c0421d":["c5c99ad021f3da085fcb66220598a8f91dc5e453","55b50463286869f584cf849d1587a0fcd54d1dfa","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["55b50463286869f584cf849d1587a0fcd54d1dfa","7c0c76f8855bd391c39890131d8dbd56c3fdcef0","670400747be2d99524159f3806d449ecfb0c2389"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"5a2d81cf6955f09cda03ed448bb9bb397d4b9742":["5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c0c76f8855bd391c39890131d8dbd56c3fdcef0":["670400747be2d99524159f3806d449ecfb0c2389"],"670400747be2d99524159f3806d449ecfb0c2389":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","55b50463286869f584cf849d1587a0fcd54d1dfa","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}