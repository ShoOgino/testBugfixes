{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","commits":[{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader()) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader()) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938e4fd7b1e4b34da1650edba7471764bbfaefde","date":1344033248,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader()) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader()) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader()) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.getStr(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.get(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.get(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf","date":1351542322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n          \n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log, \"Collection creation of \" + message.getStr(\"name\") + \" failed\");\n          }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0","date":1355709729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        \n        \n        workQueue.poll();\n       \n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        \n        \n        workQueue.poll();\n       \n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        workQueue.remove();\n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c986b1ea9768aff3c903f05a2c85b7b672b5c225","date":1359126891,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       while (amILeader() && !isClosed) {\n         try {\n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Throwable e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        \n        \n        workQueue.poll();\n       \n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       while (amILeader() && !isClosed) {\n         try {\n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Throwable e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection messages\");\n    while (amILeader() && !isClosed) {\n      try {\n        byte[] head = workQueue.peek(true);\n        \n        //if (head != null) {    // should not happen since we block above\n          final ZkNodeProps message = ZkNodeProps.load(head);\n          final String operation = message.getStr(QUEUE_OPERATION);\n        try {\n          boolean success = processMessage(message, operation);\n          if (!success) {\n            // TODO: what to do on failure / partial failure\n            // if we fail, do we clean up then ?\n            SolrException.log(log,\n                \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                    + \" failed\");\n          }\n        } catch(Throwable t) {\n          SolrException.log(log,\n              \"Collection \" + operation + \" of \" + message.getStr(\"name\")\n                  + \" failed\", t);\n        }\n        //}\n        \n        \n        workQueue.poll();\n       \n      } catch (KeeperException e) {\n        if (e.code() == KeeperException.Code.SESSIONEXPIRED\n            || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n          log.warn(\"Overseer cannot talk to ZK\");\n          return;\n        }\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"270612d8e1a51cded91704d7af12f8979de0f584","date":1381502089,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n       while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Throwable e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       while (amILeader() && !isClosed) {\n         try {\n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Throwable e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n       while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n       while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Throwable e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":["c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44de42d869f7d8e5235d43c4ad9a99f520363a2f","date":1389871557,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n       while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n           head.setBytes(SolrResponse.serializable(response));\n           workQueue.remove(head);\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f45f67a018421da088ea39274f23ad5d339b97d","date":1395559348,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           SolrResponse response = processMessage(message, operation);\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           if(isClosed) break;\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           if(isClosed) break;\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           if(isClosed) break;\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":["d75364131df0d7cbc7779fdc05269dbdb03f80a8","6afb0ba86024b96e8b34cfc2e15562239dc36360","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","ff49eed06b46bfc31ddfdd5bbede7cb5766f1ed6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n       log.info(\"Process current queue of collection creations\");\n       LeaderStatus isLeader = amILeader();\n       while (isLeader == LeaderStatus.DONT_KNOW) {\n         log.debug(\"am_i_leader unclear {}\", isLeader);\n         isLeader = amILeader();  // not a no, not a yes, try ask again\n       }\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n\n    }\n    while (!this.isClosed) {\n         try {\n           isLeader = amILeader();\n           if (LeaderStatus.NO == isLeader) {\n             break;\n           }\n           else if (LeaderStatus.YES != isLeader) {\n             log.debug(\"am_i_leader unclear {}\", isLeader);                  \n             continue; // not a no, not a yes, try asking again\n           }\n           \n           QueueEvent head = workQueue.peek(true);\n           if(isClosed) break;\n           final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n\n           final String asyncId = (message.containsKey(ASYNC) && message.get(ASYNC) != null) ? (String) message.get(ASYNC) : null;\n\n           try {\n             if(message.containsKey(ASYNC) && message.get(ASYNC) != null && !runningMap.contains(message.getStr(ASYNC)))\n              runningMap.put(asyncId, null);\n           } catch (KeeperException.NodeExistsException e) {\n             // Just catch and do nothing. The runningMap.contains(..) check ensures that this is the only\n             // entry point into the runningMap.\n             // NOTE: Make sure to handle it as soon as OCP gets distributed/multi-threaded.\n           }\n\n           log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n           final String operation = message.getStr(QUEUE_OPERATION);\n           final TimerContext timerContext = stats.time(\"collection_\" + operation); // even if operation is async, it is sync!\n           SolrResponse response = null;\n           try  {\n             response = processMessage(message, operation);\n           } finally {\n             timerContext.stop();\n           }\n\n           head.setBytes(SolrResponse.serializable(response));\n           if (!operation.equals(REQUESTSTATUS) && asyncId != null) {\n             if(response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null) {\n               failureMap.put(asyncId, null);\n             } else {\n               completedMap.put(asyncId, null);\n             }\n           }\n           if(asyncId != null)\n            runningMap.remove(asyncId);\n\n           workQueue.remove(head);\n\n           if (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)  {\n             stats.error(\"collection_\" + operation);\n             stats.storeFailureDetails(\"collection_\" + operation, message, response);\n           } else {\n             stats.success(\"collection_\" + operation);\n           }\n\n          log.info(\"Overseer Collection Processor: Message id:\" + head.getId() + \" complete, response:\"+ response.getResponse().toString());\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n             log.warn(\"Overseer cannot talk to ZK\");\n             return;\n           }\n           SolrException.log(log, \"\", e);\n           throw new ZooKeeperException(\n               SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           return;\n         } catch (Exception e) {\n           SolrException.log(log, \"\", e);\n         }\n       }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff2ea054f72177967223fb032d708ad8020e80a","date":1401922976,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cec25d43333cb074264978e327ddb9bc3a2418c8","date":1408670418,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED\n              || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d75364131df0d7cbc7779fdc05269dbdb03f80a8","date":1408712725,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n          throw new ZooKeeperException(\n              SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":["6f26f74e4969851a019d28f10315cb1c77786f22"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ExecutorUtil.MDCAwareThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ff49eed06b46bfc31ddfdd5bbede7cb5766f1ed6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31","date":1435517625,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ExecutorUtil.MDCAwareThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            final String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ExecutorUtil.MDCAwareThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerProcessor#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#run().mjava","sourceNew":"  @Override\n  public void run() {\n    log.info(\"Process current queue of overseer operations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizer.prioritizeOverseerNodes(myId);\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ExecutorUtil.MDCAwareThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            OverseerMessageHandler messageHandler = selector.selectOverseerMessageHandler(message);\n            String taskKey = messageHandler.getTaskKey(message);\n            final String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(messageHandler, message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(messageHandler, head, taskKey, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(messageHandler.getName() + \": Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(messageHandler, message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    log.info(\"Process current queue of collection creations\");\n    LeaderStatus isLeader = amILeader();\n    while (isLeader == LeaderStatus.DONT_KNOW) {\n      log.debug(\"am_i_leader unclear {}\", isLeader);\n      isLeader = amILeader();  // not a no, not a yes, try ask again\n    }\n\n    String oldestItemInWorkQueue = null;\n    // hasLeftOverItems - used for avoiding re-execution of async tasks that were processed by a previous Overseer.\n    // This variable is set in case there's any task found on the workQueue when the OCP starts up and\n    // the id for the queue tail is used as a marker to check for the task in completed/failed map in zk.\n    // Beyond the marker, all tasks can safely be assumed to have never been executed.\n    boolean hasLeftOverItems = true;\n\n    try {\n      oldestItemInWorkQueue = workQueue.getTailId();\n    } catch (KeeperException e) {\n      // We don't need to handle this. This is just a fail-safe which comes in handy in skipping already processed\n      // async calls.\n      SolrException.log(log, \"\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n\n    if (oldestItemInWorkQueue == null)\n      hasLeftOverItems = false;\n    else\n      log.debug(\"Found already existing elements in the work-queue. Last element: {}\", oldestItemInWorkQueue);\n\n    try {\n      prioritizeOverseerNodes();\n    } catch (Exception e) {\n      log.error(\"Unable to prioritize overseer \", e);\n    }\n\n    // TODO: Make maxThreads configurable.\n\n    this.tpe = new ExecutorUtil.MDCAwareThreadPoolExecutor(5, 100, 0L, TimeUnit.MILLISECONDS,\n        new SynchronousQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"OverseerThreadFactory\"));\n    try {\n      while (!this.isClosed) {\n        try {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          } else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try asking again\n          }\n\n          log.debug(\"Cleaning up work-queue. #Running tasks: {}\", runningTasks.size());\n          cleanUpWorkQueue();\n\n          printTrackingMaps();\n\n          boolean waited = false;\n\n          while (runningTasks.size() > maxParallelThreads) {\n            synchronized (waitLock) {\n              waitLock.wait(100);//wait for 100 ms or till a task is complete\n            }\n            waited = true;\n          }\n\n          if (waited)\n            cleanUpWorkQueue();\n\n          List<QueueEvent> heads = workQueue.peekTopN(maxParallelThreads, runningZKTasks, 2000L);\n\n          if (heads == null)\n            continue;\n\n          log.debug(\"Got {} tasks from work-queue : [{}]\", heads.size(), heads.toString());\n\n          if (isClosed) break;\n\n          for (QueueEvent head : heads) {\n            final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n            String collectionName = message.containsKey(COLLECTION_PROP) ?\n                message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n            final String asyncId = message.getStr(ASYNC);\n            if (hasLeftOverItems) {\n              if (head.getId().equals(oldestItemInWorkQueue))\n                hasLeftOverItems = false;\n              if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {\n                log.debug(\"Found already processed task in workQueue, cleaning up. AsyncId [{}]\",asyncId );\n                workQueue.remove(head);\n                continue;\n              }\n            }\n\n            if (!checkExclusivity(message, head.getId())) {\n              log.debug(\"Exclusivity check failed for [{}]\", message.toString());\n              continue;\n            }\n\n            try {\n              markTaskAsRunning(head, collectionName, asyncId, message);\n              log.debug(\"Marked task [{}] as running\", head.getId());\n            } catch (KeeperException.NodeExistsException e) {\n              // This should never happen\n              log.error(\"Tried to pick up task [{}] when it was already running!\", head.getId());\n            } catch (InterruptedException e) {\n              log.error(\"Thread interrupted while trying to pick task for execution.\", head.getId());\n              Thread.currentThread().interrupt();\n            }\n\n            log.info(\"Overseer Collection Processor: Get the message id:\" + head.getId() + \" message:\" + message.toString());\n            String operation = message.getStr(Overseer.QUEUE_OPERATION);\n            Runner runner = new Runner(message,\n                operation, head);\n            tpe.execute(runner);\n          }\n\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\"Overseer cannot talk to ZK\");\n            return;\n          }\n          SolrException.log(log, \"\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n      }\n    } finally {\n      this.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"270612d8e1a51cded91704d7af12f8979de0f584":["c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf","b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31":["cb5af3afeddbb803fb785098176e6e177c34261b"],"cec25d43333cb074264978e327ddb9bc3a2418c8":["8ff2ea054f72177967223fb032d708ad8020e80a"],"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf":["fa64435b5902ce266c23755a4a00691a3285dab8"],"d75364131df0d7cbc7779fdc05269dbdb03f80a8":["cec25d43333cb074264978e327ddb9bc3a2418c8"],"9f45f67a018421da088ea39274f23ad5d339b97d":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"b7605579001505896d48b07160075a5c8b8e128e":["5b15576cafd8b5d06857055c28f26912321937e3","6f26f74e4969851a019d28f10315cb1c77786f22"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["f222f4f2bda21ffd6b39b3362b2412e98e4d5e31"],"5b15576cafd8b5d06857055c28f26912321937e3":["9f45f67a018421da088ea39274f23ad5d339b97d"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d75364131df0d7cbc7779fdc05269dbdb03f80a8"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["d75364131df0d7cbc7779fdc05269dbdb03f80a8","1390137e395d2f07f9ba5b8c43d293befe84d563"],"6f26f74e4969851a019d28f10315cb1c77786f22":["5b15576cafd8b5d06857055c28f26912321937e3"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["270612d8e1a51cded91704d7af12f8979de0f584"],"5eb2511ababf862ea11e10761c70ee560cd84510":["9f45f67a018421da088ea39274f23ad5d339b97d","5b15576cafd8b5d06857055c28f26912321937e3"],"8ff2ea054f72177967223fb032d708ad8020e80a":["6f26f74e4969851a019d28f10315cb1c77786f22"],"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fa64435b5902ce266c23755a4a00691a3285dab8":["938e4fd7b1e4b34da1650edba7471764bbfaefde"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","33d0ed80b7b47e34ad3ff033a77544563aba3085"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["33d0ed80b7b47e34ad3ff033a77544563aba3085","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"cb5af3afeddbb803fb785098176e6e177c34261b":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"]},"commit2Childs":{"270612d8e1a51cded91704d7af12f8979de0f584":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["dd45d4a2ee01a1932d33eec42f5272c2402da679"],"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"cec25d43333cb074264978e327ddb9bc3a2418c8":["d75364131df0d7cbc7779fdc05269dbdb03f80a8"],"2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"d75364131df0d7cbc7779fdc05269dbdb03f80a8":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"9f45f67a018421da088ea39274f23ad5d339b97d":["5b15576cafd8b5d06857055c28f26912321937e3","5eb2511ababf862ea11e10761c70ee560cd84510"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["9f45f67a018421da088ea39274f23ad5d339b97d"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"b7605579001505896d48b07160075a5c8b8e128e":[],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5b15576cafd8b5d06857055c28f26912321937e3":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22","5eb2511ababf862ea11e10761c70ee560cd84510"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["270612d8e1a51cded91704d7af12f8979de0f584","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","cb5af3afeddbb803fb785098176e6e177c34261b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"6f26f74e4969851a019d28f10315cb1c77786f22":["b7605579001505896d48b07160075a5c8b8e128e","8ff2ea054f72177967223fb032d708ad8020e80a"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"8ff2ea054f72177967223fb032d708ad8020e80a":["cec25d43333cb074264978e327ddb9bc3a2418c8"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["938e4fd7b1e4b34da1650edba7471764bbfaefde","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fa64435b5902ce266c23755a4a00691a3285dab8":["2c4436c3a2f4c25c2d48c1b3d1a5fb0ec6b410bf"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"cb5af3afeddbb803fb785098176e6e177c34261b":["f222f4f2bda21ffd6b39b3362b2412e98e4d5e31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","b7605579001505896d48b07160075a5c8b8e128e","d2638f781be724518ff6c2263d14a48cf6e68017","5eb2511ababf862ea11e10761c70ee560cd84510","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}