{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"/dev/null","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2017f5f076f786bc5036834c12b67cf1fbcb8241"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2017f5f076f786bc5036834c12b67cf1fbcb8241","date":1460627715,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1); // marker for null token\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521","date":1461254038,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cb5c25025721b90f1f80bf3df99ae2b9a945e6c","date":1576521071,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  @SuppressForbidden(reason = \"XXX: security hole\")\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b945b8f5bba0303382bc69d60c0c287714f23328","date":1576586294,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/http/ReplicationService#perform(HttpServletRequest,HttpServletResponse).mjava","sourceNew":"  /** Executes the replication task. */\n  @SuppressForbidden(reason = \"XXX: security hole\")\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","sourceOld":"  /** Executes the replication task. */\n  public void perform(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    String[] pathElements = getPathElements(req);\n    \n    if (pathElements.length != 2) {\n      throw new ServletException(\"invalid path, must contain shard ID and action, e.g. */s1/update\");\n    }\n    \n    final ReplicationAction action;\n    try {\n      action = ReplicationAction.valueOf(pathElements[ACTION_IDX].toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new ServletException(\"Unsupported action provided: \" + pathElements[ACTION_IDX]);\n    }\n    \n    final Replicator replicator = replicators.get(pathElements[SHARD_IDX]);\n    if (replicator == null) {\n      throw new ServletException(\"unrecognized shard ID \" + pathElements[SHARD_IDX]);\n    }\n    \n    // SOLR-8933 Don't close this stream.\n    ServletOutputStream resOut = resp.getOutputStream();\n    try {\n      switch (action) {\n        case OBTAIN:\n          final String sessionID = extractRequestParam(req, REPLICATE_SESSION_ID_PARAM);\n          final String fileName = extractRequestParam(req, REPLICATE_FILENAME_PARAM);\n          final String source = extractRequestParam(req, REPLICATE_SOURCE_PARAM);\n          InputStream in = replicator.obtainFile(sessionID, source, fileName);\n          try {\n            copy(in, resOut);\n          } finally {\n            in.close();\n          }\n          break;\n        case RELEASE:\n          replicator.release(extractRequestParam(req, REPLICATE_SESSION_ID_PARAM));\n          break;\n        case UPDATE:\n          String currVersion = req.getParameter(REPLICATE_VERSION_PARAM);\n          SessionToken token = replicator.checkForUpdate(currVersion);\n          if (token == null) {\n            resOut.write(0); // marker for null token\n          } else {\n            resOut.write(1);\n            token.serialize(new DataOutputStream(resOut));\n          }\n          break;\n      }\n    } catch (Exception e) {\n      resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); // propagate the failure\n      try {\n        /*\n         * Note: it is assumed that \"identified exceptions\" are thrown before\n         * anything was written to the stream.\n         */\n        ObjectOutputStream oos = new ObjectOutputStream(resOut);\n        oos.writeObject(e);\n        oos.flush();\n      } catch (Exception e2) {\n        throw new IOException(\"Could not serialize\", e2);\n      }\n    } finally {\n      resp.flushBuffer();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["2017f5f076f786bc5036834c12b67cf1fbcb8241","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"2017f5f076f786bc5036834c12b67cf1fbcb8241":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["2017f5f076f786bc5036834c12b67cf1fbcb8241"],"4cb5c25025721b90f1f80bf3df99ae2b9a945e6c":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"b945b8f5bba0303382bc69d60c0c287714f23328":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","4cb5c25025721b90f1f80bf3df99ae2b9a945e6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4cb5c25025721b90f1f80bf3df99ae2b9a945e6c"]},"commit2Childs":{"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["4cb5c25025721b90f1f80bf3df99ae2b9a945e6c","b945b8f5bba0303382bc69d60c0c287714f23328"],"2017f5f076f786bc5036834c12b67cf1fbcb8241":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["2017f5f076f786bc5036834c12b67cf1fbcb8241"],"4cb5c25025721b90f1f80bf3df99ae2b9a945e6c":["b945b8f5bba0303382bc69d60c0c287714f23328","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b945b8f5bba0303382bc69d60c0c287714f23328":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","b945b8f5bba0303382bc69d60c0c287714f23328","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}