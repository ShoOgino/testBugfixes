{"path":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d17ffdbce80d3dce181982a9cd16f4f90bc8619a","date":1357583592,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<Query>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<Float>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<String>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e","date":1411674127,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MLTHandler Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0c49644277f679076861896c254bd95b97909b74"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","date":1411744836,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MLTHandler Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    // Set field flags\n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n    String q = params.get( CommonParams.Q );\n    Query query = null;\n    SortSpec sortSpec = null;\n    List<Query> filters = null;\n\n    try {\n      if (q != null) {\n        QParser parser = QParser.getParser(q, defType, req);\n        query = parser.getQuery();\n        sortSpec = parser.getSort(true);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n          filters = new ArrayList<>();\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    MoreLikeThisHelper mlt = new MoreLikeThisHelper( params, searcher );\n\n    // Hold on to the interesting terms if relevant\n    TermStyle termStyle = TermStyle.get( params.get( MoreLikeThisParams.INTERESTING_TERMS ) );\n    List<InterestingTerm> interesting = (termStyle == TermStyle.NONE )\n      ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );\n    \n    DocListAndSet mltDocs = null;\n\n    // Parse Required Params\n    // This will either have a single Reader or valid query\n    Reader reader = null;\n    try {\n      if (q == null || q.trim().length() < 1) {\n        Iterable<ContentStream> streams = req.getContentStreams();\n        if (streams != null) {\n          Iterator<ContentStream> iter = streams.iterator();\n          if (iter.hasNext()) {\n            reader = iter.next().getReader();\n          }\n          if (iter.hasNext()) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis does not support multiple ContentStreams\");\n          }\n        }\n      }\n\n      int start = params.getInt(CommonParams.START, 0);\n      int rows = params.getInt(CommonParams.ROWS, 10);\n\n      // Find documents MoreLikeThis - either with a reader or a query\n      // --------------------------------------------------------------------------------\n      if (reader != null) {\n        mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n            interesting, flags);\n      } else if (q != null) {\n        // Matching options\n        boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n            true);\n        int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n        // Find the base match\n        DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n            flags); // only get the first one...\n        if (includeMatch) {\n          rsp.add(\"match\", match);\n        }\n\n        // This is an iterator, but we only handle the first match\n        DocIterator iterator = match.iterator();\n        if (iterator.hasNext()) {\n          // do a MoreLikeThis query for each document in results\n          int id = iterator.nextDoc();\n          mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n              flags);\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n      }\n\n    } finally {\n      if (reader != null) {\n        reader.close();\n      }\n    }\n    \n    if( mltDocs == null ) {\n      mltDocs = new DocListAndSet(); // avoid NPE\n    }\n    rsp.add( \"response\", mltDocs.docList );\n    \n  \n    if( interesting != null ) {\n      if( termStyle == TermStyle.DETAILS ) {\n        NamedList<Float> it = new NamedList<>();\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.toString(), t.boost );\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n      else {\n        List<String> it = new ArrayList<>( interesting.size() );\n        for( InterestingTerm t : interesting ) {\n          it.add( t.term.text());\n        }\n        rsp.add( \"interestingTerms\", it );\n      }\n    }\n    \n    // maybe facet the results\n    if (params.getBool(FacetParams.FACET,false)) {\n      if( mltDocs.docSet == null ) {\n        rsp.add( \"facet_counts\", null );\n      }\n      else {\n        SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params );\n        rsp.add( \"facet_counts\", f.getFacetCounts() );\n      }\n    }\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n    boolean dbgQuery = false, dbgResults = false;\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n      if (dbgParams != null) {\n        for (int i = 0; i < dbgParams.length; i++) {\n          if (dbgParams[i].equals(CommonParams.QUERY)){\n            dbgQuery = true;\n          } else if (dbgParams[i].equals(CommonParams.RESULTS)){\n            dbgResults = true;\n          }\n        }\n      }\n    } else {\n      dbgQuery = true;\n      dbgResults = true;\n    }\n    // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n    if (dbg == true) {\n      try {\n        NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n        if (null != dbgInfo) {\n          if (null != filters) {\n            dbgInfo.add(\"filter_queries\",req.getParams().getParams(CommonParams.FQ));\n            List<String> fqs = new ArrayList<>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbgInfo.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbgInfo);\n        }\n      } catch (Exception e) {\n        SolrException.log(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f001da93ec624cbfbf3655c529836b5b1ec1aa46","date":1412885266,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MLTHandler Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"MLTHandler Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", f.getFacetCounts());\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(SolrCore.log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecd75942508378ccc92c3a26f71db6cba9f25784","date":1450708761,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.add(\"response\", mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1","date":1451604685,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<InterestingTerm>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (int i = 0; i < dbgParams.length; i++) {\n              if (dbgParams[i].equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParams[i].equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79acb0e466faaab809d0bcd9d44bc446449d325e","date":1453293805,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, 0);\n          int rows = params.getInt(CommonParams.ROWS, 10);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","date":1470751445,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bca25eefa1f2205e2b0ef713701dc3a0fecd702","date":1470810578,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07cbaf0735458446c429df54ba816915e8a1f638","date":1476738812,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSort(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, null, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // Copied from StandardRequestHandler... perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c49644277f679076861896c254bd95b97909b74","date":1527241182,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"MoreLikeThis does not support multiple ContentStreams\");\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"MoreLikeThis requires either a query (?q=) or text to find similar documents.\");\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":["eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; {}\", req.getParamString(), ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            @SuppressWarnings({\"unchecked\"})\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; {}\", req.getParamString(), ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; {}\", req.getParamString(), ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            @SuppressWarnings({\"unchecked\"})\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; \", req.getParamString(), ex);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            @SuppressWarnings({\"unchecked\"})\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; {}\", req.getParamString(), ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6d19d09273bf442102fec52cfac9af9294bc89","date":1597466467,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    SolrQueryTimeoutImpl.set(req);\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            @SuppressWarnings({\"unchecked\"})\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; \", req.getParamString(), ex);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception \n  {\n    SolrParams params = req.getParams();\n\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n    if(timeAllowed > 0) {\n      SolrQueryTimeoutImpl.set(timeAllowed);\n    }\n      try {\n\n        // Set field flags\n        ReturnFields returnFields = new SolrReturnFields(req);\n        rsp.setReturnFields(returnFields);\n        int flags = 0;\n        if (returnFields.wantsScore()) {\n          flags |= SolrIndexSearcher.GET_SCORES;\n        }\n\n        String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n        String q = params.get(CommonParams.Q);\n        Query query = null;\n        SortSpec sortSpec = null;\n        List<Query> filters = null;\n\n        try {\n          if (q != null) {\n            QParser parser = QParser.getParser(q, defType, req);\n            query = parser.getQuery();\n            sortSpec = parser.getSortSpec(true);\n          }\n\n          String[] fqs = req.getParams().getParams(CommonParams.FQ);\n          if (fqs != null && fqs.length != 0) {\n            filters = new ArrayList<>();\n            for (String fq : fqs) {\n              if (fq != null && fq.trim().length() != 0) {\n                QParser fqp = QParser.getParser(fq, req);\n                filters.add(fqp.getQuery());\n              }\n            }\n          }\n        } catch (SyntaxError e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n        }\n\n        SolrIndexSearcher searcher = req.getSearcher();\n\n        MoreLikeThisHelper mlt = new MoreLikeThisHelper(params, searcher);\n\n        // Hold on to the interesting terms if relevant\n        TermStyle termStyle = TermStyle.get(params.get(MoreLikeThisParams.INTERESTING_TERMS));\n        List<InterestingTerm> interesting = (termStyle == TermStyle.NONE)\n            ? null : new ArrayList<>(mlt.mlt.getMaxQueryTerms());\n\n        DocListAndSet mltDocs = null;\n\n        // Parse Required Params\n        // This will either have a single Reader or valid query\n        Reader reader = null;\n        try {\n          if (q == null || q.trim().length() < 1) {\n            Iterable<ContentStream> streams = req.getContentStreams();\n            if (streams != null) {\n              Iterator<ContentStream> iter = streams.iterator();\n              if (iter.hasNext()) {\n                reader = iter.next().getReader();\n              }\n              if (iter.hasNext()) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    ERR_MSG_SINGLE_STREAM_ONLY);\n              }\n            }\n          }\n\n          int start = params.getInt(CommonParams.START, CommonParams.START_DEFAULT);\n          int rows = params.getInt(CommonParams.ROWS, CommonParams.ROWS_DEFAULT);\n\n          // Find documents MoreLikeThis - either with a reader or a query\n          // --------------------------------------------------------------------------------\n          if (reader != null) {\n            mltDocs = mlt.getMoreLikeThis(reader, start, rows, filters,\n                interesting, flags);\n          } else if (q != null) {\n            // Matching options\n            boolean includeMatch = params.getBool(MoreLikeThisParams.MATCH_INCLUDE,\n                true);\n            int matchOffset = params.getInt(MoreLikeThisParams.MATCH_OFFSET, 0);\n            // Find the base match\n            DocList match = searcher.getDocList(query, null, null, matchOffset, 1,\n                flags); // only get the first one...\n            if (includeMatch) {\n              rsp.add(\"match\", match);\n            }\n\n            // This is an iterator, but we only handle the first match\n            DocIterator iterator = match.iterator();\n            if (iterator.hasNext()) {\n              // do a MoreLikeThis query for each document in results\n              int id = iterator.nextDoc();\n              mltDocs = mlt.getMoreLikeThis(id, start, rows, filters, interesting,\n                  flags);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                ERR_MSG_QUERY_OR_TEXT_REQUIRED);\n          }\n\n        } finally {\n          if (reader != null) {\n            reader.close();\n          }\n        }\n\n        if (mltDocs == null) {\n          mltDocs = new DocListAndSet(); // avoid NPE\n        }\n        rsp.addResponse(mltDocs.docList);\n\n\n        if (interesting != null) {\n          if (termStyle == TermStyle.DETAILS) {\n            NamedList<Float> it = new NamedList<>();\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.toString(), t.boost);\n            }\n            rsp.add(\"interestingTerms\", it);\n          } else {\n            List<String> it = new ArrayList<>(interesting.size());\n            for (InterestingTerm t : interesting) {\n              it.add(t.term.text());\n            }\n            rsp.add(\"interestingTerms\", it);\n          }\n        }\n\n        // maybe facet the results\n        if (params.getBool(FacetParams.FACET, false)) {\n          if (mltDocs.docSet == null) {\n            rsp.add(\"facet_counts\", null);\n          } else {\n            SimpleFacets f = new SimpleFacets(req, mltDocs.docSet, params);\n            rsp.add(\"facet_counts\", FacetComponent.getFacetCounts(f));\n          }\n        }\n        boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n\n        boolean dbgQuery = false, dbgResults = false;\n        if (dbg == false) {//if it's true, we are doing everything anyway.\n          String[] dbgParams = req.getParams().getParams(CommonParams.DEBUG);\n          if (dbgParams != null) {\n            for (String dbgParam : dbgParams) {\n              if (dbgParam.equals(CommonParams.QUERY)) {\n                dbgQuery = true;\n              } else if (dbgParam.equals(CommonParams.RESULTS)) {\n                dbgResults = true;\n              }\n            }\n          }\n        } else {\n          dbgQuery = true;\n          dbgResults = true;\n        }\n        // TODO resolve duplicated code with DebugComponent.  Perhaps it should be added to doStandardDebug?\n        if (dbg == true) {\n          try {\n            @SuppressWarnings({\"unchecked\"})\n            NamedList<Object> dbgInfo = SolrPluginUtils.doStandardDebug(req, q, mlt.getRawMLTQuery(), mltDocs.docList, dbgQuery, dbgResults);\n            if (null != dbgInfo) {\n              if (null != filters) {\n                dbgInfo.add(\"filter_queries\", req.getParams().getParams(CommonParams.FQ));\n                List<String> fqs = new ArrayList<>(filters.size());\n                for (Query fq : filters) {\n                  fqs.add(QueryParsing.toString(fq, req.getSchema()));\n                }\n                dbgInfo.add(\"parsed_filter_queries\", fqs);\n              }\n              rsp.add(\"debug\", dbgInfo);\n            }\n          } catch (Exception e) {\n            SolrException.log(log, \"Exception during debug\", e);\n            rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: {}; \", req.getParamString(), ex);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"07cbaf0735458446c429df54ba816915e8a1f638":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["79acb0e466faaab809d0bcd9d44bc446449d325e","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f"],"79acb0e466faaab809d0bcd9d44bc446449d325e":["19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1"],"5f6d19d09273bf442102fec52cfac9af9294bc89":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["0c49644277f679076861896c254bd95b97909b74"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["c26f00b574427b55127e869b935845554afde1fa"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"55980207f1977bd1463465de1659b821347e2fa8":["da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["3cdb67100dc016748799a77218aa409478372d79"],"3cdb67100dc016748799a77218aa409478372d79":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"407687e67faf6e1f02a211ca078d8e3eed631027":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","3cdb67100dc016748799a77218aa409478372d79"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["79acb0e466faaab809d0bcd9d44bc446449d325e"],"30c8e5574b55d57947e989443dfde611646530ee":["07cbaf0735458446c429df54ba816915e8a1f638","28288370235ed02234a64753cdbf0c6ec096304a"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"28288370235ed02234a64753cdbf0c6ec096304a":["07cbaf0735458446c429df54ba816915e8a1f638","5ff704ef91e9ae30ca59babb23ece85720701b60"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["79acb0e466faaab809d0bcd9d44bc446449d325e","07cbaf0735458446c429df54ba816915e8a1f638"],"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e"],"0c49644277f679076861896c254bd95b97909b74":["28288370235ed02234a64753cdbf0c6ec096304a"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ecd75942508378ccc92c3a26f71db6cba9f25784":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["79acb0e466faaab809d0bcd9d44bc446449d325e","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f6d19d09273bf442102fec52cfac9af9294bc89"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["07cbaf0735458446c429df54ba816915e8a1f638"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e":["da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"c26f00b574427b55127e869b935845554afde1fa":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"07cbaf0735458446c429df54ba816915e8a1f638":["30c8e5574b55d57947e989443dfde611646530ee","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","5ff704ef91e9ae30ca59babb23ece85720701b60"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["07cbaf0735458446c429df54ba816915e8a1f638","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"79acb0e466faaab809d0bcd9d44bc446449d325e":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"5f6d19d09273bf442102fec52cfac9af9294bc89":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e","da951a24a6a87d5ba7e1820f8c28a1e2beea76c1"],"55980207f1977bd1463465de1659b821347e2fa8":[],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3cdb67100dc016748799a77218aa409478372d79":["d17ffdbce80d3dce181982a9cd16f4f90bc8619a","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["5f6d19d09273bf442102fec52cfac9af9294bc89"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"30c8e5574b55d57947e989443dfde611646530ee":[],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","0c49644277f679076861896c254bd95b97909b74"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1":["55980207f1977bd1463465de1659b821347e2fa8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1":["79acb0e466faaab809d0bcd9d44bc446449d325e"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["55980207f1977bd1463465de1659b821347e2fa8","22d0a81a05eba47d5e18976f17d88306b218cc22"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"0c49644277f679076861896c254bd95b97909b74":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ecd75942508378ccc92c3a26f71db6cba9f25784":["19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","55980207f1977bd1463465de1659b821347e2fa8","30c8e5574b55d57947e989443dfde611646530ee","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}