{"path":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","commits":[{"id":"b2262f0d8ead49d04485950fba849e166dbe28fb","date":1451569279,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqBuilder.add(random().nextInt(maxDoc));\n    }\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclBuilder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af","date":1461918927,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqBuilder.add(random().nextInt(maxDoc));\n    }\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclBuilder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b165e49d18420d0bbd4dd93b9d3660df84e1a1","date":1461929400,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numExcludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e8d5955830d712186a4beb716e797d505af7981","date":1461951189,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numExcludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqBuilder.add(random().nextInt(maxDoc));\n    }\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclBuilder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numExcludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqBuilder.add(random().nextInt(maxDoc));\n    }\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclBuilder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestReqExclBulkScorer#doTestRandom().mjava","sourceNew":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numExcludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","sourceOld":"  public void doTestRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 1000);\n    DocIdSetBuilder reqBuilder = new DocIdSetBuilder(maxDoc);\n    DocIdSetBuilder exclBuilder = new DocIdSetBuilder(maxDoc);\n    final int numIncludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    final int numExcludedDocs = TestUtil.nextInt(random(), 1, maxDoc);\n    DocIdSetBuilder.BulkAdder reqAdder = reqBuilder.grow(numIncludedDocs);\n    for (int i = 0; i < numIncludedDocs; ++i) {\n      reqAdder.add(random().nextInt(maxDoc));\n    }\n    DocIdSetBuilder.BulkAdder exclAdder = exclBuilder.grow(numExcludedDocs);\n    for (int i = 0; i < numExcludedDocs; ++i) {\n      exclAdder.add(random().nextInt(maxDoc));\n    }\n\n    final DocIdSet req = reqBuilder.build();\n    final DocIdSet excl = exclBuilder.build();\n\n    final BulkScorer reqBulkScorer = new BulkScorer() {\n      final DocIdSetIterator iterator = req.iterator();\n\n      @Override\n      public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int doc = iterator.docID();\n        if (iterator.docID() < min) {\n          doc = iterator.advance(min);\n        }\n        while (doc < max) {\n          if (acceptDocs == null || acceptDocs.get(doc)) {\n            collector.collect(doc);\n          }\n          doc = iterator.nextDoc();\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return iterator.cost();\n      }\n    };\n\n    ReqExclBulkScorer reqExcl = new ReqExclBulkScorer(reqBulkScorer, excl.iterator());\n    final FixedBitSet actualMatches = new FixedBitSet(maxDoc);\n    if (random().nextBoolean()) {\n      reqExcl.score(new LeafCollector() {\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {}\n        \n        @Override\n        public void collect(int doc) throws IOException {\n          actualMatches.set(doc);\n        }\n      }, null);\n    } else {\n      int next = 0;\n      while (next < maxDoc) {\n        final int min = next;\n        final int max = min + random().nextInt(10);\n        next = reqExcl.score(new LeafCollector() {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {}\n          \n          @Override\n          public void collect(int doc) throws IOException {\n            actualMatches.set(doc);\n          }\n        }, null, min, max);\n        assertTrue(next >= max);\n      }\n    }\n\n    final FixedBitSet expectedMatches = new FixedBitSet(maxDoc);\n    expectedMatches.or(req.iterator());\n    FixedBitSet excludedSet = new FixedBitSet(maxDoc);\n    excludedSet.or(excl.iterator());\n    expectedMatches.andNot(excludedSet);\n\n    assertArrayEquals(expectedMatches.getBits(), actualMatches.getBits());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["b2262f0d8ead49d04485950fba849e166dbe28fb"],"8e8d5955830d712186a4beb716e797d505af7981":["b2262f0d8ead49d04485950fba849e166dbe28fb","f0b165e49d18420d0bbd4dd93b9d3660df84e1a1"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["8e8d5955830d712186a4beb716e797d505af7981"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b2262f0d8ead49d04485950fba849e166dbe28fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0b165e49d18420d0bbd4dd93b9d3660df84e1a1":["3d3eccadf4f2a01d2034c96afe1a5c617b2e85af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["b2262f0d8ead49d04485950fba849e166dbe28fb","8e8d5955830d712186a4beb716e797d505af7981"]},"commit2Childs":{"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["f0b165e49d18420d0bbd4dd93b9d3660df84e1a1"],"8e8d5955830d712186a4beb716e797d505af7981":["285244982ce6aa163d1e60a707f0e6e121736ce5","55b50463286869f584cf849d1587a0fcd54d1dfa"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2262f0d8ead49d04485950fba849e166dbe28fb"],"b2262f0d8ead49d04485950fba849e166dbe28fb":["3d3eccadf4f2a01d2034c96afe1a5c617b2e85af","8e8d5955830d712186a4beb716e797d505af7981","55b50463286869f584cf849d1587a0fcd54d1dfa"],"f0b165e49d18420d0bbd4dd93b9d3660df84e1a1":["8e8d5955830d712186a4beb716e797d505af7981"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}