{"path":"lucene/src/java/org/apache/lucene/search/LinearFuzzyTermsEnum[FuzzyTermsEnum]#similarity(char[],int,int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/LinearFuzzyTermsEnum[FuzzyTermsEnum]#similarity(char[],int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private final float similarity(final char[] target, int offset, int length) {\n    final int m = length;\n    final int n = text.length;\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefixLen == 0 ? 0.0f : 1.0f - ((float) m / prefixLen);\n    }\n    if (m == 0) {\n      return prefixLen == 0 ? 0.0f : 1.0f - ((float) n / prefixLen);\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text[i - 1];\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target[offset+j-1]) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefixLen + Math.min(n, m)));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/LinearFuzzyTermsEnum[FuzzyTermsEnum]#similarity(char[],int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance &gt; maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * minimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparison.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private final float similarity(final char[] target, int offset, int length) {\n    final int m = length;\n    final int n = text.length;\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefixLen == 0 ? 0.0f : 1.0f - ((float) m / prefixLen);\n    }\n    if (m == 0) {\n      return prefixLen == 0 ? 0.0f : 1.0f - ((float) n / prefixLen);\n    }\n\n    final int maxDistance = getMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisely Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d[0].length <= m) {\n      growDistanceArray(m);\n    }\n\n    // init matrix d\n    for (int i = 0; i <= n; i++) d[i][0] = i;\n    for (int j = 0; j <= m; j++) d[0][j] = j;\n    \n    // start computing edit distance\n    for (int i = 1; i <= n; i++) {\n      int bestPossibleEditDistance = m;\n      final char s_i = text[i - 1];\n      for (int j = 1; j <= m; j++) {\n        if (s_i != target[offset+j-1]) {\n            d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1])+1;\n        }\n        else {\n          d[i][j] = min(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]);\n        }\n        bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i][j]);\n      }\n\n      //After calculating row i, the best possible edit distance\n      //can be found by found by finding the smallest value in a given column.\n      //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n      if (i > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n        //the closest the target can be to the text is just too far away.\n        //this target is leaving the party early.\n        return 0.0f;\n      }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0f - ((float)d[n][m] / (float) (prefixLen + Math.min(n, m)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"]},"commit2Childs":{"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}