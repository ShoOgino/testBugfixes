{"path":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","commits":[{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = new IndexSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a48ce78ef9c638df43d61dc30b4625347b47016e","date":1308554244,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee2683af80f3db2bcf6bb63bb0fec2021caee67f","date":1308571212,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e16bf7641024ed2270064ba9a6037c49266bcfb1","date":1308579310,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e93e8251fcc355b1ed7d79aaff249c2ae40ba71","date":1309295333,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers), false);\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b","date":1309334373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers), false);\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : IndexReader.open(makeEmptyIndex(random, 0), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, edge < 0 ? 4 : 0), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 == edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true)),\n      IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 7), true),\n      IndexReader.open(makeEmptyIndex(random, 0), true),\n      new MultiReader(IndexReader.open(makeEmptyIndex(random, 0 < edge ? 0 : 5), true),\n          IndexReader.open(makeEmptyIndex(random, 0), true),\n          0 < edge ? r : IndexReader.open(makeEmptyIndex(random, 0), true))\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarityProvider(s.getSimilarityProvider());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a48ce78ef9c638df43d61dc30b4625347b47016e":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"e16bf7641024ed2270064ba9a6037c49266bcfb1":["a48ce78ef9c638df43d61dc30b4625347b47016e","ee2683af80f3db2bcf6bb63bb0fec2021caee67f"],"c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b":["6e93e8251fcc355b1ed7d79aaff249c2ae40ba71"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["e16bf7641024ed2270064ba9a6037c49266bcfb1","c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b"],"ee2683af80f3db2bcf6bb63bb0fec2021caee67f":["a48ce78ef9c638df43d61dc30b4625347b47016e"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b91922b55d15444d554721b352861d028eb8278":["c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b"],"6e93e8251fcc355b1ed7d79aaff249c2ae40ba71":["ee2683af80f3db2bcf6bb63bb0fec2021caee67f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"a48ce78ef9c638df43d61dc30b4625347b47016e":["e16bf7641024ed2270064ba9a6037c49266bcfb1","ee2683af80f3db2bcf6bb63bb0fec2021caee67f"],"e16bf7641024ed2270064ba9a6037c49266bcfb1":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","7b91922b55d15444d554721b352861d028eb8278"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"ee2683af80f3db2bcf6bb63bb0fec2021caee67f":["e16bf7641024ed2270064ba9a6037c49266bcfb1","6e93e8251fcc355b1ed7d79aaff249c2ae40ba71"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a48ce78ef9c638df43d61dc30b4625347b47016e","817d8435e9135b756f08ce6710ab0baac51bdf88","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6e93e8251fcc355b1ed7d79aaff249c2ae40ba71":["c9c65a2bbc3efe5fa2e3db2c260b3f45a365f22b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}