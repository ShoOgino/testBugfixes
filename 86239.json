{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","commits":[{"id":"c7f06758793500ca773d0df1037290e6e404fb33","date":1562230223,"type":0,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","pathOld":"/dev/null","sourceNew":"  public void testCheckDataDimOptimalOrder() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(5000);\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final double maxMB = (float) 3.0 + (3*random().nextDouble());\n\n    final int numIndexDims = TestUtil.nextInt(random(), 1, 8);\n    final int numDataDims =  TestUtil.nextInt(random(), numIndexDims, 8);\n\n    final byte[] pointValue1 = new byte[numDataDims * numBytesPerDim];\n    final byte[] pointValue2 = new byte[numDataDims * numBytesPerDim];\n    random().nextBytes(pointValue1);\n    random().nextBytes(pointValue2);\n    // equal index dimensions but different data dimensions\n    for (int i = 0; i < numIndexDims; i++) {\n        System.arraycopy(pointValue1, i * numBytesPerDim, pointValue2, i * numBytesPerDim, numBytesPerDim);\n    }\n\n    BKDWriter w = new BKDWriter(2 * numValues, dir, \"_temp\", numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode,\n        maxMB, 2 * numValues);\n    for (int i = 0; i < numValues; ++i) {\n      w.add(pointValue1, i);\n      w.add(pointValue2, i);\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n\n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    points.intersect(new IntersectVisitor() {\n\n      byte[] previous = null;\n      boolean hasChanged = false;\n\n      @Override\n      public void visit(int docID) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (previous == null) {\n          previous = new byte[numDataDims * numBytesPerDim];\n          System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n        } else {\n          int mismatch = Arrays.mismatch(packedValue, previous);\n          if (mismatch != -1) {\n            if (hasChanged == false) {\n              hasChanged = true;\n              System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n            } else {\n              fail(\"Points are not in optimal order\");\n            }\n          }\n        }\n      }\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","sourceNew":"  public void testCheckDataDimOptimalOrder() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(5000);\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final double maxMB = (float) 3.0 + (3*random().nextDouble());\n\n    final int numIndexDims = TestUtil.nextInt(random(), 1, 8);\n    final int numDataDims =  TestUtil.nextInt(random(), numIndexDims, 8);\n\n    final byte[] pointValue1 = new byte[numDataDims * numBytesPerDim];\n    final byte[] pointValue2 = new byte[numDataDims * numBytesPerDim];\n    random().nextBytes(pointValue1);\n    random().nextBytes(pointValue2);\n    // equal index dimensions but different data dimensions\n    for (int i = 0; i < numIndexDims; i++) {\n        System.arraycopy(pointValue1, i * numBytesPerDim, pointValue2, i * numBytesPerDim, numBytesPerDim);\n    }\n\n    BKDWriter w = new BKDWriter(2 * numValues, dir, \"_temp\", numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode,\n        maxMB, 2 * numValues);\n    for (int i = 0; i < numValues; ++i) {\n      w.add(pointValue1, i);\n      w.add(pointValue2, i);\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n\n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    points.intersect(new IntersectVisitor() {\n\n      byte[] previous = null;\n      boolean hasChanged = false;\n\n      @Override\n      public void visit(int docID) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (previous == null) {\n          previous = new byte[numDataDims * numBytesPerDim];\n          System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n        } else {\n          int mismatch = Arrays.mismatch(packedValue, previous);\n          if (mismatch != -1) {\n            if (hasChanged == false) {\n              hasChanged = true;\n              System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n            } else {\n              fail(\"Points are not in optimal order\");\n            }\n          }\n        }\n      }\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testCheckDataDimOptimalOrder() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(5000);\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final double maxMB = (float) 3.0 + (3*random().nextDouble());\n\n    final int numIndexDims = TestUtil.nextInt(random(), 1, 8);\n    final int numDataDims =  TestUtil.nextInt(random(), numIndexDims, 8);\n\n    final byte[] pointValue1 = new byte[numDataDims * numBytesPerDim];\n    final byte[] pointValue2 = new byte[numDataDims * numBytesPerDim];\n    random().nextBytes(pointValue1);\n    random().nextBytes(pointValue2);\n    // equal index dimensions but different data dimensions\n    for (int i = 0; i < numIndexDims; i++) {\n        System.arraycopy(pointValue1, i * numBytesPerDim, pointValue2, i * numBytesPerDim, numBytesPerDim);\n    }\n\n    BKDWriter w = new BKDWriter(2 * numValues, dir, \"_temp\", numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode,\n        maxMB, 2 * numValues);\n    for (int i = 0; i < numValues; ++i) {\n      w.add(pointValue1, i);\n      w.add(pointValue2, i);\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      indexFP = w.finish(out);\n      w.close();\n    }\n\n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn);\n\n    points.intersect(new IntersectVisitor() {\n\n      byte[] previous = null;\n      boolean hasChanged = false;\n\n      @Override\n      public void visit(int docID) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (previous == null) {\n          previous = new byte[numDataDims * numBytesPerDim];\n          System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n        } else {\n          int mismatch = Arrays.mismatch(packedValue, previous);\n          if (mismatch != -1) {\n            if (hasChanged == false) {\n              hasChanged = true;\n              System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n            } else {\n              fail(\"Points are not in optimal order\");\n            }\n          }\n        }\n      }\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testCheckDataDimOptimalOrder().mjava","sourceNew":"  public void testCheckDataDimOptimalOrder() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(5000);\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final double maxMB = (float) 3.0 + (3*random().nextDouble());\n\n    final int numIndexDims = TestUtil.nextInt(random(), 1, 8);\n    final int numDataDims =  TestUtil.nextInt(random(), numIndexDims, 8);\n\n    final byte[] pointValue1 = new byte[numDataDims * numBytesPerDim];\n    final byte[] pointValue2 = new byte[numDataDims * numBytesPerDim];\n    random().nextBytes(pointValue1);\n    random().nextBytes(pointValue2);\n    // equal index dimensions but different data dimensions\n    for (int i = 0; i < numIndexDims; i++) {\n        System.arraycopy(pointValue1, i * numBytesPerDim, pointValue2, i * numBytesPerDim, numBytesPerDim);\n    }\n\n    BKDWriter w = new BKDWriter(2 * numValues, dir, \"_temp\", new BKDConfig(numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode),\n        maxMB, 2 * numValues);\n    for (int i = 0; i < numValues; ++i) {\n      w.add(pointValue1, i);\n      w.add(pointValue2, i);\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n\n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    points.intersect(new IntersectVisitor() {\n\n      byte[] previous = null;\n      boolean hasChanged = false;\n\n      @Override\n      public void visit(int docID) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (previous == null) {\n          previous = new byte[numDataDims * numBytesPerDim];\n          System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n        } else {\n          int mismatch = Arrays.mismatch(packedValue, previous);\n          if (mismatch != -1) {\n            if (hasChanged == false) {\n              hasChanged = true;\n              System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n            } else {\n              fail(\"Points are not in optimal order\");\n            }\n          }\n        }\n      }\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testCheckDataDimOptimalOrder() throws IOException {\n    Directory dir = newDirectory();\n    final int numValues = atLeast(5000);\n    final int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 500);\n    final int numBytesPerDim = TestUtil.nextInt(random(), 1, 4);\n    final double maxMB = (float) 3.0 + (3*random().nextDouble());\n\n    final int numIndexDims = TestUtil.nextInt(random(), 1, 8);\n    final int numDataDims =  TestUtil.nextInt(random(), numIndexDims, 8);\n\n    final byte[] pointValue1 = new byte[numDataDims * numBytesPerDim];\n    final byte[] pointValue2 = new byte[numDataDims * numBytesPerDim];\n    random().nextBytes(pointValue1);\n    random().nextBytes(pointValue2);\n    // equal index dimensions but different data dimensions\n    for (int i = 0; i < numIndexDims; i++) {\n        System.arraycopy(pointValue1, i * numBytesPerDim, pointValue2, i * numBytesPerDim, numBytesPerDim);\n    }\n\n    BKDWriter w = new BKDWriter(2 * numValues, dir, \"_temp\", numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode,\n        maxMB, 2 * numValues);\n    for (int i = 0; i < numValues; ++i) {\n      w.add(pointValue1, i);\n      w.add(pointValue2, i);\n    }\n    final long indexFP;\n    try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n      Runnable finalizer = w.finish(out, out, out);\n      indexFP = out.getFilePointer();\n      finalizer.run();\n      w.close();\n    }\n\n    IndexInput pointsIn = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    pointsIn.seek(indexFP);\n    BKDReader points = new BKDReader(pointsIn, pointsIn, pointsIn);\n\n    points.intersect(new IntersectVisitor() {\n\n      byte[] previous = null;\n      boolean hasChanged = false;\n\n      @Override\n      public void visit(int docID) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (previous == null) {\n          previous = new byte[numDataDims * numBytesPerDim];\n          System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n        } else {\n          int mismatch = Arrays.mismatch(packedValue, previous);\n          if (mismatch != -1) {\n            if (hasChanged == false) {\n              hasChanged = true;\n              System.arraycopy(packedValue, 0, previous, 0, numDataDims * numBytesPerDim);\n            } else {\n              fail(\"Points are not in optimal order\");\n            }\n          }\n        }\n      }\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    });\n\n\n    pointsIn.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7f06758793500ca773d0df1037290e6e404fb33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["c7f06758793500ca773d0df1037290e6e404fb33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"c7f06758793500ca773d0df1037290e6e404fb33":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7f06758793500ca773d0df1037290e6e404fb33"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}