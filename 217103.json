{"path":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    ValueType[] values = ValueType.values();\n    ValueType type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    IndexDocValuesField docValuesField = new IndexDocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    ValueType[] values = ValueType.values();\n    ValueType type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"PreFlex\".equals(codecProvider.getFieldCodec(name)) || doc.getField(name) != null)\n        return;\n    IndexDocValuesField docValuesField = new IndexDocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    DocValuesField docValuesField = new DocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    ValueType[] values = ValueType.values();\n    ValueType type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    IndexDocValuesField docValuesField = new IndexDocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    DocValuesField docValuesField = new DocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    ValueType[] values = ValueType.values();\n    ValueType type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    IndexDocValuesField docValuesField = new IndexDocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    FieldType ft = new FieldType();\n    ft.setDocValueType(type);\n    ft.freeze();\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      f = new Field(name, fixedRef, ft);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      f = new Field(name, new BytesRef(_TestUtil.randomUnicodeString(random, 200)), ft);\n      break;\n    case FLOAT_32:\n      f = new Field(name, random.nextFloat(), ft);\n      break;\n    case FLOAT_64:\n      f = new Field(name, random.nextDouble(), ft);\n      break;\n    case VAR_INTS:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_16:\n      f = new Field(name, random.nextInt(Short.MAX_VALUE), ft);\n      break;\n    case FIXED_INTS_32:\n      f = new Field(name, random.nextInt(), ft);\n      break;\n    case FIXED_INTS_64:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_8:\n      f = new Field(name, random.nextInt(128), ft);\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    DocValuesField docValuesField = new DocValuesField(name);\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      docValuesField.setBytes(fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));\n      docValuesField.setBytes(ref, type);\n      break;\n    case FLOAT_32:\n      docValuesField.setFloat(random.nextFloat());\n      break;\n    case FLOAT_64:\n      docValuesField.setFloat(random.nextDouble());\n      break;\n    case VAR_INTS:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_16:\n      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      docValuesField.setInt(random.nextInt());\n      break;\n    case FIXED_INTS_64:\n      docValuesField.setInt(random.nextLong());\n      break;\n    case FIXED_INTS_8:\n      docValuesField.setInt(random.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n\n    doc.add(docValuesField);\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    FieldType ft = new FieldType();\n    ft.setDocValueType(type);\n    ft.freeze();\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      f = new Field(name, fixedRef, ft);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      f = new Field(name, new BytesRef(_TestUtil.randomUnicodeString(random, 200)), ft);\n      break;\n    case FLOAT_32:\n      f = new Field(name, random.nextFloat(), ft);\n      break;\n    case FLOAT_64:\n      f = new Field(name, random.nextDouble(), ft);\n      break;\n    case VAR_INTS:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_16:\n      f = new Field(name, random.nextInt(Short.MAX_VALUE), ft);\n      break;\n    case FIXED_INTS_32:\n      f = new Field(name, random.nextInt(), ft);\n      break;\n    case FIXED_INTS_64:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_8:\n      f = new Field(name, random.nextInt(128), ft);\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null)\n        return;\n    FieldType ft = new FieldType();\n    ft.setDocValueType(type);\n    ft.freeze();\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      f = new Field(name, fixedRef, ft);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      f = new Field(name, new BytesRef(_TestUtil.randomUnicodeString(random, 200)), ft);\n      break;\n    case FLOAT_32:\n      f = new Field(name, random.nextFloat(), ft);\n      break;\n    case FLOAT_64:\n      f = new Field(name, random.nextDouble(), ft);\n      break;\n    case VAR_INTS:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_16:\n      f = new Field(name, random.nextInt(Short.MAX_VALUE), ft);\n      break;\n    case FIXED_INTS_32:\n      f = new Field(name, random.nextInt(), ft);\n      break;\n    case FIXED_INTS_64:\n      f = new Field(name, random.nextLong(), ft);\n      break;\n    case FIXED_INTS_8:\n      f = new Field(name, random.nextInt(128), ft);\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fa0f44f887719e97183771e977cfc4bfb485b766"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["7b91922b55d15444d554721b352861d028eb8278"],"fa0f44f887719e97183771e977cfc4bfb485b766":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["7b91922b55d15444d554721b352861d028eb8278","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"fa0f44f887719e97183771e977cfc4bfb485b766":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["fa0f44f887719e97183771e977cfc4bfb485b766"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}