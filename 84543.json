{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FindDelayEvaluator#evaluate(Tuple).mjava","commits":[{"id":"d5af4cf979f31a72154bab227890da4561b327a3","date":1495645850,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FindDelayEvaluator#evaluate(Tuple).mjava","pathOld":"/dev/null","sourceNew":"  public Number evaluate(Tuple tuple) throws IOException {\n    StreamEvaluator colEval1 = subEvaluators.get(0);\n    StreamEvaluator colEval2 = subEvaluators.get(1);\n\n    List<Number> numbers1 = (List<Number>)colEval1.evaluate(tuple);\n    List<Number> numbers2 = (List<Number>)colEval2.evaluate(tuple);\n    double[] column1 = new double[numbers1.size()];\n    double[] column2 = new double[numbers2.size()];\n\n    for(int i=0; i<numbers1.size(); i++) {\n      column1[i] = numbers1.get(i).doubleValue();\n    }\n\n    //Reverse the second column.\n    //The convolve function will reverse it back.\n    //This allows correlation to be represented using the convolution math.\n    int rIndex=0;\n    for(int i=numbers2.size()-1; i>=0; i--) {\n      column2[rIndex++] = numbers2.get(i).doubleValue();\n    }\n\n    double[] convolution = MathArrays.convolve(column1, column2);\n    double max = -Double.MAX_VALUE;\n    double maxIndex = -1;\n\n    for(int i=0; i< convolution.length; i++) {\n      double abs = Math.abs(convolution[i]);\n      if(abs > max) {\n        max = abs;\n        maxIndex = i;\n      }\n    }\n\n    return (maxIndex+1)-column2.length;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12cb83a3f761dc612e1ece020f46e1886fc2550e","date":1495722768,"type":5,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/FindDelayEvaluator#evaluate(Tuple).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FindDelayEvaluator#evaluate(Tuple).mjava","sourceNew":"  public Number evaluate(Tuple tuple) throws IOException {\n    StreamEvaluator colEval1 = subEvaluators.get(0);\n    StreamEvaluator colEval2 = subEvaluators.get(1);\n\n    List<Number> numbers1 = (List<Number>)colEval1.evaluate(tuple);\n    List<Number> numbers2 = (List<Number>)colEval2.evaluate(tuple);\n    double[] column1 = new double[numbers1.size()];\n    double[] column2 = new double[numbers2.size()];\n\n    for(int i=0; i<numbers1.size(); i++) {\n      column1[i] = numbers1.get(i).doubleValue();\n    }\n\n    //Reverse the second column.\n    //The convolve function will reverse it back.\n    //This allows correlation to be represented using the convolution math.\n    int rIndex=0;\n    for(int i=numbers2.size()-1; i>=0; i--) {\n      column2[rIndex++] = numbers2.get(i).doubleValue();\n    }\n\n    double[] convolution = MathArrays.convolve(column1, column2);\n    double max = -Double.MAX_VALUE;\n    double maxIndex = -1;\n\n    for(int i=0; i< convolution.length; i++) {\n      double abs = Math.abs(convolution[i]);\n      if(abs > max) {\n        max = abs;\n        maxIndex = i;\n      }\n    }\n\n    return (maxIndex+1)-column2.length;\n  }\n\n","sourceOld":"  public Number evaluate(Tuple tuple) throws IOException {\n    StreamEvaluator colEval1 = subEvaluators.get(0);\n    StreamEvaluator colEval2 = subEvaluators.get(1);\n\n    List<Number> numbers1 = (List<Number>)colEval1.evaluate(tuple);\n    List<Number> numbers2 = (List<Number>)colEval2.evaluate(tuple);\n    double[] column1 = new double[numbers1.size()];\n    double[] column2 = new double[numbers2.size()];\n\n    for(int i=0; i<numbers1.size(); i++) {\n      column1[i] = numbers1.get(i).doubleValue();\n    }\n\n    //Reverse the second column.\n    //The convolve function will reverse it back.\n    //This allows correlation to be represented using the convolution math.\n    int rIndex=0;\n    for(int i=numbers2.size()-1; i>=0; i--) {\n      column2[rIndex++] = numbers2.get(i).doubleValue();\n    }\n\n    double[] convolution = MathArrays.convolve(column1, column2);\n    double max = -Double.MAX_VALUE;\n    double maxIndex = -1;\n\n    for(int i=0; i< convolution.length; i++) {\n      double abs = Math.abs(convolution[i]);\n      if(abs > max) {\n        max = abs;\n        maxIndex = i;\n      }\n    }\n\n    return (maxIndex+1)-column2.length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"12cb83a3f761dc612e1ece020f46e1886fc2550e":["d5af4cf979f31a72154bab227890da4561b327a3"],"d5af4cf979f31a72154bab227890da4561b327a3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"12cb83a3f761dc612e1ece020f46e1886fc2550e":[],"d5af4cf979f31a72154bab227890da4561b327a3":["12cb83a3f761dc612e1ece020f46e1886fc2550e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5af4cf979f31a72154bab227890da4561b327a3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["12cb83a3f761dc612e1ece020f46e1886fc2550e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}