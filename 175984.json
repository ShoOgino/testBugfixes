{"path":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ebb4b4370532662eb5f3238d02b002836b38b2","date":1331733267,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      // We always alloc a new block when writing w/ prefix;\n      // we could some day relax that and span two blocks:\n      assert blockSize - offset >= length;\n      // Within block\n      b.offset = offset;\n      b.bytes = blocks[index];\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"484eb080c9d643a98dc51ee3683d012609e5e95f","date":1331761835,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      // we could some day relax that and span two blocks:\n      \n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      // We always alloc a new block when writing w/ prefix;\n      // we could some day relax that and span two blocks:\n      assert blockSize - offset >= length;\n      // Within block\n      b.offset = offset;\n      b.bytes = blocks[index];\n      return b;\n    }\n\n","bugFix":null,"bugIntro":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d","date":1331762974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      // we could some day relax that and span two blocks:\n      \n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":["09ebb4b4370532662eb5f3238d02b002836b38b2","484eb080c9d643a98dc51ee3683d012609e5e95f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21","date":1331894398,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      byte[] block = blocks[index];\n      final int length;\n      assert offset <= block.length-1;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        if (offset==block.length-1) {\n          final byte[] nextBlock = blocks[++index];\n          length = ((block[offset] & 0x7f) << 8) | (nextBlock[0] & 0xff);\n          offset = 1;\n          block = nextBlock;\n          assert length > 0; \n        } else {\n          assert offset < block.length-1;\n          length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n          offset = offset+2;\n          assert length > 0;\n        }\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa968010b9c6598d02666b7b879c12e3cb0db4ee","date":1359063766,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":null,"sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      byte[] block = blocks[index];\n      final int length;\n      assert offset <= block.length-1;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        if (offset==block.length-1) {\n          final byte[] nextBlock = blocks[++index];\n          length = ((block[offset] & 0x7f) << 8) | (nextBlock[0] & 0xff);\n          offset = 1;\n          block = nextBlock;\n          assert length > 0; \n        } else {\n          assert offset < block.length-1;\n          length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n          offset = offset+2;\n          assert length > 0;\n        }\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":null,"sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      byte[] block = blocks[index];\n      final int length;\n      assert offset <= block.length-1;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        if (offset==block.length-1) {\n          final byte[] nextBlock = blocks[++index];\n          length = ((block[offset] & 0x7f) << 8) | (nextBlock[0] & 0xff);\n          offset = 1;\n          block = nextBlock;\n          assert length > 0; \n        } else {\n          assert offset < block.length-1;\n          length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n          offset = offset+2;\n          assert length > 0;\n        }\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n\n      // NOTE: even though copyUsingLengthPrefix always\n      // allocs a new block if the byte[] to be added won't\n      // fit in current block,\n      // VarDerefBytesImpl.finishInternal does its own\n      // prefix + byte[] writing which can span two blocks,\n      // so we support that here on decode:\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        b.bytes = new byte[length];\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21","fa968010b9c6598d02666b7b879c12e3cb0db4ee"],"484eb080c9d643a98dc51ee3683d012609e5e95f":["09ebb4b4370532662eb5f3238d02b002836b38b2"],"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d":["484eb080c9d643a98dc51ee3683d012609e5e95f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09ebb4b4370532662eb5f3238d02b002836b38b2":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21":["fa968010b9c6598d02666b7b879c12e3cb0db4ee","d4d69c535930b5cce125cff868d40f6373dc27d4"],"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"484eb080c9d643a98dc51ee3683d012609e5e95f":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d":["b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["09ebb4b4370532662eb5f3238d02b002836b38b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"09ebb4b4370532662eb5f3238d02b002836b38b2":["484eb080c9d643a98dc51ee3683d012609e5e95f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}