{"path":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","commits":[{"id":"8f50ea9dfa58003c5d50d910905b09f933083da4","date":1291388067,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55dd513b2fefcbba6851ee08dc8b67bdd78a528e","date":1291396189,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","date":1291833341,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac","date":1291922762,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n      threads[threadID].start();\n    }\n\n    for(int threadID=0;threadID<NUM_SEARCH_THREADS;threadID++) {\n      threads[threadID].join();\n    }\n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790e1fde4caa765b3faaad3fbcd25c6973450336","date":1296689245,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = new IndexSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f83af14a2a8131b14d7aee6274c740334e0363d3","date":1307579822,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS*RANDOM_MULTIPLIER;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", Field.Index.ANALYZED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    s.close();\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSearchWithThreads#test().mjava","sourceNew":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n\n    final long startTime = System.currentTimeMillis();\n\n    // TODO: replace w/ the @nightly test data; make this\n    // into an optional @nightly stress test\n    final Document doc = new Document();\n    final Field body = newField(\"body\", \"\", TextField.TYPE_UNSTORED);\n    doc.add(body);\n    final StringBuilder sb = new StringBuilder();\n    for(int docCount=0;docCount<NUM_DOCS;docCount++) {\n      final int numTerms = random.nextInt(10);\n      for(int termCount=0;termCount<numTerms;termCount++) {\n        sb.append(random.nextBoolean() ? \"aaa\" : \"bbb\");\n        sb.append(' ');\n      }\n      body.setValue(sb.toString());\n      w.addDocument(doc);\n      sb.delete(0, sb.length());\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    final long endTime = System.currentTimeMillis();\n    if (VERBOSE) System.out.println(\"BUILD took \" + (endTime-startTime));\n\n    final IndexSearcher s = newSearcher(r);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n    final AtomicLong netSearch = new AtomicLong();\n\n    Thread[] threads = new Thread[NUM_SEARCH_THREADS];\n    for (int threadID = 0; threadID < NUM_SEARCH_THREADS; threadID++) {\n      threads[threadID] = new Thread() {\n        TotalHitCountCollector col = new TotalHitCountCollector();\n          @Override\n          public void run() {\n            try {\n              long totHits = 0;\n              long totSearch = 0;\n              long stopAt = System.currentTimeMillis() + RUN_TIME_MSEC;\n              while(System.currentTimeMillis() < stopAt && !failed.get()) {\n                s.search(new TermQuery(new Term(\"body\", \"aaa\")), col);\n                totHits += col.getTotalHits();\n                s.search(new TermQuery(new Term(\"body\", \"bbb\")), col);\n                totHits += col.getTotalHits();\n                totSearch++;\n              }\n              assertTrue(totSearch > 0 && totHits > 0);\n              netSearch.addAndGet(totSearch);\n            } catch (Exception exc) {\n              failed.set(true);\n              throw new RuntimeException(exc);\n            }\n          }\n        };\n      threads[threadID].setDaemon(true);\n    }\n\n    for (Thread t : threads) {\n      t.start();\n    }\n    \n    for (Thread t : threads) {\n      t.join();\n    }\n    \n    if (VERBOSE) System.out.println(NUM_SEARCH_THREADS + \" threads did \" + netSearch.get() + \" searches\");\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["790e1fde4caa765b3faaad3fbcd25c6973450336","f83af14a2a8131b14d7aee6274c740334e0363d3"],"f83af14a2a8131b14d7aee6274c740334e0363d3":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"8f50ea9dfa58003c5d50d910905b09f933083da4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["1509f151d7692d84fae414b2b799ac06ba60fcb4","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac":["55dd513b2fefcbba6851ee08dc8b67bdd78a528e"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","790e1fde4caa765b3faaad3fbcd25c6973450336"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["29ef99d61cda9641b6250bf9567329a6e65f901d","f83af14a2a8131b14d7aee6274c740334e0363d3"],"55dd513b2fefcbba6851ee08dc8b67bdd78a528e":["8f50ea9dfa58003c5d50d910905b09f933083da4"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","790e1fde4caa765b3faaad3fbcd25c6973450336"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"f83af14a2a8131b14d7aee6274c740334e0363d3":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"8f50ea9dfa58003c5d50d910905b09f933083da4":["55dd513b2fefcbba6851ee08dc8b67bdd78a528e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","790e1fde4caa765b3faaad3fbcd25c6973450336"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","f83af14a2a8131b14d7aee6274c740334e0363d3","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8f50ea9dfa58003c5d50d910905b09f933083da4","4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"55dd513b2fefcbba6851ee08dc8b67bdd78a528e":["170f297ffac2bf0170f6ad64e8b7aa65f7ec26ac"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}