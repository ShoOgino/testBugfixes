{"path":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","commits":[{"id":"d613b5ee68a090ed0e48d760ff0949da8f2443c4","date":1339448928,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams.FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd9ddb59e9d33950773d186a8b726b5610ae3aad","date":1341258232,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams.FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams.FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d17ffdbce80d3dce181982a9cd16f4f90bc8619a","date":1357583592,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new SolrReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new SolrReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new ReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermVectorComponent#getFields(ResponseBuilder).mjava","sourceNew":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new SolrReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","sourceOld":"  /**\n   * Helper method for determining the list of fields that we should \n   * try to find term vectors on.  \n   * <p>\n   * Does simple (non-glob-supporting) parsing on the \n   * {@link TermVectorParams#FIELDS} param if specified, otherwise it returns \n   * the concrete field values specified in {@link CommonParams#FL} -- \n   * ignoring functions, transformers, or literals.  \n   * </p>\n   * <p>\n   * If \"fl=*\" is used, or neither param is specified, then <code>null</code> \n   * will be returned.  If the empty set is returned, it means the \"fl\" \n   * specified consisted entirely of things that are not real fields \n   * (ie: functions, transformers, partial-globs, score, etc...) and not \n   * supported by this component. \n   * </p>\n   */\n  private Set<String> getFields(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    String[] fldLst = params.getParams(TermVectorParams.FIELDS);\n    if (null == fldLst || 0 == fldLst.length || \n        (1 == fldLst.length && 0 == fldLst[0].length())) {\n\n      // no tv.fl, parse the main fl\n      ReturnFields rf = new SolrReturnFields\n        (params.getParams(CommonParams.FL), rb.req);\n\n      if (rf.wantsAllFields()) {\n        return null;\n      }\n\n      Set<String> fieldNames = rf.getLuceneFieldNames();\n      return (null != fieldNames) ?\n        fieldNames :\n        // return empty set indicating no fields should be used\n        Collections.<String>emptySet();\n    }\n\n    // otherwise us the raw fldList as is, no special parsing or globs\n    Set<String> fieldNames = new LinkedHashSet<String>();\n    for (String fl : fldLst) {\n      fieldNames.addAll(Arrays.asList(SolrPluginUtils.split(fl)));\n    }\n    return fieldNames;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["bd9ddb59e9d33950773d186a8b726b5610ae3aad","d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["d613b5ee68a090ed0e48d760ff0949da8f2443c4"],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["d613b5ee68a090ed0e48d760ff0949da8f2443c4","bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"d613b5ee68a090ed0e48d760ff0949da8f2443c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d17ffdbce80d3dce181982a9cd16f4f90bc8619a","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"d613b5ee68a090ed0e48d760ff0949da8f2443c4":["bd9ddb59e9d33950773d186a8b726b5610ae3aad","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d613b5ee68a090ed0e48d760ff0949da8f2443c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}