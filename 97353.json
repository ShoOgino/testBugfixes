{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","commits":[{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    LightAutomaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   * @param maxDeterminizedStates Maximum number of states created when\n   *   determinizing.  Higher numbers allow this operation to consume more\n   *   memory but allow more complex automatons.  Use\n   *   DEFAULT_MAX_DETERMINIZED_STATES as a decent default if you don't know\n   *   how many to allow.\n   * @throws TooComplexToDeterminizeException if determinizing a creates an\n   *   automaton with more than maxDeterminizedStates\n   */\n  public static Automaton determinize(Automaton a, int maxDeterminizedStates) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            if (q >= maxDeterminizedStates) {\n              throw new TooComplexToDeterminizeException(a, maxDeterminizedStates);\n            }\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b316f82baae88f5e279893a9cb7eee51fd8902f"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","5c84485629d80d203608e8975a1139de9933cc38"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}