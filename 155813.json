{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setIntValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setIntValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setIntValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setIntValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setIntValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setIntValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final DocValuesField valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_16:\n        valField = new DocValuesField(valueType.name(), (short) 0, valueType);\n        break;\n      case FIXED_INTS_32:\n        valField = new DocValuesField(valueType.name(), 0, valueType);\n        break;\n      case FIXED_INTS_64:\n        valField = new DocValuesField(valueType.name(), (long) 0, valueType);\n        break;\n      case FIXED_INTS_8:\n        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);\n        break;\n      case FLOAT_32:\n        valField = new DocValuesField(valueType.name(), (float) 0, valueType);\n        break;\n      case FLOAT_64:\n        valField = new DocValuesField(valueType.name(), (double) 0, valueType);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setIntValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setIntValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe","fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":["7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"841532e4eb1e16e53a6f7a438ec2079ff981b192","date":1358288582,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":null,"sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":null,"sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","841532e4eb1e16e53a6f7a438ec2079ff981b192"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["04f07771a2a7dd3a395700665ed839c3dae2def2","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"841532e4eb1e16e53a6f7a438ec2079ff981b192":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"841532e4eb1e16e53a6f7a438ec2079ff981b192":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["d4d69c535930b5cce125cff868d40f6373dc27d4","fe33227f6805edab2036cbb80645cc4e2d1fa424","841532e4eb1e16e53a6f7a438ec2079ff981b192"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}