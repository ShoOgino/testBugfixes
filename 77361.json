{"path":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","commits":[{"id":"5a7624bc6b738f100f63bb9902e91a84dd67d86f","date":1372889271,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"/dev/null","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    initCore(\"solrconfig-mutable-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"/dev/null","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    initCore(\"solrconfig-mutable-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e0d5dcd5bcba76f5b672a85f179329a4969f456","date":1376419046,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    initCore(\"solrconfig-mutable-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    initCore(\"solrconfig-mutable-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<String,Object>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestManagedSchema#testPersistUniqueKey().mjava","sourceNew":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    Files.delete(managedSchemaFile.toPath()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","sourceOld":"  public void testPersistUniqueKey() throws Exception {\n    assertSchemaResource(collection, \"managed-schema\");\n    deleteCore();\n    File managedSchemaFile = new File(tmpConfDir, \"managed-schema\");\n    assertTrue(managedSchemaFile.delete()); // Delete managed-schema so it won't block parsing a new schema\n    System.setProperty(\"managed.schema.mutable\", \"true\");\n    initCore(\"solrconfig-managed-schema.xml\", \"schema-one-field-no-dynamic-field-unique-key.xml\", tmpSolrHome.getPath());\n\n    assertTrue(managedSchemaFile.exists());\n    String managedSchemaContents = FileUtils.readFileToString(managedSchemaFile, \"UTF-8\");\n    assertFalse(managedSchemaContents.contains(\"\\\"new_field\\\"\"));\n\n    Map<String,Object> options = new HashMap<>();\n    options.put(\"stored\", \"false\");\n    IndexSchema oldSchema = h.getCore().getLatestSchema();\n    assertEquals(\"str\", oldSchema.getUniqueKeyField().getName());\n    String fieldName = \"new_field\";\n    String fieldType = \"string\";\n    SchemaField newField = oldSchema.newField(fieldName, fieldType, options);\n    IndexSchema newSchema = oldSchema.addField(newField);\n    assertEquals(\"str\", newSchema.getUniqueKeyField().getName());\n    h.getCore().setLatestSchema(newSchema);\n    log.info(\"####close harness\");\n    h.close();\n    log.info(\"####close harness end\");\n    initCore();\n\n    assertTrue(managedSchemaFile.exists());\n    FileInputStream stream = new FileInputStream(managedSchemaFile);\n    managedSchemaContents = IOUtils.toString(stream, \"UTF-8\");\n    stream.close(); // Explicitly close so that Windows can delete this file\n    assertTrue(managedSchemaContents.contains(\"<field name=\\\"new_field\\\" type=\\\"string\\\" stored=\\\"false\\\"/>\"));\n    IndexSchema newNewSchema = h.getCore().getLatestSchema();\n    assertNotNull(newNewSchema.getUniqueKeyField());\n    assertEquals(\"str\", newNewSchema.getUniqueKeyField().getName());\n  }\n\n","bugFix":["5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1e0d5dcd5bcba76f5b672a85f179329a4969f456"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1e0d5dcd5bcba76f5b672a85f179329a4969f456"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e0d5dcd5bcba76f5b672a85f179329a4969f456":["5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"5a7624bc6b738f100f63bb9902e91a84dd67d86f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cbc3688252d4a8045d69a164236b2cf87b721f17"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"1e0d5dcd5bcba76f5b672a85f179329a4969f456":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"5a7624bc6b738f100f63bb9902e91a84dd67d86f":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1e0d5dcd5bcba76f5b672a85f179329a4969f456"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}