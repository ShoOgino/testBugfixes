{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /** Optimized scan, without allocating new terms. \n   *  Return number of invocations to next(). */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /** Optimized scan, without allocating new terms. \n   *  Return number of invocations to next(). */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773f3441f7263f3a1b78e69ba2a38600c336c420","date":1307633537,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /** Optimized scan, without allocating new terms. \n   *  Return number of invocations to next(). */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":["1b30678d88259b68d3d1e3faba3ea3bccdf0c751"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8a181b2ac3ca090b11a2d4ce411832943e65d19","date":1307707503,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /** Optimized scan, without allocating new terms. \n   *  Return number of invocations to next(). */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /** Optimized scan, without allocating new terms. \n   *  Return number of invocations to next(). */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5145e7af5e55022ec6ba083c0aef480e49e0d3b","date":1319475599,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    if (first) {\n      // Always force initial next() in case term is\n      // Term(\"\", \"\")\n      next();\n      first = false;\n      count++;\n    }\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/SegmentTermEnum#scanTo(Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/SegmentTermEnum#scanTo(Term).mjava","sourceNew":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    if (first) {\n      // Always force initial next() in case term is\n      // Term(\"\", \"\")\n      next();\n      first = false;\n      count++;\n    }\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","sourceOld":"  /* Optimized scan, without allocating new terms. \n   *  Return number of invocations to next().\n   *\n   * NOTE: LUCENE-3183: if you pass Term(\"\", \"\") here then this\n   * will incorrectly return before positioning the enum,\n   * and position will be -1; caller must detect this. */\n  final int scanTo(Term term) throws IOException {\n    scanBuffer.set(term);\n    int count = 0;\n    if (first) {\n      // Always force initial next() in case term is\n      // Term(\"\", \"\")\n      next();\n      first = false;\n      count++;\n    }\n    while (scanBuffer.compareTo(termBuffer) > 0 && next()) {\n      count++;\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","773f3441f7263f3a1b78e69ba2a38600c336c420"],"7b91922b55d15444d554721b352861d028eb8278":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b8a181b2ac3ca090b11a2d4ce411832943e65d19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","773f3441f7263f3a1b78e69ba2a38600c336c420"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"773f3441f7263f3a1b78e69ba2a38600c336c420":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["773f3441f7263f3a1b78e69ba2a38600c336c420"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"b8a181b2ac3ca090b11a2d4ce411832943e65d19":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","b8a181b2ac3ca090b11a2d4ce411832943e65d19","773f3441f7263f3a1b78e69ba2a38600c336c420"],"773f3441f7263f3a1b78e69ba2a38600c336c420":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","b8a181b2ac3ca090b11a2d4ce411832943e65d19","c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["7b91922b55d15444d554721b352861d028eb8278"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","b8a181b2ac3ca090b11a2d4ce411832943e65d19","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}