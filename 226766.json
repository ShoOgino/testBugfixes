{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":5,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}