{"path":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","commits":[{"id":"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91","date":1456586780,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final Comparator<BytesRef> comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b51ee14e04858fe1f47f241ac29486de23b215b5","date":1456734355,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final Comparator<BytesRef> comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort(Comparator[BytesRef]).mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   * \n   * @param comp\n   *          the {@link Comparator} used for sorting\n   */\n  public int[] sort(final Comparator<BytesRef> comp) {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return comp.compare(scratch1, scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return comp.compare(pivot, scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4fad46319f3d6c1d3e0aa6838a968a25b8fbef07","date":1464190764,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new StringMSBRadixSorter() {\n\n      BytesRef scratch = new BytesRef();\n\n      @Override\n      protected void swap(int i, int j) {\n        int tmp = compact[i];\n        compact[i] = compact[j];\n        compact[j] = tmp;\n      }\n\n      @Override\n      protected BytesRef get(int i) {\n        pool.setBytesRef(scratch, bytesStart[compact[i]]);\n        return scratch;\n      }\n\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new StringMSBRadixSorter() {\n\n      BytesRef scratch = new BytesRef();\n\n      @Override\n      protected void swap(int i, int j) {\n        int tmp = compact[i];\n        compact[i] = compact[j];\n        compact[j] = tmp;\n      }\n\n      @Override\n      protected BytesRef get(int i) {\n        pool.setBytesRef(scratch, bytesStart[compact[i]]);\n        return scratch;\n      }\n\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new StringMSBRadixSorter() {\n\n      BytesRef scratch = new BytesRef();\n\n      @Override\n      protected void swap(int i, int j) {\n        int tmp = compact[i];\n        compact[i] = compact[j];\n        compact[j] = tmp;\n      }\n\n      @Override\n      protected BytesRef get(int i) {\n        pool.setBytesRef(scratch, bytesStart[compact[i]]);\n        return scratch;\n      }\n\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#sort().mjava","sourceNew":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new StringMSBRadixSorter() {\n\n      BytesRef scratch = new BytesRef();\n\n      @Override\n      protected void swap(int i, int j) {\n        int tmp = compact[i];\n        compact[i] = compact[j];\n        compact[j] = tmp;\n      }\n\n      @Override\n      protected BytesRef get(int i) {\n        pool.setBytesRef(scratch, bytesStart[compact[i]]);\n        return scratch;\n      }\n\n    }.sort(0, count);\n    return compact;\n  }\n\n","sourceOld":"  /**\n   * Returns the values array sorted by the referenced byte values.\n   * <p>\n   * Note: This is a destructive operation. {@link #clear()} must be called in\n   * order to reuse this {@link BytesRefHash} instance.\n   * </p>\n   */\n  public int[] sort() {\n    final int[] compact = compact();\n    new IntroSorter() {\n      @Override\n      protected void swap(int i, int j) {\n        final int o = compact[i];\n        compact[i] = compact[j];\n        compact[j] = o;\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        final int id1 = compact[i], id2 = compact[j];\n        assert bytesStart.length > id1 && bytesStart.length > id2;\n        pool.setBytesRef(scratch1, bytesStart[id1]);\n        pool.setBytesRef(scratch2, bytesStart[id2]);\n        return scratch1.compareTo(scratch2);\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        final int id = compact[i];\n        assert bytesStart.length > id;\n        pool.setBytesRef(pivot, bytesStart[id]);\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        final int id = compact[j];\n        assert bytesStart.length > id;\n        pool.setBytesRef(scratch2, bytesStart[id]);\n        return pivot.compareTo(scratch2);\n      }\n      \n      private final BytesRef pivot = new BytesRef(),\n        scratch1 = new BytesRef(), scratch2 = new BytesRef();\n    }.sort(0, count);\n    return compact;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b51ee14e04858fe1f47f241ac29486de23b215b5"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["78cf5dd35bc9be11f14b0c5b5806b05d3f529f91"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["af2638813028b254a88b418ebeafb541afb49653","4fad46319f3d6c1d3e0aa6838a968a25b8fbef07"],"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4fad46319f3d6c1d3e0aa6838a968a25b8fbef07":["af2638813028b254a88b418ebeafb541afb49653"],"83870855d82aba6819217abeff5a40779dbb28b4":["af2638813028b254a88b418ebeafb541afb49653","0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["af2638813028b254a88b418ebeafb541afb49653","0e121d43b5a10f2df530f406f935102656e9c4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e121d43b5a10f2df530f406f935102656e9c4e8"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["0e121d43b5a10f2df530f406f935102656e9c4e8","4fad46319f3d6c1d3e0aa6838a968a25b8fbef07","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["af2638813028b254a88b418ebeafb541afb49653"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"78cf5dd35bc9be11f14b0c5b5806b05d3f529f91":["b51ee14e04858fe1f47f241ac29486de23b215b5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","78cf5dd35bc9be11f14b0c5b5806b05d3f529f91"],"4fad46319f3d6c1d3e0aa6838a968a25b8fbef07":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}