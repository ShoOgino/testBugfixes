{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","commits":[{"id":"6e619491f96eb1c2c64d9f8134326816b0bcd2e4","date":1395198663,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), RANDOM.nextBoolean());\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdeaa00dcbddadddadb64c70e8cbf41f17d40103","date":1395205849,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), RANDOM.nextBoolean());\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"819937dbf00e42db24a95dd95454773e968b164f","date":1397424778,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudSolrClient = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrClient = new CloudSolrClient(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrClient.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrClient, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrClient != null) {\n        cloudSolrClient.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrServer cloudSolrServer = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrServer = new CloudSolrServer(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrServer.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrServer, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrServer.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      cloudSolrServer.add(doc);\n      cloudSolrServer.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrServer.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrServer != null) {\n        cloudSolrServer.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4b636de9d648a57c06c19d05a2344be9a96ee11","date":1420139952,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    // create collection\n    String collectionName = \"testSolrCloudCollection\";\n    String configName = \"solrCloudCollectionConfig\";\n    File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n    miniCluster.uploadConfigDir(configDir, configName);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n    collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n    collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n    // use non-test classes so RandomizedRunner isn't necessary\n    collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n    collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n    miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n    \n    try(SolrZkClient zkClient = new SolrZkClient\n        (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      \n      // modify/query collection\n      CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudSolrClient = null;\n    SolrZkClient zkClient = null;\n    try {\n      cloudSolrClient = new CloudSolrClient(miniCluster.getZkServer().getZkAddress(), true);\n      cloudSolrClient.connect();\n      zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(),\n        AbstractZkTestCase.TIMEOUT, 45000, null);\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      System.setProperty(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      uploadConfigToZk(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\", configName);\n      createCollection(cloudSolrClient, collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName);\n\n      // modify/query collection\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    } finally {\n      if (cloudSolrClient != null) {\n        cloudSolrClient.shutdown();\n      }\n      if (zkClient != null) {\n        zkClient.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc56848da7b3f927bb9840e8aedf09ee11cede1","date":1424871235,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    // create collection\n    String collectionName = \"testSolrCloudCollection\";\n    String configName = \"solrCloudCollectionConfig\";\n    File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n    miniCluster.uploadConfigDir(configDir, configName);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n    collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n    collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n    // use non-test classes so RandomizedRunner isn't necessary\n    collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n    collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n    miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n    \n    try(SolrZkClient zkClient = new SolrZkClient\n        (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      \n      // modify/query collection\n      CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    // create collection\n    String collectionName = \"testSolrCloudCollection\";\n    String configName = \"solrCloudCollectionConfig\";\n    File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n    miniCluster.uploadConfigDir(configDir, configName);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n    collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n    collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n    // use non-test classes so RandomizedRunner isn't necessary\n    collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n    collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n    miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n    \n    try(SolrZkClient zkClient = new SolrZkClient\n        (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      \n      // modify/query collection\n      CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82ae1e051eb54651f97786343944abe292d64b50","date":1425934288,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n        ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    // create collection\n    String collectionName = \"testSolrCloudCollection\";\n    String configName = \"solrCloudCollectionConfig\";\n    File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n    miniCluster.uploadConfigDir(configDir, configName);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n    collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n    collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n    // use non-test classes so RandomizedRunner isn't necessary\n    collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n    collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n    miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n    \n    try(SolrZkClient zkClient = new SolrZkClient\n        (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      \n      // modify/query collection\n      CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n        ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // shut down a server\n    JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n    assertTrue(stoppedServer.isStopped());\n    assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n    // create a server\n    JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n    assertTrue(startedServer.isRunning());\n    assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n    // create collection\n    String collectionName = \"testSolrCloudCollection\";\n    String configName = \"solrCloudCollectionConfig\";\n    File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n    miniCluster.uploadConfigDir(configDir, configName);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n    collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n    collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n    // use non-test classes so RandomizedRunner isn't necessary\n    collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n    collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n    collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n    miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n    \n    try(SolrZkClient zkClient = new SolrZkClient\n        (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n      ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n      waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n      \n      // modify/query collection\n      CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.setField(\"id\", \"1\");\n      cloudSolrClient.add(doc);\n      cloudSolrClient.commit();\n      SolrQuery query = new SolrQuery();\n      query.setQuery(\"*:*\");\n      QueryResponse rsp = cloudSolrClient.query(query);\n      assertEquals(1, rsp.getResults().getNumFound());\n\n      // remove a server not hosting any replicas\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n      for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n        String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n        jettyMap.put(key, jetty);\n      }\n      Collection<Slice> slices = clusterState.getSlices(collectionName);\n      // track the servers not host repliacs\n      for (Slice slice : slices) {\n        jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n        for (Replica replica : slice.getReplicas()) {\n          jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n        }\n      }\n      assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n      JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n      jettys = miniCluster.getJettySolrRunners();\n      for (int i = 0; i < jettys.size(); ++i) {\n        if (jettys.get(i).equals(jettyToStop)) {\n          miniCluster.stopJettySolrRunner(i);\n          assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a9be5565efd659f2400b5f4db5144a4ffa1da3d","date":1429792192,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    testCollectionCreateSearchDelete();\n    // sometimes run a second test e.g. to test collection create-delete-create scenario\n    if (random().nextBoolean()) testCollectionCreateSearchDelete();\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir().toFile(), solrXml, null, null);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner(null, null, null);\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.maxIndexingThreads\", \"-1\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, collectionProperties);\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null)) {\n        ZkStateReader zkStateReader = new ZkStateReader(zkClient);\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState(true);\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b","date":1438774486,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":"  @Test\n  public void testBasics() throws Exception {\n    final String collectionName = \"testSolrCloudCollection\";\n    testCollectionCreateSearchDelete(collectionName);\n    // sometimes run a second test e.g. to test collection create-delete-create scenario\n    if (random().nextBoolean()) testCollectionCreateSearchDelete(collectionName);\n  }\n\n","sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    testCollectionCreateSearchDelete();\n    // sometimes run a second test e.g. to test collection create-delete-create scenario\n    if (random().nextBoolean()) testCollectionCreateSearchDelete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54","date":1446047031,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testBasics().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testBasics() throws Exception {\n    final String collectionName = \"testSolrCloudCollection\";\n    testCollectionCreateSearchDelete(collectionName);\n    // sometimes run a second test e.g. to test collection create-delete-create scenario\n    if (random().nextBoolean()) testCollectionCreateSearchDelete(collectionName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fdeaa00dcbddadddadb64c70e8cbf41f17d40103":["6e619491f96eb1c2c64d9f8134326816b0bcd2e4"],"e4b636de9d648a57c06c19d05a2344be9a96ee11":["bafca15d8e408346a67f4282ad1143b88023893b"],"819937dbf00e42db24a95dd95454773e968b164f":["fdeaa00dcbddadddadb64c70e8cbf41f17d40103"],"bafca15d8e408346a67f4282ad1143b88023893b":["819937dbf00e42db24a95dd95454773e968b164f"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["9a9be5565efd659f2400b5f4db5144a4ffa1da3d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e4b636de9d648a57c06c19d05a2344be9a96ee11","82ae1e051eb54651f97786343944abe292d64b50"],"9a9be5565efd659f2400b5f4db5144a4ffa1da3d":["82ae1e051eb54651f97786343944abe292d64b50"],"82ae1e051eb54651f97786343944abe292d64b50":["1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"6e619491f96eb1c2c64d9f8134326816b0bcd2e4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["e4b636de9d648a57c06c19d05a2344be9a96ee11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"]},"commit2Childs":{"fdeaa00dcbddadddadb64c70e8cbf41f17d40103":["819937dbf00e42db24a95dd95454773e968b164f"],"e4b636de9d648a57c06c19d05a2344be9a96ee11":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"819937dbf00e42db24a95dd95454773e968b164f":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["e4b636de9d648a57c06c19d05a2344be9a96ee11"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"6e619491f96eb1c2c64d9f8134326816b0bcd2e4":["fdeaa00dcbddadddadb64c70e8cbf41f17d40103"],"9a9be5565efd659f2400b5f4db5144a4ffa1da3d":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"82ae1e051eb54651f97786343944abe292d64b50":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9a9be5565efd659f2400b5f4db5144a4ffa1da3d"],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["82ae1e051eb54651f97786343944abe292d64b50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e619491f96eb1c2c64d9f8134326816b0bcd2e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}