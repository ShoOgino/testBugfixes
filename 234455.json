{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/LongCompressor#compress(PackedInts.Reader,int,boolean,int,int,double).mjava","commits":[{"id":"91afec3d1be3c4538a6f92102a22573087f69d68","date":1543843480,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/LongCompressor#compress(PackedInts.Reader,int,boolean,int,int,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a compact version of the given values from index 0 to length-1.\n   * @param values PackedInts with no special constraints.\n   * @param length the number of values to compress.\n   * @param allowSparse if true and is the default limits matches the input, a sparse representation will be created.\n   * @param minTotalSparse the minimum absolute number of 0-entries needed for a sparse representation.\n   *                       0-entries are counted after minValue compression: {@code 3, 5, 3, 7, 16} has two 0-entries.\n   * @return a compact version of the given values or the given values if compression did not improve on heap overhead.\n   */\n  public static PackedInts.Reader compress(\n      PackedInts.Reader values, int length, boolean allowSparse,\n      int minTotalSparse, int minZeroSparse, double minZeroFractionSparse) {\n    if (length == 0) {\n      return PackedInts.getMutable(0, 1, PackedInts.DEFAULT);\n    }\n\n    final long min = getMin(values, length);\n    final long gcd = getGCD(values, length, min);\n    final long maxCompressed = getMax(values, length, min, gcd);\n\n    int zeroCount;\n    if (!isPossiblySparseCandidate(length, allowSparse, minTotalSparse) ||\n        !isSparseCandidate(values, length, true, minTotalSparse,\n            (zeroCount = countZeroes(values, length, min, gcd)), minZeroSparse, minZeroFractionSparse)) {\n      // TODO: Add abort-early if it becomes apparent that no space saving is possible\n      PackedInts.Mutable inner =\n          PackedInts.getMutable(length, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n      for (int i = 0 ; i < length ; i++) {\n        inner.set(i, (values.get(i)-min)/gcd);\n      }\n      PackedInts.Reader comp = new CompressedReader(inner, min, gcd);\n      // Sanity check that compression worked and if not, return the original input\n      return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n    }\n\n    // Sparsify\n    RankBitSet rank = new RankBitSet(length);\n    PackedInts.Mutable inner =\n        PackedInts.getMutable(values.size()-zeroCount, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n    int valueIndex = 0;\n    for (int i = 0 ; i < length ; i++) {\n      long value = (values.get(i)-min)/gcd;\n      if (value != 0) {\n        rank.set(i);\n        inner.set(valueIndex++, value);\n      }\n    }\n    rank.buildRankCache();\n    PackedInts.Reader comp = new CompressedReader(inner, min, gcd, rank);\n    // Sanity check that compression worked and if not, return the original input\n    return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90c33633162a86e6323f4cf2b93e2bb168b1dc22","date":1544534062,"type":4,"author":"Toke Eskildsen","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/LongCompressor#compress(PackedInts.Reader,int,boolean,int,int,double).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a compact version of the given values from index 0 to length-1.\n   * @param values PackedInts with no special constraints.\n   * @param length the number of values to compress.\n   * @param allowSparse if true and is the default limits matches the input, a sparse representation will be created.\n   * @param minTotalSparse the minimum absolute number of 0-entries needed for a sparse representation.\n   *                       0-entries are counted after minValue compression: {@code 3, 5, 3, 7, 16} has two 0-entries.\n   * @return a compact version of the given values or the given values if compression did not improve on heap overhead.\n   */\n  public static PackedInts.Reader compress(\n      PackedInts.Reader values, int length, boolean allowSparse,\n      int minTotalSparse, int minZeroSparse, double minZeroFractionSparse) {\n    if (length == 0) {\n      return PackedInts.getMutable(0, 1, PackedInts.DEFAULT);\n    }\n\n    final long min = getMin(values, length);\n    final long gcd = getGCD(values, length, min);\n    final long maxCompressed = getMax(values, length, min, gcd);\n\n    int zeroCount;\n    if (!isPossiblySparseCandidate(length, allowSparse, minTotalSparse) ||\n        !isSparseCandidate(values, length, true, minTotalSparse,\n            (zeroCount = countZeroes(values, length, min, gcd)), minZeroSparse, minZeroFractionSparse)) {\n      // TODO: Add abort-early if it becomes apparent that no space saving is possible\n      PackedInts.Mutable inner =\n          PackedInts.getMutable(length, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n      for (int i = 0 ; i < length ; i++) {\n        inner.set(i, (values.get(i)-min)/gcd);\n      }\n      PackedInts.Reader comp = new CompressedReader(inner, min, gcd);\n      // Sanity check that compression worked and if not, return the original input\n      return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n    }\n\n    // Sparsify\n    RankBitSet rank = new RankBitSet(length);\n    PackedInts.Mutable inner =\n        PackedInts.getMutable(values.size()-zeroCount, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n    int valueIndex = 0;\n    for (int i = 0 ; i < length ; i++) {\n      long value = (values.get(i)-min)/gcd;\n      if (value != 0) {\n        rank.set(i);\n        inner.set(valueIndex++, value);\n      }\n    }\n    rank.buildRankCache();\n    PackedInts.Reader comp = new CompressedReader(inner, min, gcd, rank);\n    // Sanity check that compression worked and if not, return the original input\n    return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfd70c9571310639a77f0123aea0db41077d9bb6","date":1544538617,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/LongCompressor#compress(PackedInts.Reader,int,boolean,int,int,double).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a compact version of the given values from index 0 to length-1.\n   * @param values PackedInts with no special constraints.\n   * @param length the number of values to compress.\n   * @param allowSparse if true and is the default limits matches the input, a sparse representation will be created.\n   * @param minTotalSparse the minimum absolute number of 0-entries needed for a sparse representation.\n   *                       0-entries are counted after minValue compression: {@code 3, 5, 3, 7, 16} has two 0-entries.\n   * @return a compact version of the given values or the given values if compression did not improve on heap overhead.\n   */\n  public static PackedInts.Reader compress(\n      PackedInts.Reader values, int length, boolean allowSparse,\n      int minTotalSparse, int minZeroSparse, double minZeroFractionSparse) {\n    if (length == 0) {\n      return PackedInts.getMutable(0, 1, PackedInts.DEFAULT);\n    }\n\n    final long min = getMin(values, length);\n    final long gcd = getGCD(values, length, min);\n    final long maxCompressed = getMax(values, length, min, gcd);\n\n    int zeroCount;\n    if (!isPossiblySparseCandidate(length, allowSparse, minTotalSparse) ||\n        !isSparseCandidate(values, length, true, minTotalSparse,\n            (zeroCount = countZeroes(values, length, min, gcd)), minZeroSparse, minZeroFractionSparse)) {\n      // TODO: Add abort-early if it becomes apparent that no space saving is possible\n      PackedInts.Mutable inner =\n          PackedInts.getMutable(length, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n      for (int i = 0 ; i < length ; i++) {\n        inner.set(i, (values.get(i)-min)/gcd);\n      }\n      PackedInts.Reader comp = new CompressedReader(inner, min, gcd);\n      // Sanity check that compression worked and if not, return the original input\n      return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n    }\n\n    // Sparsify\n    RankBitSet rank = new RankBitSet(length);\n    PackedInts.Mutable inner =\n        PackedInts.getMutable(values.size()-zeroCount, PackedInts.bitsRequired(maxCompressed), PackedInts.DEFAULT);\n    int valueIndex = 0;\n    for (int i = 0 ; i < length ; i++) {\n      long value = (values.get(i)-min)/gcd;\n      if (value != 0) {\n        rank.set(i);\n        inner.set(valueIndex++, value);\n      }\n    }\n    rank.buildRankCache();\n    PackedInts.Reader comp = new CompressedReader(inner, min, gcd, rank);\n    // Sanity check that compression worked and if not, return the original input\n    return comp.ramBytesUsed() < values.ramBytesUsed() ? comp : values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91afec3d1be3c4538a6f92102a22573087f69d68":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["91afec3d1be3c4538a6f92102a22573087f69d68","90c33633162a86e6323f4cf2b93e2bb168b1dc22"],"90c33633162a86e6323f4cf2b93e2bb168b1dc22":["91afec3d1be3c4538a6f92102a22573087f69d68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfd70c9571310639a77f0123aea0db41077d9bb6"]},"commit2Childs":{"91afec3d1be3c4538a6f92102a22573087f69d68":["cfd70c9571310639a77f0123aea0db41077d9bb6","90c33633162a86e6323f4cf2b93e2bb168b1dc22"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"90c33633162a86e6323f4cf2b93e2bb168b1dc22":["cfd70c9571310639a77f0123aea0db41077d9bb6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91afec3d1be3c4538a6f92102a22573087f69d68"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}