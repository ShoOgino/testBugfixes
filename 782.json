{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399d5903979ca52514d2bc7e3a362e1c45885c94","date":1333042474,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2dee33619431ada2a7a07f5fe2dbd94bac6a460","date":1337274029,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b2af6b2c05418fb9df466c739ed5b3a153eadde","date":1337520269,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0791b41f65aecff2e75db0c1ebf95d745a5ab1b1","date":1338332414,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    if (conf.inUseByIndexWriter.get()) {\n      throw new IllegalStateException(\"the provided IndexWriterConfig was previously used by a different IndexWriter; please make a new one instead\");\n    }\n    config = conf.clone();\n    config.inUseByIndexWriter.set(true);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","7b91922b55d15444d554721b352861d028eb8278","06584e6e98d592b34e1329b384182f368d2025e8","7ab99e8c71442b92c320e218141dee04a9b91ce8","adde4ed7da03e734626803a3802e6cf88b77a2e7","fe8474c4e5a03f0ca187f99c062af83e092717f3","076af493bb24818bc23f634456a5d89f6c1bd3fc","f7719bda090a2ae5bab940a27ba7bb9054b29818"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f4e54ed7cef46f86888b5fb547594f62160395c","date":1340006971,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    if (conf.inUseByIndexWriter.get()) {\n      throw new IllegalStateException(\"the provided IndexWriterConfig was previously used by a different IndexWriter; please make a new one instead\");\n    }\n    config = conf.clone();\n    config.inUseByIndexWriter.set(true);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4ce24aa081e44190692bbebc8aead342ad7060e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30e0912f3a3069b115cfea44ff612c44d6906386","date":1365631344,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3af8c90c5e965a1a8011e827ab59de734c7dfb79","date":1368108782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4","c5947ccd7ba3770dcba5a0713dbd5496678256d9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5091aa83309a6e03e5104286d08aff1d8e2b3a82","date":1371565135,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned, which, in-turn, clones the\n   * {@link IndexWriterConfig#getFlushPolicy() flush policy},\n   * {@link IndexWriterConfig#getIndexDeletionPolicy() deletion policy},\n   * {@link IndexWriterConfig#getMergePolicy() merge policy},\n   * and {@link IndexWriterConfig#getMergeScheduler() merge scheduler}.\n   * If you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4ce24aa081e44190692bbebc8aead342ad7060e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned, which, in-turn, clones the\n   * {@link IndexWriterConfig#getFlushPolicy() flush policy},\n   * {@link IndexWriterConfig#getIndexDeletionPolicy() deletion policy},\n   * {@link IndexWriterConfig#getMergePolicy() merge policy},\n   * and {@link IndexWriterConfig#getMergeScheduler() merge scheduler}.\n   * If you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ce24aa081e44190692bbebc8aead342ad7060e8","date":1374951664,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned, which, in-turn, clones the\n   * {@link IndexWriterConfig#getFlushPolicy() flush policy},\n   * {@link IndexWriterConfig#getIndexDeletionPolicy() deletion policy},\n   * {@link IndexWriterConfig#getMergePolicy() merge policy},\n   * and {@link IndexWriterConfig#getMergeScheduler() merge scheduler}.\n   * If you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["7f4e54ed7cef46f86888b5fb547594f62160395c","5091aa83309a6e03e5104286d08aff1d8e2b3a82","00b21520fafb9860ce0318d7be5ea84619c185ad"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned, which, in-turn, clones the\n   * {@link IndexWriterConfig#getFlushPolicy() flush policy},\n   * {@link IndexWriterConfig#getIndexDeletionPolicy() deletion policy},\n   * {@link IndexWriterConfig#getMergePolicy() merge policy},\n   * and {@link IndexWriterConfig#getMergeScheduler() merge scheduler}.\n   * If you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    config = new LiveIndexWriterConfig(conf.clone());\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0fcdcf196523675146a4df3193e91413533857ab","date":1390686560,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["c5e92e41f8d7626ca1ac96bc757f15ab985e6890"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfc45818441587d8004ff1a119fb60ac9ecb9a14","date":1401437797,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = new LiveIndexWriterConfig(conf);\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"027bee21e09164c9ee230395405076d1e0034b30","date":1401521821,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergePolicy = config.getMergePolicy();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13eb667d6e65203cf0d6d783f25a6b410e8935ec","date":1412186148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos.read(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos.read(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos.read(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos.read(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    directory = d;\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98b44240f64a2d6935543ff25faee750b29204eb","date":1424972040,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalDocCount());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98a04f56464afdffd4c430d6c47a0c868a38354e","date":1424985833,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalDocCount());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalDocCount());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalDocCount());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    \n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    long timeout = config.getWriteLockTimeout();\n    final Directory lockDir;\n    if (timeout == 0) {\n      // user doesn't want sleep/retries\n      lockDir = d;\n    } else {\n      lockDir = new SleepingLockWrapper(d, timeout);\n    }\n    writeLock = lockDir.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n\n    directory = d;\n\n    // Directory we use for merging, so we can abort running merges, and so\n    // merge schedulers can optionally rate-limit per-merge IO:\n    mergeDirectory = addMergeRateLimiters(d);\n\n    analyzer = config.getAnalyzer();\n    infoStream = config.getInfoStream();\n    mergeScheduler = config.getMergeScheduler();\n    mergeScheduler.setInfoStream(infoStream);\n    codec = config.getCodec();\n\n    bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n    poolReaders = config.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(config.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directory, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b97509e7e2489430edfe784e4411976e3c6c748","date":1434336771,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    \n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    \n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    long timeout = config.getWriteLockTimeout();\n    final Directory lockDir;\n    if (timeout == 0) {\n      // user doesn't want sleep/retries\n      lockDir = d;\n    } else {\n      lockDir = new SleepingLockWrapper(d, timeout);\n    }\n    writeLock = lockDir.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6b82a3644db30161c3cbd3e23aeefe19cb88113","date":1435478870,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n      boolean fromReader = false;\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    \n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n      } else {\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        IndexCommit commit = config.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = getFieldNumberMap();\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n      boolean fromReader = false;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n      boolean fromReader = false;\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String[] files = directory.listAll();\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n      boolean fromReader = false;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory still has pending deleted files\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac","date":1454606266,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    Directory unwrapped = FilterDirectory.unwrap(d);\n    if (unwrapped instanceof FSDirectory && ((FSDirectory) unwrapped).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory still has pending deleted files\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6105d385afcbf42689e171e9bcea48d0c9ff6c","date":1454692764,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" is still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    Directory unwrapped = FilterDirectory.unwrap(d);\n    if (unwrapped instanceof FSDirectory && ((FSDirectory) unwrapped).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" is still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1643a47ae20c901b799d4b469fd2fe6bb203bea","date":1454774887,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" is still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" is still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" is still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71e1a70f18d64b93db3ef618e606d6df5062f747","date":1466156390,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c","date":1467811770,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10005c6013abbd1102f2463cf95604d4c8774c99","date":1469460814,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after this writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after this writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0567940defa1ea6eb8a039d9d36e3682063f8a4","date":1469815320,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after this writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after this writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer. If you intend to do so, you should\n   * {@link IndexWriterConfig#clone() clone} it beforehand.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d97ba94eef1fc33c5451259a7aa2ac682646c1af","date":1488285427,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        SegmentInfos sis = null;\n        try {\n          sis = SegmentInfos.readLatestCommit(directory);\n          sis.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n          sis = new SegmentInfos();\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      // Directory we use for merging, so we can abort running merges, and so\n      // merge schedulers can optionally rate-limit per-merge IO:\n      mergeDirectory = addMergeRateLimiters(directory);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<String,String>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), newReader, new PendingDeletes(newReader, newReader.getSegmentInfo())));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), newReader, new PendingDeletes(newReader, newReader.getSegmentInfo())));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(this, newReader));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), newReader, newPendingDeletes(newReader, newReader.getSegmentInfo())));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), newReader, new PendingDeletes(newReader, newReader.getSegmentInfo())));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n      poolReaders = config.getReaderPooling();\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init from reader \" + reader);\n          messageState();\n        }\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // Pre-enroll all segment readers into the reader pool; this is necessary so\n        // any in-memory NRT live docs are correctly carried over, and so NRT readers\n        // pulled from this IW share the same segment reader:\n        List<LeafReaderContext> leaves = reader.leaves();\n        assert segmentInfos.size() == leaves.size();\n\n        for (int i=0;i<leaves.size();i++) {\n          LeafReaderContext leaf = leaves.get(i);\n          SegmentReader segReader = (SegmentReader) leaf.reader();\n          SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(), segReader.numDocs());\n          readerPool.readerMap.put(newReader.getSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), newReader, newPendingDeletes(newReader, newReader.getSegmentInfo())));\n        }\n\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n\n      bufferedUpdatesStream = new BufferedUpdatesStream(this);\n\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      docWriter = new DocumentsWriter(this, config, directoryOrig, directory);\n      eventQueue = docWriter.eventQueue();\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3306bdef6cff9218671c5972462d4ff115785dd0","date":1524667585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d.checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d instanceof FSDirectory && ((FSDirectory) d).checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5e84aa7f651de6493590da495bcbe46d32cf038","date":1526462263,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    if (d.checkPendingDeletions()) {\n      throw new IllegalArgumentException(\"Directory \" + d + \" still has pending deleted files; cannot initialize IndexWriter\");\n    }\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf310a87bbc47f93a147695674e33b1234513a7f","date":1532682688,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      boolean initialIndexExists = true;\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        try {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          initialIndexExists = false;\n        }\n        \n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       initialIndexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb769584d3433c13d4262b03a87433e9a8c5a307","date":1542374674,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader, config.getReaderAttributes());\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader, config.getReaderAttributes());\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.initialize(infoStream, directoryOrig);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.setInfoStream(infoStream);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.initialize(infoStream, directoryOrig);\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * If you want to make \"live\" changes to this writer instance, use\n   * {@link #getConfig()}.\n   * \n   * <p>\n   * <b>NOTE:</b> after ths writer is created, the given configuration instance\n   * cannot be passed to another writer.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf) throws IOException {\n    enableTestPoints = isEnableTestPoints();\n    conf.setIndexWriter(this); // prevent reuse by other instances\n    config = conf;\n    infoStream = config.getInfoStream();\n    softDeletesEnabled = config.getSoftDeletesField() != null;\n    // obtain the write.lock. If the user configured a timeout,\n    // we wrap with a sleeper and this might take some time.\n    writeLock = d.obtainLock(WRITE_LOCK_NAME);\n    \n    boolean success = false;\n    try {\n      directoryOrig = d;\n      directory = new LockValidatingDirectoryWrapper(d, writeLock);\n\n      analyzer = config.getAnalyzer();\n      mergeScheduler = config.getMergeScheduler();\n      mergeScheduler.initialize(infoStream, directoryOrig);\n      codec = config.getCodec();\n      OpenMode mode = config.getOpenMode();\n      final boolean indexExists;\n      final boolean create;\n      if (mode == OpenMode.CREATE) {\n        indexExists = DirectoryReader.indexExists(directory);\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        indexExists = true;\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        indexExists = DirectoryReader.indexExists(directory);\n        create = !indexExists;\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n\n      String[] files = directory.listAll();\n\n      // Set up our initial SegmentInfos:\n      IndexCommit commit = config.getIndexCommit();\n\n      // Set up our initial SegmentInfos:\n      StandardDirectoryReader reader;\n      if (commit == null) {\n        reader = null;\n      } else {\n        reader = commit.getReader();\n      }\n\n      if (create) {\n\n        if (config.getIndexCommit() != null) {\n          // We cannot both open from a commit point and create:\n          if (mode == OpenMode.CREATE) {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() with OpenMode.CREATE\");\n          } else {\n            throw new IllegalArgumentException(\"cannot use IndexWriterConfig.setIndexCommit() when index has no commit\");\n          }\n        }\n\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        final SegmentInfos sis = new SegmentInfos(config.getIndexCreatedVersionMajor());\n        if (indexExists) {\n          final SegmentInfos previous = SegmentInfos.readLatestCommit(directory);\n          sis.updateGenerationVersionAndCounter(previous);\n        }\n        segmentInfos = sis;\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changed();\n\n      } else if (reader != null) {\n        // Init from an existing already opened NRT or non-NRT reader:\n      \n        if (reader.directory() != commit.getDirectory()) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory as the IndexCommit\");\n        }\n\n        if (reader.directory() != directoryOrig) {\n          throw new IllegalArgumentException(\"IndexCommit's reader must have the same directory passed to IndexWriter\");\n        }\n\n        if (reader.segmentInfos.getLastGeneration() == 0) {  \n          // TODO: maybe we could allow this?  It's tricky...\n          throw new IllegalArgumentException(\"index must already have an initial commit to open from reader\");\n        }\n\n        // Must clone because we don't want the incoming NRT reader to \"see\" any changes this writer now makes:\n        segmentInfos = reader.segmentInfos.clone();\n\n        SegmentInfos lastCommit;\n        try {\n          lastCommit = SegmentInfos.readCommit(directoryOrig, segmentInfos.getSegmentsFileName());\n        } catch (IOException ioe) {\n          throw new IllegalArgumentException(\"the provided reader is stale: its prior commit file \\\"\" + segmentInfos.getSegmentsFileName() + \"\\\" is missing from index\");\n        }\n\n        if (reader.writer != null) {\n\n          // The old writer better be closed (we have the write lock now!):\n          assert reader.writer.closed;\n\n          // In case the old writer wrote further segments (which we are now dropping),\n          // update SIS metadata so we remain write-once:\n          segmentInfos.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n          lastCommit.updateGenerationVersionAndCounter(reader.writer.segmentInfos);\n        }\n\n        rollbackSegments = lastCommit.createBackupSegmentInfos();\n      } else {\n        // Init from either the latest commit point, or an explicit prior commit point:\n\n        String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n        if (lastSegmentsFile == null) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        }\n\n        // Do not use SegmentInfos.read(Directory) since the spooky\n        // retrying it does is not necessary here (we hold the write lock):\n        segmentInfos = SegmentInfos.readCommit(directoryOrig, lastSegmentsFile);\n\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directoryOrig) {\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory, expected=\" + directoryOrig + \", got=\" + commit.getDirectory());\n          }\n          \n          SegmentInfos oldInfos = SegmentInfos.readCommit(directoryOrig, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changed();\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n\n        rollbackSegments = segmentInfos.createBackupSegmentInfos();\n      }\n\n\n\n      commitUserData = new HashMap<>(segmentInfos.getUserData()).entrySet();\n\n      pendingNumDocs.set(segmentInfos.totalMaxDoc());\n\n      // start with previous field numbers, but new FieldInfos\n      // NOTE: this is correct even for an NRT reader because we'll pull FieldInfos even for the un-committed segments:\n      globalFieldNumberMap = getFieldNumberMap();\n\n      validateIndexSort();\n\n      config.getFlushPolicy().init(config);\n      bufferedUpdatesStream = new BufferedUpdatesStream(infoStream);\n      docWriter = new DocumentsWriter(flushNotifications, segmentInfos.getIndexCreatedVersionMajor(), pendingNumDocs,\n          enableTestPoints, this::newSegmentName,\n          config, directoryOrig, directory, globalFieldNumberMap);\n      readerPool = new ReaderPool(directory, directoryOrig, segmentInfos, globalFieldNumberMap,\n          bufferedUpdatesStream::getCompletedDelGen, infoStream, conf.getSoftDeletesField(), reader);\n      if (config.getReaderPooling()) {\n        readerPool.enableReaderPooling();\n      }\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n\n      // Sync'd is silly here, but IFD asserts we sync'd on the IW instance:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(files, directoryOrig, directory,\n                                       config.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this,\n                                       indexExists, reader != null);\n\n        // We incRef all files when we return an NRT reader from IW, so all files must exist even in the NRT case:\n        assert create || filesExist(segmentInfos);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changed();\n      }\n\n      if (reader != null) {\n        // We always assume we are carrying over incoming changes when opening from reader:\n        segmentInfos.changed();\n        changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create + \" reader=\" + reader);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        IOUtils.closeWhileHandlingException(writeLock);\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3af8c90c5e965a1a8011e827ab59de734c7dfb79","5091aa83309a6e03e5104286d08aff1d8e2b3a82"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"89697e7abc9807639c384eecf5a2a6eef1080426":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"b70042a8a492f7054d480ccdd2be9796510d4327":["c5e84aa7f651de6493590da495bcbe46d32cf038","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"7f4e54ed7cef46f86888b5fb547594f62160395c":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"cb769584d3433c13d4262b03a87433e9a8c5a307":["cf310a87bbc47f93a147695674e33b1234513a7f"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["2b97509e7e2489430edfe784e4411976e3c6c748"],"30e0912f3a3069b115cfea44ff612c44d6906386":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"027bee21e09164c9ee230395405076d1e0034b30":["cfc45818441587d8004ff1a119fb60ac9ecb9a14"],"98a04f56464afdffd4c430d6c47a0c868a38354e":["5faf65b6692f15cca0f87bf8666c87899afc619f","98b44240f64a2d6935543ff25faee750b29204eb"],"cf310a87bbc47f93a147695674e33b1234513a7f":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cfc45818441587d8004ff1a119fb60ac9ecb9a14":["0fcdcf196523675146a4df3193e91413533857ab"],"3306bdef6cff9218671c5972462d4ff115785dd0":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"b0267c69e2456a3477a1ad785723f2135da3117e":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["c02b804ab16489b95429791a2d8fb0e0728354d4","b470f36a9372c97283360b1304eacbde22df6c0d"],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460"],"0791b41f65aecff2e75db0c1ebf95d745a5ab1b1":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["d9a47902d6207303f5ed3e7aaca62ca33433af66"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["ee59f646cf24586a449cad77391a60a3ac8d8959","13eb667d6e65203cf0d6d783f25a6b410e8935ec"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"1e6105d385afcbf42689e171e9bcea48d0c9ff6c":["b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac"],"b470f36a9372c97283360b1304eacbde22df6c0d":["c02b804ab16489b95429791a2d8fb0e0728354d4","1e6105d385afcbf42689e171e9bcea48d0c9ff6c"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["7f4e54ed7cef46f86888b5fb547594f62160395c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3af8c90c5e965a1a8011e827ab59de734c7dfb79":["30e0912f3a3069b115cfea44ff612c44d6906386"],"13eb667d6e65203cf0d6d783f25a6b410e8935ec":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"f592209545c71895260367152601e9200399776d":["c5e84aa7f651de6493590da495bcbe46d32cf038","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["7af110b00ea8df9429309d83e38e0533d82e144f"],"7af110b00ea8df9429309d83e38e0533d82e144f":["4ce24aa081e44190692bbebc8aead342ad7060e8"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["cb769584d3433c13d4262b03a87433e9a8c5a307"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["027bee21e09164c9ee230395405076d1e0034b30"],"5a207d19eac354d649c3f0e2cce070017c78125e":["c02b804ab16489b95429791a2d8fb0e0728354d4","b1643a47ae20c901b799d4b469fd2fe6bb203bea"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"0ad30c6a479e764150a3316e57263319775f1df2":["5a207d19eac354d649c3f0e2cce070017c78125e","3d33e731a93d4b57e662ff094f64f94a745422d4"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"10005c6013abbd1102f2463cf95604d4c8774c99":["481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["5a207d19eac354d649c3f0e2cce070017c78125e","0ad30c6a479e764150a3316e57263319775f1df2"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"4ce24aa081e44190692bbebc8aead342ad7060e8":["5091aa83309a6e03e5104286d08aff1d8e2b3a82"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","5a207d19eac354d649c3f0e2cce070017c78125e"],"b06445ae1731e049327712db0454e5643ca9b7fe":["98a04f56464afdffd4c430d6c47a0c868a38354e","b0267c69e2456a3477a1ad785723f2135da3117e"],"2b97509e7e2489430edfe784e4411976e3c6c748":["618635065f043788c9e034f96ca5cd5cea1b4592"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["7f4e54ed7cef46f86888b5fb547594f62160395c"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"98b44240f64a2d6935543ff25faee750b29204eb":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5091aa83309a6e03e5104286d08aff1d8e2b3a82":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["4ce24aa081e44190692bbebc8aead342ad7060e8","7af110b00ea8df9429309d83e38e0533d82e144f"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["9b2af6b2c05418fb9df466c739ed5b3a153eadde"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"b1643a47ae20c901b799d4b469fd2fe6bb203bea":["b470f36a9372c97283360b1304eacbde22df6c0d"],"28288370235ed02234a64753cdbf0c6ec096304a":["31741cf1390044e38a2ec3127cf302ba841bfd75","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5a207d19eac354d649c3f0e2cce070017c78125e","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"618635065f043788c9e034f96ca5cd5cea1b4592":["b0267c69e2456a3477a1ad785723f2135da3117e"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["399d5903979ca52514d2bc7e3a362e1c45885c94","9d153abcf92dc5329d98571a8c3035df9bd80648"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["5a207d19eac354d649c3f0e2cce070017c78125e"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["89697e7abc9807639c384eecf5a2a6eef1080426"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"0fcdcf196523675146a4df3193e91413533857ab":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["13eb667d6e65203cf0d6d783f25a6b410e8935ec","3384e6013a93e4d11b7d75388693f8d0388602bf"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["28288370235ed02234a64753cdbf0c6ec096304a"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["5a207d19eac354d649c3f0e2cce070017c78125e","ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c","10005c6013abbd1102f2463cf95604d4c8774c99"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d08973aa47f2cf98a588293a53af4e948952ccfb","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"c5e84aa7f651de6493590da495bcbe46d32cf038":["3306bdef6cff9218671c5972462d4ff115785dd0"]},"commit2Childs":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["d97ba94eef1fc33c5451259a7aa2ac682646c1af","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["3306bdef6cff9218671c5972462d4ff115785dd0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["89697e7abc9807639c384eecf5a2a6eef1080426"],"89697e7abc9807639c384eecf5a2a6eef1080426":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"7f4e54ed7cef46f86888b5fb547594f62160395c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"cb769584d3433c13d4262b03a87433e9a8c5a307":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac"],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"30e0912f3a3069b115cfea44ff612c44d6906386":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"027bee21e09164c9ee230395405076d1e0034b30":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"98a04f56464afdffd4c430d6c47a0c868a38354e":["b0267c69e2456a3477a1ad785723f2135da3117e","b06445ae1731e049327712db0454e5643ca9b7fe"],"cf310a87bbc47f93a147695674e33b1234513a7f":["cb769584d3433c13d4262b03a87433e9a8c5a307"],"cfc45818441587d8004ff1a119fb60ac9ecb9a14":["027bee21e09164c9ee230395405076d1e0034b30"],"3306bdef6cff9218671c5972462d4ff115785dd0":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","618635065f043788c9e034f96ca5cd5cea1b4592"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["dd75f58072bba84066e89d61bd7028de1bd5b632"],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"0791b41f65aecff2e75db0c1ebf95d745a5ab1b1":["7f4e54ed7cef46f86888b5fb547594f62160395c"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["3384e6013a93e4d11b7d75388693f8d0388602bf"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac":["1e6105d385afcbf42689e171e9bcea48d0c9ff6c"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["6bfe104fc023fadc9e709f8d17403d2cc61133fe","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","5a207d19eac354d649c3f0e2cce070017c78125e"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["9b2af6b2c05418fb9df466c739ed5b3a153eadde"],"1e6105d385afcbf42689e171e9bcea48d0c9ff6c":["b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1643a47ae20c901b799d4b469fd2fe6bb203bea"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"3af8c90c5e965a1a8011e827ab59de734c7dfb79":["37a0f60745e53927c4c876cfe5b5a58170f0646c","5091aa83309a6e03e5104286d08aff1d8e2b3a82"],"13eb667d6e65203cf0d6d783f25a6b410e8935ec":["d9a47902d6207303f5ed3e7aaca62ca33433af66","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"f592209545c71895260367152601e9200399776d":[],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["0fcdcf196523675146a4df3193e91413533857ab"],"7af110b00ea8df9429309d83e38e0533d82e144f":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["d9a47902d6207303f5ed3e7aaca62ca33433af66","13eb667d6e65203cf0d6d783f25a6b410e8935ec"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"5a207d19eac354d649c3f0e2cce070017c78125e":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","dd75f58072bba84066e89d61bd7028de1bd5b632","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","28288370235ed02234a64753cdbf0c6ec096304a"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4ce24aa081e44190692bbebc8aead342ad7060e8":["7af110b00ea8df9429309d83e38e0533d82e144f","31d4861802ca404d78ca1d15f4550eec415b9199"],"dd75f58072bba84066e89d61bd7028de1bd5b632":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"2b97509e7e2489430edfe784e4411976e3c6c748":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["30e0912f3a3069b115cfea44ff612c44d6906386","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"98b44240f64a2d6935543ff25faee750b29204eb":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"5091aa83309a6e03e5104286d08aff1d8e2b3a82":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4ce24aa081e44190692bbebc8aead342ad7060e8"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"b1643a47ae20c901b799d4b469fd2fe6bb203bea":["5a207d19eac354d649c3f0e2cce070017c78125e"],"28288370235ed02234a64753cdbf0c6ec096304a":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"481f7e7bbb6cd3648a79ea3343aacbdfb04f7b0c":["10005c6013abbd1102f2463cf95604d4c8774c99","d08973aa47f2cf98a588293a53af4e948952ccfb"],"618635065f043788c9e034f96ca5cd5cea1b4592":["2b97509e7e2489430edfe784e4411976e3c6c748"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["98a04f56464afdffd4c430d6c47a0c868a38354e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","98b44240f64a2d6935543ff25faee750b29204eb"],"0fcdcf196523675146a4df3193e91413533857ab":["cfc45818441587d8004ff1a119fb60ac9ecb9a14"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["d60c1bb96a28a26d197c36299f7b6c9c5da617a1","aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["b70042a8a492f7054d480ccdd2be9796510d4327","cf310a87bbc47f93a147695674e33b1234513a7f","f592209545c71895260367152601e9200399776d"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["b0567940defa1ea6eb8a039d9d36e3682063f8a4","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"c5e84aa7f651de6493590da495bcbe46d32cf038":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","fe33227f6805edab2036cbb80645cc4e2d1fa424","f592209545c71895260367152601e9200399776d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dd75f58072bba84066e89d61bd7028de1bd5b632","b06445ae1731e049327712db0454e5643ca9b7fe","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}