{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","commits":[{"id":"a752b89ed4b8bfa40e21a23601fbc376340bb3f4","date":1329246954,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,String,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    String leaderCoreName = leaderCNodeProps.getCoreName();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      CommonsHttpSolrServer server = new CommonsHttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(30000);\n      server.setSoTimeout(30000);\n      PrepRecovery prepCmd = new PrepRecovery();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(nodeName);\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      \n      server.request(prepCmd);\n      server.shutdown();\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure fore=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, String shardZkNodeName, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    String leaderCoreName = leaderCNodeProps.getCoreName();\n    \n    log.info(\"Attempt to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      CommonsHttpSolrServer server = new CommonsHttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(30000);\n      server.setSoTimeout(30000);\n      PrepRecovery prepCmd = new PrepRecovery();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(nodeName);\n      prepCmd.setCoreNodeName(shardZkNodeName);\n      \n      server.request(prepCmd);\n      server.shutdown();\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure fore=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c850a9faa7f2268d78aa6e8a611d281658781a99","date":1329403874,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    String leaderCoreName = leaderCNodeProps.getCoreName();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      CommonsHttpSolrServer server = new CommonsHttpSolrServer(leaderBaseUrl);\n      server.setConnectionTimeout(30000);\n      server.setSoTimeout(30000);\n      PrepRecovery prepCmd = new PrepRecovery();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(nodeName);\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      \n      server.request(prepCmd);\n      server.shutdown();\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure fore=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n    // start buffer updates to tran log\n    // and do recovery - either replay via realtime get (eventually)\n    // or full index replication\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1e5b576a150f260cba5c0287b3764e42cab2fe7","date":1337700347,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (close) retries = INTERRUPTED; \n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2425308ebcd91b538a601df94ae1551ccaab2bb","date":1340702883,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl + \"replication\");\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef9583322dbc8650e3cd32d936c0b3e31eefadba","date":1344482424,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". Core:\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". Core:\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40c478fcb4e093ac431407a8db2896ac9c867f33","date":1344540116,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". Core:\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". Core:\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making sure force=true does not download files we already have\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b7dcf962e7234de952e43c4e78bb27dea75b294","date":1362159634,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, false);\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, true); // TODO: look into making force=true not download files we already have?\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0","date":1371567556,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n\n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    \n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, false);\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","6c94d2661bc1c14426980ec7882e951fdcff08d0","e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":null,"sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, false);\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66c64e8cfded6a585100e6430238faaf416f3fea":["40c478fcb4e093ac431407a8db2896ac9c867f33"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3b7dcf962e7234de952e43c4e78bb27dea75b294","71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["c850a9faa7f2268d78aa6e8a611d281658781a99","6b834dd353486678973f4157b3ba402ac3a7ca88"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["c850a9faa7f2268d78aa6e8a611d281658781a99"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["c7869f64c874ebf7f317d22c00baf2b6857797a6","66c64e8cfded6a585100e6430238faaf416f3fea"],"fa64435b5902ce266c23755a4a00691a3285dab8":["66c64e8cfded6a585100e6430238faaf416f3fea"],"a752b89ed4b8bfa40e21a23601fbc376340bb3f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c850a9faa7f2268d78aa6e8a611d281658781a99":["a752b89ed4b8bfa40e21a23601fbc376340bb3f4"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","66c64e8cfded6a585100e6430238faaf416f3fea"],"ef9583322dbc8650e3cd32d936c0b3e31eefadba":["f2425308ebcd91b538a601df94ae1551ccaab2bb"],"f2425308ebcd91b538a601df94ae1551ccaab2bb":["e1e5b576a150f260cba5c0287b3764e42cab2fe7"],"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0":["3b7dcf962e7234de952e43c4e78bb27dea75b294"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"40c478fcb4e093ac431407a8db2896ac9c867f33":["ef9583322dbc8650e3cd32d936c0b3e31eefadba"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","40c478fcb4e093ac431407a8db2896ac9c867f33"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e1e5b576a150f260cba5c0287b3764e42cab2fe7","f2425308ebcd91b538a601df94ae1551ccaab2bb"],"e1e5b576a150f260cba5c0287b3764e42cab2fe7":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["6b834dd353486678973f4157b3ba402ac3a7ca88","e1e5b576a150f260cba5c0287b3764e42cab2fe7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["f2425308ebcd91b538a601df94ae1551ccaab2bb","ef9583322dbc8650e3cd32d936c0b3e31eefadba"],"3b7dcf962e7234de952e43c4e78bb27dea75b294":["a6378064655e76cd7b908b1cab4ce425b384b508"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["d6f074e73200c07d54f242d3880a8da5a35ff97b","40c478fcb4e093ac431407a8db2896ac9c867f33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"]},"commit2Childs":{"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","fa64435b5902ce266c23755a4a00691a3285dab8","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e1e5b576a150f260cba5c0287b3764e42cab2fe7","3599646b4d4c346cf74d334813488b8b337b5bf5"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a752b89ed4b8bfa40e21a23601fbc376340bb3f4":["c850a9faa7f2268d78aa6e8a611d281658781a99"],"c850a9faa7f2268d78aa6e8a611d281658781a99":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"ef9583322dbc8650e3cd32d936c0b3e31eefadba":["40c478fcb4e093ac431407a8db2896ac9c867f33","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"f2425308ebcd91b538a601df94ae1551ccaab2bb":["ef9583322dbc8650e3cd32d936c0b3e31eefadba","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"40c478fcb4e093ac431407a8db2896ac9c867f33":["66c64e8cfded6a585100e6430238faaf416f3fea","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"a6378064655e76cd7b908b1cab4ce425b384b508":["3b7dcf962e7234de952e43c4e78bb27dea75b294"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a752b89ed4b8bfa40e21a23601fbc376340bb3f4"],"e1e5b576a150f260cba5c0287b3764e42cab2fe7":["f2425308ebcd91b538a601df94ae1551ccaab2bb","fe33227f6805edab2036cbb80645cc4e2d1fa424","3599646b4d4c346cf74d334813488b8b337b5bf5"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"3b7dcf962e7234de952e43c4e78bb27dea75b294":["37a0f60745e53927c4c876cfe5b5a58170f0646c","71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","3599646b4d4c346cf74d334813488b8b337b5bf5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}