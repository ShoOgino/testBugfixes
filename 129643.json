{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"/dev/null","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"/dev/null","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45","date":1492172132,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dcb0432bcb41451b41e9aaaabe99f5d208258fe","date":1493203108,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDataDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDataDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":4,"author":"iverase","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#sort(int).mjava","sourceNew":null,"sourceOld":"  private PointWriter sort(int dim) throws IOException {\n    assert dim >= 0 && dim < numDataDims;\n\n    if (heapPointWriter != null) {\n\n      assert tempInput == null;\n\n      // We never spilled the incoming points to disk, so now we sort in heap:\n      HeapPointWriter sorted;\n\n      if (dim == 0) {\n        // First dim can re-use the current heap writer\n        sorted = heapPointWriter;\n      } else {\n        // Subsequent dims need a private copy\n        sorted = new HeapPointWriter((int) pointCount, (int) pointCount, packedBytesLength, longOrds, singleValuePerDoc);\n        sorted.copyFrom(heapPointWriter);\n      }\n\n      //long t0 = System.nanoTime();\n      sortHeapPointWriter(sorted, dim);\n      //long t1 = System.nanoTime();\n      //System.out.println(\"BKD: sort took \" + ((t1-t0)/1000000.0) + \" msec\");\n\n      sorted.close();\n      return sorted;\n    } else {\n\n      // Offline sort:\n      assert tempInput != null;\n\n      final int offset = bytesPerDim * dim;\n\n      Comparator<BytesRef> cmp;\n      if (dim == numDataDims - 1) {\n        // in that case the bytes for the dimension and for the doc id are contiguous,\n        // so we don't need a branch\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          }\n        };\n      } else {\n        cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n          @Override\n          protected int byteAt(BytesRef ref, int i) {\n            if (i < bytesPerDim) {\n              return ref.bytes[ref.offset + offset + i] & 0xff;\n            } else {\n              return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n            }\n          }\n        };\n      }\n\n      OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n            return new ByteSequencesWriter(out) {\n              @Override\n              public void write(byte[] bytes, int off, int len) throws IOException {\n                assert len == bytesPerDoc: \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n                out.writeBytes(bytes, off, len);\n              }\n            };\n          }\n\n          /** We write/read fixed-byte-width file that {@link OfflinePointReader} can read. */\n          @Override\n          protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n            return new ByteSequencesReader(in, name) {\n              final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n              @Override\n              public BytesRef next() throws IOException {\n                if (in.getFilePointer() >= end) {\n                  return null;\n                }\n                in.readBytes(scratch.bytes, 0, bytesPerDoc);\n                return scratch;\n              }\n            };\n          }\n        };\n\n      String name = sorter.sort(tempInput.getName());\n\n      return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"f6652c943595e92c187ee904c382863013eae28f":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["62e7e8f89cb6b0283f3f5d6c0945453b73f09d45"],"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9856095f7afb5a607bf5e65077615ed91273508c","62e7e8f89cb6b0283f3f5d6c0945453b73f09d45"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["e9017cf144952056066919f1ebc7897ff9bd71b1","f6652c943595e92c187ee904c382863013eae28f"],"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}