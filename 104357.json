{"path":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","commits":[{"id":"6627e96da3f5efc85314b83db335fea8518ad464","date":1117908960,"type":0,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    if (SegmentInfos.readCurrentVersion(directory) != segmentInfos.getVersion()) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2285750e6d83bf7de3809e562fcb0d2e5675b97e","1b54a9bc667895a2095a886184bf69a3179e63df","537382020d6797489b93fa8aeb62495d5018b0ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2285750e6d83bf7de3809e562fcb0d2e5675b97e","date":1135305503,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    synchronized (directory) {                 // in- & inter-process sync\n      Lock commitLock=directory.makeLock(IndexWriter.COMMIT_LOCK_NAME);\n      \n      boolean locked=false;\n      \n      try {\n         locked=commitLock.obtain(IndexWriter.COMMIT_LOCK_TIMEOUT);\n         \n         return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n      } finally {\n        if (locked) {\n          commitLock.release();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    if (SegmentInfos.readCurrentVersion(directory) != segmentInfos.getVersion()) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["6627e96da3f5efc85314b83db335fea8518ad464"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12d40284fd9481f79444bc63bc5d13847caddd3d","date":1149902602,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    synchronized (directory) {                 // in- & inter-process sync\n      Lock commitLock=directory.makeLock(IndexWriter.COMMIT_LOCK_NAME);\n\n      boolean locked=false;\n\n      try {\n         locked=commitLock.obtain(IndexWriter.COMMIT_LOCK_TIMEOUT);\n\n         return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n      } finally {\n        if (locked) {\n          commitLock.release();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    synchronized (directory) {                 // in- & inter-process sync\n      Lock commitLock=directory.makeLock(IndexWriter.COMMIT_LOCK_NAME);\n      \n      boolean locked=false;\n      \n      try {\n         locked=commitLock.obtain(IndexWriter.COMMIT_LOCK_TIMEOUT);\n         \n         return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n      } finally {\n        if (locked) {\n          commitLock.release();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    synchronized (directory) {                 // in- & inter-process sync\n      Lock commitLock=directory.makeLock(IndexWriter.COMMIT_LOCK_NAME);\n\n      boolean locked=false;\n\n      try {\n         locked=commitLock.obtain(IndexWriter.COMMIT_LOCK_TIMEOUT);\n\n         return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n      } finally {\n        if (locked) {\n          commitLock.release();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws IOException\n   */\n  public boolean isCurrent() throws IOException {\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","bugFix":["6627e96da3f5efc85314b83db335fea8518ad464"],"bugIntro":["537382020d6797489b93fa8aeb62495d5018b0ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"328c1568e471f0c6eaa49ec00334ca59e573710f","date":1173897963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    ensureOpen();\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b56e885a22afb645ce1aa922624ff41d8630930","date":1180437969,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  See the\n   * description of the <a href=\"IndexWriter.html#autoCommit\"><code>autoCommit</code></a>\n   * flag which controls when the {@link IndexWriter}\n   * actually commits changes to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    ensureOpen();\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader still works on a current version of the index.\n   * If this is not the case you will need to re-open the IndexReader to\n   * make sure you see the latest changes made to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    ensureOpen();\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","bugFix":null,"bugIntro":["537382020d6797489b93fa8aeb62495d5018b0ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"125b5699f11b58d9be0820c6ce8b1648812902e8","date":1190273227,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  See the\n   * description of the <a href=\"IndexWriter.html#autoCommit\"><code>autoCommit</code></a>\n   * flag which controls when the {@link IndexWriter}\n   * actually commits changes to the index.\n   * \n   * <p>\n   * Not implemented in the IndexReader base class.\n   * </p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  See the\n   * description of the <a href=\"IndexWriter.html#autoCommit\"><code>autoCommit</code></a>\n   * flag which controls when the {@link IndexWriter}\n   * actually commits changes to the index.\n   * \n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    ensureOpen();\n    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();\n  }\n\n","bugFix":null,"bugIntro":["537382020d6797489b93fa8aeb62495d5018b0ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87c966e9308847938a7c905c2e46a56d8df788b8","date":1255035452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  Changes must\n   * be committed using  {@link IndexWriter#commit} to be\n   * visible to readers.\n   * \n   * <p>\n   * Not implemented in the IndexReader base class.\n   * </p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  See the\n   * description of the <a href=\"IndexWriter.html#autoCommit\"><code>autoCommit</code></a>\n   * flag which controls when the {@link IndexWriter}\n   * actually commits changes to the index.\n   * \n   * <p>\n   * Not implemented in the IndexReader base class.\n   * </p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","bugFix":null,"bugIntro":["537382020d6797489b93fa8aeb62495d5018b0ba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"537382020d6797489b93fa8aeb62495d5018b0ba","date":1255718738,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether any new changes have occurred to the\n   * index since this reader was opened.\n   *\n   * <p>If this reader is based on a Directory (ie, was\n   * created by calling {@link #open}, or {@link #reopen} on\n   * a reader based on a Directory), then this method checks\n   * if any further commits (see {@link IndexWriter#commit}\n   * have occurred in that directory).</p>\n   *\n   * <p>If instead this reader is a near real-time reader\n   * (ie, obtained by a call to {@link\n   * IndexWriter#getReader}, or by calling {@link #reopen}\n   * on a near real-time reader), then this method checks if\n   * either a new commmit has occurred, or any new\n   * uncommitted changes have taken place via the writer.\n   * Note that even if the writer has only performed\n   * merging, this method will still return false.</p>\n   *\n   * <p>In any event, if this returns false, you should call\n   * {@link #reopen} to get a new reader that sees the\n   * changes.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException           if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","sourceOld":"  /**\n   * Check whether this IndexReader is still using the\n   * current (i.e., most recently committed) version of the\n   * index.  If a writer has committed any changes to the\n   * index since this reader was opened, this will return\n   * <code>false</code>, in which case you must open a new\n   * IndexReader in order to see the changes.  Changes must\n   * be committed using  {@link IndexWriter#commit} to be\n   * visible to readers.\n   * \n   * <p>\n   * Not implemented in the IndexReader base class.\n   * </p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","bugFix":["125b5699f11b58d9be0820c6ce8b1648812902e8","1b54a9bc667895a2095a886184bf69a3179e63df","87c966e9308847938a7c905c2e46a56d8df788b8","6627e96da3f5efc85314b83db335fea8518ad464","1b56e885a22afb645ce1aa922624ff41d8630930"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#isCurrent().mjava","sourceNew":"  /**\n   * Check whether any new changes have occurred to the\n   * index since this reader was opened.\n   *\n   * <p>If this reader is based on a Directory (ie, was\n   * created by calling {@link #open}, or {@link #reopen} on\n   * a reader based on a Directory), then this method checks\n   * if any further commits (see {@link IndexWriter#commit}\n   * have occurred in that directory).</p>\n   *\n   * <p>If instead this reader is a near real-time reader\n   * (ie, obtained by a call to {@link\n   * IndexWriter#getReader}, or by calling {@link #reopen}\n   * on a near real-time reader), then this method checks if\n   * either a new commmit has occurred, or any new\n   * uncommitted changes have taken place via the writer.\n   * Note that even if the writer has only performed\n   * merging, this method will still return false.</p>\n   *\n   * <p>In any event, if this returns false, you should call\n   * {@link #reopen} to get a new reader that sees the\n   * changes.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException           if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","sourceOld":"  /**\n   * Check whether any new changes have occurred to the\n   * index since this reader was opened.\n   *\n   * <p>If this reader is based on a Directory (ie, was\n   * created by calling {@link #open}, or {@link #reopen} on\n   * a reader based on a Directory), then this method checks\n   * if any further commits (see {@link IndexWriter#commit}\n   * have occurred in that directory).</p>\n   *\n   * <p>If instead this reader is a near real-time reader\n   * (ie, obtained by a call to {@link\n   * IndexWriter#getReader}, or by calling {@link #reopen}\n   * on a near real-time reader), then this method checks if\n   * either a new commmit has occurred, or any new\n   * uncommitted changes have taken place via the writer.\n   * Note that even if the writer has only performed\n   * merging, this method will still return false.</p>\n   *\n   * <p>In any event, if this returns false, you should call\n   * {@link #reopen} to get a new reader that sees the\n   * changes.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException           if there is a low-level IO error\n   * @throws UnsupportedOperationException unless overridden in subclass\n   */\n  public boolean isCurrent() throws CorruptIndexException, IOException {\n    throw new UnsupportedOperationException(\"This reader does not support this method.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"125b5699f11b58d9be0820c6ce8b1648812902e8":["1b56e885a22afb645ce1aa922624ff41d8630930"],"2285750e6d83bf7de3809e562fcb0d2e5675b97e":["6627e96da3f5efc85314b83db335fea8518ad464"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["1b54a9bc667895a2095a886184bf69a3179e63df"],"1b54a9bc667895a2095a886184bf69a3179e63df":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"537382020d6797489b93fa8aeb62495d5018b0ba":["87c966e9308847938a7c905c2e46a56d8df788b8"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["2285750e6d83bf7de3809e562fcb0d2e5675b97e"],"1b56e885a22afb645ce1aa922624ff41d8630930":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"6627e96da3f5efc85314b83db335fea8518ad464":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"87c966e9308847938a7c905c2e46a56d8df788b8":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["537382020d6797489b93fa8aeb62495d5018b0ba"]},"commit2Childs":{"125b5699f11b58d9be0820c6ce8b1648812902e8":["87c966e9308847938a7c905c2e46a56d8df788b8"],"2285750e6d83bf7de3809e562fcb0d2e5675b97e":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["1b56e885a22afb645ce1aa922624ff41d8630930"],"1b54a9bc667895a2095a886184bf69a3179e63df":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"537382020d6797489b93fa8aeb62495d5018b0ba":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"1b56e885a22afb645ce1aa922624ff41d8630930":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["1b54a9bc667895a2095a886184bf69a3179e63df"],"6627e96da3f5efc85314b83db335fea8518ad464":["2285750e6d83bf7de3809e562fcb0d2e5675b97e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6627e96da3f5efc85314b83db335fea8518ad464"],"87c966e9308847938a7c905c2e46a56d8df788b8":["537382020d6797489b93fa8aeb62495d5018b0ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}