{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22b3128eea8c61f8f1f387dac6b3e9504bc8036e","date":1337625491,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          System.out.println(\"drop all del seg=\" + info.name);\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"034b8e37ade96af2cef0172233d24b652b432f99","date":1337636665,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          System.out.println(\"drop all del seg=\" + info.name);\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes || result.anyNumericDVUpdates) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe","date":1381909398,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes || result.anyNumericDVUpdates) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletesAndUpdates().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#applyAllDeletes().mjava","sourceNew":"  final synchronized void applyAllDeletesAndUpdates() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedUpdatesStream.ApplyDeletesResult result;\n    result = bufferedUpdatesStream.applyDeletesAndUpdates(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentCommitInfo info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedUpdatesStream.prune(segmentInfos);\n  }\n\n","sourceOld":"  final synchronized void applyAllDeletes() throws IOException {\n    flushDeletesCount.incrementAndGet();\n    final BufferedDeletesStream.ApplyDeletesResult result;\n    result = bufferedDeletesStream.applyDeletes(readerPool, segmentInfos.asList());\n    if (result.anyDeletes) {\n      checkpoint();\n    }\n    if (!keepFullyDeletedSegments && result.allDeleted != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n      }\n      for (SegmentInfoPerCommit info : result.allDeleted) {\n        // If a merge has already registered for this\n        // segment, we leave it in the readerPool; the\n        // merge will skip merging it and will then drop\n        // it once it's done:\n        if (!mergingSegments.contains(info)) {\n          segmentInfos.remove(info);\n          readerPool.drop(info);\n        }\n      }\n      checkpoint();\n    }\n    bufferedDeletesStream.prune(segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":["e4f3b0a30c9d521b86f768348f832af93505b4eb"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9d153abcf92dc5329d98571a8c3035df9bd80648"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["034b8e37ade96af2cef0172233d24b652b432f99"],"22b3128eea8c61f8f1f387dac6b3e9504bc8036e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"034b8e37ade96af2cef0172233d24b652b432f99":["22b3128eea8c61f8f1f387dac6b3e9504bc8036e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","22b3128eea8c61f8f1f387dac6b3e9504bc8036e"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"22b3128eea8c61f8f1f387dac6b3e9504bc8036e":["034b8e37ade96af2cef0172233d24b652b432f99"],"034b8e37ade96af2cef0172233d24b652b432f99":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}