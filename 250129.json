{"path":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","commits":[{"id":"86a0a50d2d14aaee1e635bbec914468551f7f9a2","date":1482234306,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,PointsWriter).mjava","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":"  public void flush(SegmentWriteState state, PointsWriter writer) throws IOException {\n    PointValues values = new MutablePointValues() {\n\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    PointsReader reader = new PointsReader() {\n      \n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n      \n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n\n    writer.writeField(fieldInfo, reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"/dev/null","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dca67e06c96e95a8d9ef07418b6299bfd981523b","date":1484639518,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDataDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumIndexDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PointValuesWriter#flush(SegmentWriteState,Sorter.DocMap,PointsWriter).mjava","sourceNew":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumIndexDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","sourceOld":"  public void flush(SegmentWriteState state, Sorter.DocMap sortMap, PointsWriter writer) throws IOException {\n    PointValues points = new MutablePointValues() {\n      final int[] ords = new int[numPoints];\n      {\n        for (int i = 0; i < numPoints; ++i) {\n          ords[i] = i;\n        }\n      }\n\n      @Override\n      public void intersect(IntersectVisitor visitor) throws IOException {\n        final BytesRef scratch = new BytesRef();\n        final byte[] packedValue = new byte[packedBytesLength];\n        for(int i=0;i<numPoints;i++) {\n          getValue(i, scratch);\n          assert scratch.length == packedValue.length;\n          System.arraycopy(scratch.bytes, scratch.offset, packedValue, 0, packedBytesLength);\n          visitor.visit(getDocID(i), packedValue);\n        }\n      }\n\n      @Override\n      public long estimatePointCount(IntersectVisitor visitor) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMinPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public byte[] getMaxPackedValue() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumDataDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getNumIndexDimensions() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public int getBytesPerDimension() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long size() {\n        return numPoints;\n      }\n\n      @Override\n      public int getDocCount() {\n        return numDocs;\n      }\n\n      @Override\n      public void swap(int i, int j) {\n        int tmp = ords[i];\n        ords[i] = ords[j];\n        ords[j] = tmp;\n      }\n\n      @Override\n      public int getDocID(int i) {\n        return docIDs[ords[i]];\n      }\n\n      @Override\n      public void getValue(int i, BytesRef packedValue) {\n        final long offset = (long) packedBytesLength * ords[i];\n        packedValue.length = packedBytesLength;\n        bytes.setRawBytesRef(packedValue, offset);\n      }\n\n      @Override\n      public byte getByteAt(int i, int k) {\n        final long offset = (long) packedBytesLength * ords[i] + k;\n        return bytes.readByte(offset);\n      }\n    };\n\n    final PointValues values;\n    if (sortMap == null) {\n      values = points;\n    } else {\n      values = new MutableSortingPointValues((MutablePointValues) points, sortMap);\n    }\n    PointsReader reader = new PointsReader() {\n      @Override\n      public PointValues getValues(String fieldName) {\n        if (fieldName.equals(fieldInfo.name) == false) {\n          throw new IllegalArgumentException(\"fieldName must be the same\");\n        }\n        return values;\n      }\n\n      @Override\n      public void checkIntegrity() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public long ramBytesUsed() {\n        return 0L;\n      }\n\n      @Override\n      public void close() {\n      }\n    };\n    writer.writeField(fieldInfo, reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["dca67e06c96e95a8d9ef07418b6299bfd981523b"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"302d34f2c66e8d489ee13078305c330cbf67b226":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","dca67e06c96e95a8d9ef07418b6299bfd981523b"]},"commit2Childs":{"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["302d34f2c66e8d489ee13078305c330cbf67b226"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["f6652c943595e92c187ee904c382863013eae28f","302d34f2c66e8d489ee13078305c330cbf67b226"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","dca67e06c96e95a8d9ef07418b6299bfd981523b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"302d34f2c66e8d489ee13078305c330cbf67b226":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}