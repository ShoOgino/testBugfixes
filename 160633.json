{"path":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","commits":[{"id":"136796946c32863f11b97ebec6b4091cdfe3a20b","date":1468862468,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // TODO: fq testing blocked by SOLR-9308\n    //\n    // // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = null;                                           // TODO: replace this...\n    // final Integer FQ_MAX = usually() ? null : random().nextInt();       //       ... with this\n    // if (null != FQ_MAX) {\n    //   params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    // }\n    // TODO: END\n    \n    final Set<FlValidator> validators = new HashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new HashSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new HashSet<>(actual.getFieldNames());\n        assertEquals(\"More actual fields then expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["76b65cf789129cacd84e977b8f1538aec29e0281"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76b65cf789129cacd84e977b8f1538aec29e0281","date":1470165799,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new HashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new HashSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new HashSet<>(actual.getFieldNames());\n        assertEquals(\"More actual fields then expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // TODO: fq testing blocked by SOLR-9308\n    //\n    // // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = null;                                           // TODO: replace this...\n    // final Integer FQ_MAX = usually() ? null : random().nextInt();       //       ... with this\n    // if (null != FQ_MAX) {\n    //   params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    // }\n    // TODO: END\n    \n    final Set<FlValidator> validators = new HashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new HashSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new HashSet<>(actual.getFieldNames());\n        assertEquals(\"More actual fields then expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":["136796946c32863f11b97ebec6b4091cdfe3a20b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbfb6ddad2ec9fa9128265741535450c3cbc4344","date":1470329280,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n\n    // HACK: [subquery] expects this to be top level params\n    params.add(SubQueryValidator.SUBQ_KEY + \".q\",\n               \"{!field f=\" + SubQueryValidator.SUBQ_FIELD + \" v=$row.\" + SubQueryValidator.SUBQ_FIELD + \"}\");\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new HashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new HashSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new HashSet<>(actual.getFieldNames());\n        assertEquals(\"More actual fields then expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3237bc9583fd899fcf68bae4cc834095f5c911bf","date":1470710919,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n\n    // HACK: [subquery] expects this to be top level params\n    params.add(SubQueryValidator.SUBQ_KEY + \".q\",\n               \"{!field f=\" + SubQueryValidator.SUBQ_FIELD + \" v=$row.\" + SubQueryValidator.SUBQ_FIELD + \"}\");\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bca25eefa1f2205e2b0ef713701dc3a0fecd702","date":1470810578,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n\n    // HACK: [subquery] expects this to be top level params\n    params.add(SubQueryValidator.SUBQ_KEY + \".q\",\n               \"{!field f=\" + SubQueryValidator.SUBQ_FIELD + \" v=$row.\" + SubQueryValidator.SUBQ_FIELD + \"}\");\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // TODO: fq testing blocked by SOLR-9308\n    //\n    // // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = null;                                           // TODO: replace this...\n    // final Integer FQ_MAX = usually() ? null : random().nextInt();       //       ... with this\n    // if (null != FQ_MAX) {\n    //   params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    // }\n    // TODO: END\n    \n    final Set<FlValidator> validators = new HashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addFlParams(validators, params);\n    \n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = Integer.parseInt(actual.getFirstValue(\"id\").toString());\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new HashSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new HashSet<>(actual.getFieldNames());\n        assertEquals(\"More actual fields then expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18e7cf5eab4be20c96aa36554daa39b53f43cf6e","date":1490632275,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"febf4fa8feff6bbc932c1b388cbd758a3e6697f7","date":1490873944,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma seperated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c342e04e879b5c549539944338f5ec0ff3000f3","date":1539630497,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in its own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in it's own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa4f44656c8081bbc63325a83abdb025eafd5a2b","date":1543200469,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#assertRTG(SolrInputDocument[],int[]).mjava","sourceNew":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    validators.add(ROOT_VALIDATOR); // always added in a nested schema, with the same value as id\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in its own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Does one or more RTG request for the specified docIds with a randomized fl &amp; fq params, asserting\n   * that the returned document (if any) makes sense given the expected SolrInputDocuments\n   */\n  private void assertRTG(final SolrInputDocument[] knownDocs, final int[] docIds) throws IOException, SolrServerException {\n    final SolrClient client = getRandClient(random());\n    // NOTE: not using SolrClient.getById or getByIds because we want to force choice of \"id\" vs \"ids\" params\n    final ModifiableSolrParams params = params(\"qt\",\"/get\");\n    \n    // random fq -- nothing fancy, secondary concern for our test\n    final Integer FQ_MAX = usually() ? null : random().nextInt();\n    if (null != FQ_MAX) {\n      params.add(\"fq\", \"aaa_i:[* TO \" + FQ_MAX + \"]\");\n    }\n    \n    final Set<FlValidator> validators = new LinkedHashSet<>();\n    validators.add(ID_VALIDATOR); // always include id so we can be confident which doc we're looking at\n    addRandomFlValidators(random(), validators);\n    FlValidator.addParams(validators, params);\n\n    final List<String> idsToRequest = new ArrayList<>(docIds.length);\n    final List<SolrInputDocument> docsToExpect = new ArrayList<>(docIds.length);\n    for (int docId : docIds) {\n      // every docId will be included in the request\n      idsToRequest.add(\"\" + docId);\n      \n      // only docs that should actually exist and match our (optional) filter will be expected in response\n      if (null != knownDocs[docId]) {\n        Integer filterVal = (Integer) knownDocs[docId].getFieldValue(\"aaa_i\");\n        if (null == FQ_MAX || ((null != filterVal) && filterVal.intValue() <= FQ_MAX.intValue())) {\n          docsToExpect.add(knownDocs[docId]);\n        }\n      }\n    }\n\n    // even w/only 1 docId requested, the response format can vary depending on how we request it\n    final boolean askForList = random().nextBoolean() || (1 != idsToRequest.size());\n    if (askForList) {\n      if (1 == idsToRequest.size()) {\n        // have to be careful not to try to use \"multi\" 'id' params with only 1 docId\n        // with a single docId, the only way to ask for a list is with the \"ids\" param\n        params.add(\"ids\", idsToRequest.get(0));\n      } else {\n        if (random().nextBoolean()) {\n          // each id in its own param\n          for (String id : idsToRequest) {\n            params.add(\"id\",id);\n          }\n        } else {\n          // add one or more comma separated ids params\n          params.add(buildCommaSepParams(random(), \"ids\", idsToRequest));\n        }\n      }\n    } else {\n      assert 1 == idsToRequest.size();\n      params.add(\"id\",idsToRequest.get(0));\n    }\n    \n    final QueryResponse rsp = client.query(params);\n    assertNotNull(params.toString(), rsp);\n\n    final SolrDocumentList docs = getDocsFromRTGResponse(askForList, rsp);\n    assertNotNull(params + \" => \" + rsp, docs);\n    \n    assertEquals(\"num docs mismatch: \" + params + \" => \" + docsToExpect + \" vs \" + docs,\n                 docsToExpect.size(), docs.size());\n    \n    // NOTE: RTG makes no garuntees about the order docs will be returned in when multi requested\n    for (SolrDocument actual : docs) {\n      try {\n        int actualId = assertParseInt(\"id\", actual.getFirstValue(\"id\"));\n        final SolrInputDocument expected = knownDocs[actualId];\n        assertNotNull(\"expected null doc but RTG returned: \" + actual, expected);\n        \n        Set<String> expectedFieldNames = new TreeSet<>();\n        for (FlValidator v : validators) {\n          expectedFieldNames.addAll(v.assertRTGResults(validators, expected, actual));\n        }\n        // ensure only expected field names are in the actual document\n        Set<String> actualFieldNames = new TreeSet<>(actual.getFieldNames());\n        assertEquals(\"Actual field names returned differs from expected\", expectedFieldNames, actualFieldNames);\n      } catch (AssertionError ae) {\n        throw new AssertionError(params + \" => \" + actual + \": \" + ae.getMessage(), ae);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"18e7cf5eab4be20c96aa36554daa39b53f43cf6e":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"febf4fa8feff6bbc932c1b388cbd758a3e6697f7":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["fbfb6ddad2ec9fa9128265741535450c3cbc4344","3237bc9583fd899fcf68bae4cc834095f5c911bf"],"aa4f44656c8081bbc63325a83abdb025eafd5a2b":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"fbfb6ddad2ec9fa9128265741535450c3cbc4344":["76b65cf789129cacd84e977b8f1538aec29e0281"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"136796946c32863f11b97ebec6b4091cdfe3a20b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["18e7cf5eab4be20c96aa36554daa39b53f43cf6e"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["136796946c32863f11b97ebec6b4091cdfe3a20b","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa4f44656c8081bbc63325a83abdb025eafd5a2b"],"76b65cf789129cacd84e977b8f1538aec29e0281":["136796946c32863f11b97ebec6b4091cdfe3a20b"],"3237bc9583fd899fcf68bae4cc834095f5c911bf":["fbfb6ddad2ec9fa9128265741535450c3cbc4344"]},"commit2Childs":{"18e7cf5eab4be20c96aa36554daa39b53f43cf6e":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"febf4fa8feff6bbc932c1b388cbd758a3e6697f7":[],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["18e7cf5eab4be20c96aa36554daa39b53f43cf6e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","febf4fa8feff6bbc932c1b388cbd758a3e6697f7","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"aa4f44656c8081bbc63325a83abdb025eafd5a2b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fbfb6ddad2ec9fa9128265741535450c3cbc4344":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702","3237bc9583fd899fcf68bae4cc834095f5c911bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","136796946c32863f11b97ebec6b4091cdfe3a20b"],"136796946c32863f11b97ebec6b4091cdfe3a20b":["3b013574eedcdbac35dc7e35b0ee616ffc38895d","76b65cf789129cacd84e977b8f1538aec29e0281"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["aa4f44656c8081bbc63325a83abdb025eafd5a2b"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"3237bc9583fd899fcf68bae4cc834095f5c911bf":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"76b65cf789129cacd84e977b8f1538aec29e0281":["fbfb6ddad2ec9fa9128265741535450c3cbc4344"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","febf4fa8feff6bbc932c1b388cbd758a3e6697f7","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}