{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#launchPreCopyMerge(AtomicBoolean,long,Map[String,FileMetaData]).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#launchPreCopyMerge(AtomicBoolean,long,Map[String,FileMetaData]).mjava","pathOld":"/dev/null","sourceNew":"  protected synchronized CopyJob launchPreCopyMerge(AtomicBoolean finished, long newPrimaryGen, Map<String,FileMetaData> files) throws IOException {\n\n    CopyJob job;\n\n    maybeNewPrimary(newPrimaryGen);\n    final long primaryGenStart = lastPrimaryGen;\n    Set<String> fileNames = files.keySet();\n    message(\"now pre-copy warm merge files=\" + fileNames + \" primaryGen=\" + newPrimaryGen);\n\n    for(String fileName : fileNames) {\n      assert pendingMergeFiles.contains(fileName) == false: \"file \\\"\" + fileName + \"\\\" is already being warmed!\";\n      assert lastNRTFiles.contains(fileName) == false: \"file \\\"\" + fileName + \"\\\" is already NRT visible!\";\n    }\n\n    job = newCopyJob(\"warm merge on \" + name() + \" filesNames=\" + fileNames,\n                     files, null, false,\n                     new CopyJob.OnceDone() {\n\n                       @Override\n                       public void run(CopyJob job) throws IOException {\n                         // Signals that this replica has finished\n                         mergeCopyJobs.remove(job);\n                         message(\"done warming merge \" + fileNames + \" failed?=\" + job.getFailed());\n                         synchronized(this) {\n                           if (job.getFailed() == false) {\n                             if (lastPrimaryGen != primaryGenStart) {\n                               message(\"merge pre copy finished but primary has changed; cancelling job files=\" + fileNames);\n                               job.cancel(\"primary changed during merge copy\", null);\n                             } else {\n                               boolean abort = false;\n                               for (String fileName : fileNames) {\n                                 if (lastNRTFiles.contains(fileName)) {\n                                   message(\"abort merge finish: file \" + fileName + \" is referenced by last NRT point\");\n                                   abort = true;\n                                 }\n                                 if (lastCommitFiles.contains(fileName)) {\n                                   message(\"abort merge finish: file \" + fileName + \" is referenced by last commit point\");\n                                   abort = true;\n                                 }\n                               }\n                               if (abort) {\n                                 // Even though in newNRTPoint we have similar logic, which cancels any merge copy jobs if an NRT point\n                                 // shows up referencing the files we are warming (because primary got impatient and gave up on us), we also\n                                 // need it here in case replica is way far behind and fails to even receive the merge pre-copy request\n                                 // until after the newNRTPoint referenced those files:\n                                 job.cancel(\"merged segment was separately copied via NRT point\", null);\n                               } else {\n                                 job.finish();\n                                 message(\"merge pre copy finished files=\" + fileNames);\n                                 for(String fileName : fileNames) {\n                                   assert pendingMergeFiles.contains(fileName) == false : \"file \\\"\" + fileName + \"\\\" is already in pendingMergeFiles\";\n                                   message(\"add file \" + fileName + \" to pendingMergeFiles\");\n                                   pendingMergeFiles.add(fileName);\n                                 }\n                               }\n                             }\n                           } else {\n                             message(\"merge copy finished with failure\");\n                           }\n                         }\n                         finished.set(true);\n                       }\n                     });\n\n    job.start();\n\n    // When warming a merge we better not already have any of these files copied!\n    assert job.getFileNamesToCopy().size() == files.size();\n\n    mergeCopyJobs.add(job);\n    launch(job);\n\n    return job;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#launchPreCopyMerge(AtomicBoolean,long,Map[String,FileMetaData]).mjava","pathOld":"/dev/null","sourceNew":"  protected synchronized CopyJob launchPreCopyMerge(AtomicBoolean finished, long newPrimaryGen, Map<String,FileMetaData> files) throws IOException {\n\n    CopyJob job;\n\n    maybeNewPrimary(newPrimaryGen);\n    final long primaryGenStart = lastPrimaryGen;\n    Set<String> fileNames = files.keySet();\n    message(\"now pre-copy warm merge files=\" + fileNames + \" primaryGen=\" + newPrimaryGen);\n\n    for(String fileName : fileNames) {\n      assert pendingMergeFiles.contains(fileName) == false: \"file \\\"\" + fileName + \"\\\" is already being warmed!\";\n      assert lastNRTFiles.contains(fileName) == false: \"file \\\"\" + fileName + \"\\\" is already NRT visible!\";\n    }\n\n    job = newCopyJob(\"warm merge on \" + name() + \" filesNames=\" + fileNames,\n                     files, null, false,\n                     new CopyJob.OnceDone() {\n\n                       @Override\n                       public void run(CopyJob job) throws IOException {\n                         // Signals that this replica has finished\n                         mergeCopyJobs.remove(job);\n                         message(\"done warming merge \" + fileNames + \" failed?=\" + job.getFailed());\n                         synchronized(this) {\n                           if (job.getFailed() == false) {\n                             if (lastPrimaryGen != primaryGenStart) {\n                               message(\"merge pre copy finished but primary has changed; cancelling job files=\" + fileNames);\n                               job.cancel(\"primary changed during merge copy\", null);\n                             } else {\n                               boolean abort = false;\n                               for (String fileName : fileNames) {\n                                 if (lastNRTFiles.contains(fileName)) {\n                                   message(\"abort merge finish: file \" + fileName + \" is referenced by last NRT point\");\n                                   abort = true;\n                                 }\n                                 if (lastCommitFiles.contains(fileName)) {\n                                   message(\"abort merge finish: file \" + fileName + \" is referenced by last commit point\");\n                                   abort = true;\n                                 }\n                               }\n                               if (abort) {\n                                 // Even though in newNRTPoint we have similar logic, which cancels any merge copy jobs if an NRT point\n                                 // shows up referencing the files we are warming (because primary got impatient and gave up on us), we also\n                                 // need it here in case replica is way far behind and fails to even receive the merge pre-copy request\n                                 // until after the newNRTPoint referenced those files:\n                                 job.cancel(\"merged segment was separately copied via NRT point\", null);\n                               } else {\n                                 job.finish();\n                                 message(\"merge pre copy finished files=\" + fileNames);\n                                 for(String fileName : fileNames) {\n                                   assert pendingMergeFiles.contains(fileName) == false : \"file \\\"\" + fileName + \"\\\" is already in pendingMergeFiles\";\n                                   message(\"add file \" + fileName + \" to pendingMergeFiles\");\n                                   pendingMergeFiles.add(fileName);\n                                 }\n                               }\n                             }\n                           } else {\n                             message(\"merge copy finished with failure\");\n                           }\n                         }\n                         finished.set(true);\n                       }\n                     });\n\n    job.start();\n\n    // When warming a merge we better not already have any of these files copied!\n    assert job.getFileNamesToCopy().size() == files.size();\n\n    mergeCopyJobs.add(job);\n    launch(job);\n\n    return job;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}