{"path":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","commits":[{"id":"824ab25acd22f2eca198755bafab3cb8b7878493","date":1341276186,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","pathOld":"/dev/null","sourceNew":"  public static int decompress(IntBuffer intBuffer, int[] data) {\n    intBuffer.rewind();\n    int header = intBuffer.get();\n\n    int numInts = (header & MASK[8]) + 1;\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 29) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[5]) + 1;\n\n    // TODO: PackedIntsDecompress is hardewired to size==128 only\n    switch(numBits) {\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n      default:\n        throw new IllegalStateException(\"Unknown numFrameBits \" + numBits);\n    }\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n    return numInts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5373bc7574123da55ae25e216b6d768ccb1dcd91","date":1342013351,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","sourceNew":"  /** Decompress given Integer buffer into int array.\n   *\n   * @param intBuffer   integer buffer to hold compressed data\n   * @param data        int array to hold uncompressed data\n   */\n  public static int decompress(IntBuffer intBuffer, int[] data) {\n\n    // since this buffer is reused at upper level, rewind first\n    intBuffer.rewind();\n\n    int header = intBuffer.get();\n    int numInts = (header & MASK[8]) + 1;\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 29) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[5]) + 1;\n\n    decompressCore(intBuffer, data, numBits);\n\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n\n    return numInts;\n  }\n\n","sourceOld":"  public static int decompress(IntBuffer intBuffer, int[] data) {\n    intBuffer.rewind();\n    int header = intBuffer.get();\n\n    int numInts = (header & MASK[8]) + 1;\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 29) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[5]) + 1;\n\n    // TODO: PackedIntsDecompress is hardewired to size==128 only\n    switch(numBits) {\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n      default:\n        throw new IllegalStateException(\"Unknown numFrameBits \" + numBits);\n    }\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n    return numInts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b","date":1342134079,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","sourceNew":"  /** Decompress given Integer buffer into int array.\n   *\n   * @param intBuffer   integer buffer to hold compressed data\n   * @param data        int array to hold uncompressed data\n   */\n  public static int decompress(IntBuffer intBuffer, int[] data) {\n\n    // since this buffer is reused at upper level, rewind first\n    intBuffer.rewind();\n\n    int header = intBuffer.get();\n    int numInts = (header & MASK[8]);\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 30) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[6]);\n\n    decompressCore(intBuffer, data, numBits);\n\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n\n    return numInts;\n  }\n\n","sourceOld":"  /** Decompress given Integer buffer into int array.\n   *\n   * @param intBuffer   integer buffer to hold compressed data\n   * @param data        int array to hold uncompressed data\n   */\n  public static int decompress(IntBuffer intBuffer, int[] data) {\n\n    // since this buffer is reused at upper level, rewind first\n    intBuffer.rewind();\n\n    int header = intBuffer.get();\n    int numInts = (header & MASK[8]) + 1;\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 29) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[5]) + 1;\n\n    decompressCore(intBuffer, data, numBits);\n\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n\n    return numInts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5","date":1342443326,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#decompress(IntBuffer,int[]).mjava","sourceNew":"  /** Decompress given Integer buffer into int array.\n   *\n   * @param intBuffer   integer buffer to hold compressed data\n   * @param data        int array to hold uncompressed data\n   */\n  public static void decompress(IntBuffer intBuffer, int[] data, int header) {\n    // since this buffer is reused at upper level, rewind first\n    intBuffer.rewind();\n\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 30) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[6]);\n\n    decompressCore(intBuffer, data, numBits);\n\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n  }\n\n","sourceOld":"  /** Decompress given Integer buffer into int array.\n   *\n   * @param intBuffer   integer buffer to hold compressed data\n   * @param data        int array to hold uncompressed data\n   */\n  public static int decompress(IntBuffer intBuffer, int[] data) {\n\n    // since this buffer is reused at upper level, rewind first\n    intBuffer.rewind();\n\n    int header = intBuffer.get();\n    int numInts = (header & MASK[8]);\n    int excNum = ((header >> 8) & MASK[8]) + 1;\n    int excFirstPos = ((header >> 16) & MASK[8]) - 1;\n    int excBytes = PER_EXCEPTION_SIZE[(header >> 30) & MASK[2]];\n    int numBits = ((header >> 24) & MASK[6]);\n\n    decompressCore(intBuffer, data, numBits);\n\n    patchException(intBuffer,data,excNum,excFirstPos,excBytes);\n\n    return numInts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"824ab25acd22f2eca198755bafab3cb8b7878493":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["824ab25acd22f2eca198755bafab3cb8b7878493"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["5373bc7574123da55ae25e216b6d768ccb1dcd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"824ab25acd22f2eca198755bafab3cb8b7878493":["5373bc7574123da55ae25e216b6d768ccb1dcd91"],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["824ab25acd22f2eca198755bafab3cb8b7878493","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5":[],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}