{"path":"solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory#parseInstant(DateTimeFormatter,String,ParsePosition).mjava","commits":[{"id":"4303580aad3a549d25741d17b837bbc0e25c0bec","date":1538567942,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory#parseInstant(DateTimeFormatter,String,ParsePosition).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory#parseInstant(DateTimeFormatter,String).mjava","sourceNew":"  // see https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8177021 which is fixed in Java 9.\n  //  The upshot is that trying to use parse(Instant::from) is unreliable in the event that\n  //  the input string contains a timezone/offset that differs from the \"override zone\"\n  //  (which we configure in DEFAULT_TIME_ZONE).  Besides, we need the code below which handles\n  //  the optionality of time.  Were it not for that, we truly could do formatter.parse(Instant::from).\n  private static Instant parseInstant(DateTimeFormatter formatter, String dateStr, ParsePosition parsePosition) {\n    // prepare for reuse\n    parsePosition.setIndex(0);\n    parsePosition.setErrorIndex(-1);\n    final TemporalAccessor temporal = formatter.parse(dateStr, parsePosition);\n    // check that all content has been parsed\n    if (parsePosition.getIndex() < dateStr.length()) {\n      final String abbr;\n      if (dateStr.length() > 64) {\n        abbr = dateStr.subSequence(0, 64).toString() + \"...\";\n      } else {\n        abbr = dateStr;\n      }\n      throw new DateTimeParseException(\"Text '\" + abbr + \"' could not be parsed, unparsed text found at index \" +\n          parsePosition.getIndex(), dateStr, parsePosition.getIndex());\n    }\n\n    // Get Date; mandatory\n    LocalDate date = temporal.query(TemporalQueries.localDate());//mandatory\n    if (date == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Date (year, month, day) is mandatory: \" + formatter.toFormat().toString());\n    }\n    // Get Time; optional\n    LocalTime time = temporal.query(TemporalQueries.localTime());\n    if (time == null) {\n      time = LocalTime.MIN;\n    }\n\n    final LocalDateTime localDateTime = LocalDateTime.of(date, time);\n\n    // Get Zone Offset; optional\n    ZoneOffset offset = temporal.query(TemporalQueries.offset());\n    if (offset == null) {\n      // no Zone offset; get Zone ID\n      ZoneId zoneId = temporal.query(TemporalQueries.zone());\n      if (zoneId == null) {\n        zoneId = formatter.getZone();\n        if (zoneId == null) {\n          zoneId = ZoneOffset.UTC;\n        }\n      }\n      return localDateTime.atZone(zoneId).toInstant();\n    } else {\n      return localDateTime.toInstant(offset);\n    }\n  }\n\n","sourceOld":"  // see https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8177021 which is fixed in Java 9.\n  //  The upshot is that trying to use parse(Instant::from) is unreliable in the event that\n  //  the input string contains a timezone/offset that differs from the \"override zone\"\n  //  (which we configure in DEFAULT_TIME_ZONE).  Besides, we need the code below which handles\n  //  the optionality of time.  Were it not for that, we truly could do formatter.parse(Instant::from).\n  private static Instant parseInstant(DateTimeFormatter formatter, String dateStr) {\n    final TemporalAccessor temporal = formatter.parse(dateStr);\n    // Get Date; mandatory\n    LocalDate date = temporal.query(TemporalQueries.localDate());//mandatory\n    if (date == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Date (year, month, day) is mandatory: \" + formatter.toFormat().toString());\n    }\n    // Get Time; optional\n    LocalTime time = temporal.query(TemporalQueries.localTime());\n    if (time == null) {\n      time = LocalTime.MIN;\n    }\n\n    final LocalDateTime localDateTime = LocalDateTime.of(date, time);\n\n    // Get Zone Offset; optional\n    ZoneOffset offset = temporal.query(TemporalQueries.offset());\n    if (offset == null) {\n      // no Zone offset; get Zone ID\n      ZoneId zoneId = temporal.query(TemporalQueries.zone());\n      if (zoneId == null) {\n        zoneId = formatter.getZone();\n        if (zoneId == null) {\n          zoneId = ZoneOffset.UTC;\n        }\n      }\n      return localDateTime.atZone(zoneId).toInstant();\n    } else {\n      return localDateTime.toInstant(offset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4303580aad3a549d25741d17b837bbc0e25c0bec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4303580aad3a549d25741d17b837bbc0e25c0bec"]},"commit2Childs":{"4303580aad3a549d25741d17b837bbc0e25c0bec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4303580aad3a549d25741d17b837bbc0e25c0bec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}