{"path":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","commits":[{"id":"fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c","date":1377117099,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"/dev/null","sourceNew":"  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    int sz = fqList1.size();\n    outer:\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      for (int j = start; j < sz; j++) {\n        if (q1.equals(fqList2.get(j)))\n          continue outer;\n      }\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"/dev/null","sourceNew":"  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    int sz = fqList1.size();\n    outer:\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      for (int j = start; j < sz; j++) {\n        if (q1.equals(fqList2.get(j)))\n          continue outer;\n      }\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8a8ec7bd407ce5ad65fe8d53fd69d9cd597f58f","date":1389311746,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","sourceNew":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<Query>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","sourceOld":"  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    int sz = fqList1.size();\n    outer:\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      for (int j = start; j < sz; j++) {\n        if (q1.equals(fqList2.get(j)))\n          continue outer;\n      }\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","sourceNew":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","sourceOld":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<Query>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","sourceNew":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivalent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a guarantee that the lists never contained any duplicates,\n    // this logic could be a lot simpler \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","sourceOld":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","sourceNew":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivalent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a guarantee that the lists never contained any duplicates,\n    // this logic could be a lot simpler \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","sourceOld":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/QueryResultKey#unorderedCompare(List[Query],List[Query],int).mjava","sourceNew":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivalent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a guarantee that the lists never contained any duplicates,\n    // this logic could be a lot simpler \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","sourceOld":"  /** \n   * Does an unordered comparison of the elements of two lists of queries starting at \n   * the specified start index.\n   * \n   * This method should only be called on lists which are the same size, and where \n   * all items with an index less then the specified start index are the same.\n   *\n   * @return true if the list items after start are equivilent other then the ordering\n   */\n  private static boolean unorderedCompare(List<Query> fqList1, List<Query> fqList2, int start) {\n    assert null != fqList1;\n    assert null != fqList2;\n\n    final int sz = fqList1.size();\n    assert fqList2.size() == sz;\n\n    // SOLR-5618: if we had a garuntee that the lists never contained any duplicates,\n    // this logic could be a lot simplier \n    //\n    // (And of course: if the SolrIndexSearcher / QueryCommmand was ever changed to\n    // sort the filter query list, then this whole method could be eliminated).\n\n    final ArrayList<Query> set2 = new ArrayList<>(fqList2.subList(start, sz));\n    for (int i = start; i < sz; i++) {\n      Query q1 = fqList1.get(i);\n      if ( ! set2.remove(q1) ) {\n        return false;\n      }\n    }\n    return set2.isEmpty();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e8a8ec7bd407ce5ad65fe8d53fd69d9cd597f58f"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e8a8ec7bd407ce5ad65fe8d53fd69d9cd597f58f":["fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c"],"fb6e31e51d7f836e7a16fbf4d0cf3bbc3a4f6a1c":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e8a8ec7bd407ce5ad65fe8d53fd69d9cd597f58f"],"e8a8ec7bd407ce5ad65fe8d53fd69d9cd597f58f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}