{"path":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    Query query = rb.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( rb.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException \n  {\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    ResponseBuilder builder = SearchHandler.getResponseBuilder( req );\n    Query query = builder.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( builder.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      builder.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = builder.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( builder.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      builder.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a671e758510cca06ca5b701169a61e9644a7b4c4","date":1232137421,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( rb.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n    \n    Query query = rb.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( rb.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( forceElevation && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61cd7bdf2e4fbdad8e97effdfc84f04a3656d596","date":1241435235,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    if( query == null ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"The QueryElevationComponent needs to be registered 'after' the query component\" );\n    }\n    \n    String qstr = getAnalyzedQuery( rb.getQueryString() );\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":["5391288921372c32bf6096df320497ad2d05757f","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb8cfe7bf587294d6207ef881511e98bde8666f1","date":1244338898,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, new ElevationComparatorSource(booster.priority), false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, \n              new ElevationComparatorSource(booster.priority), false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, \n                new ElevationComparatorSource(booster.priority), sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cb8cfe7bf587294d6207ef881511e98bde8666f1":["61cd7bdf2e4fbdad8e97effdfc84f04a3656d596"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"a671e758510cca06ca5b701169a61e9644a7b4c4":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"ad94625fb8d088209f46650c8097196fec67f00c":["cb8cfe7bf587294d6207ef881511e98bde8666f1"],"61cd7bdf2e4fbdad8e97effdfc84f04a3656d596":["a671e758510cca06ca5b701169a61e9644a7b4c4"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"cb8cfe7bf587294d6207ef881511e98bde8666f1":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"a671e758510cca06ca5b701169a61e9644a7b4c4":["61cd7bdf2e4fbdad8e97effdfc84f04a3656d596"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"61cd7bdf2e4fbdad8e97effdfc84f04a3656d596":["cb8cfe7bf587294d6207ef881511e98bde8666f1"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["a671e758510cca06ca5b701169a61e9644a7b4c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}