{"path":"lucene/monitor/src/java/org/apache/lucene/monitor/ConcurrentQueryLoader#[E]_drain(BlockingQueue[E],Collection[#-super-E],int,long,TimeUnit).mjava","commits":[{"id":"7c529b189e09de25455d82ebd7260748cf11ee14","date":1560415257,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/monitor/src/java/org/apache/lucene/monitor/ConcurrentQueryLoader#[E]_drain(BlockingQueue[E],Collection[#-super-E],int,long,TimeUnit).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested\n   * {@code numElements} elements are not available, it will wait for them up to the specified\n   * timeout.\n   * <p>\n   * Taken from Google Guava 18.0 Queues\n   *\n   * @param q           the blocking queue to be drained\n   * @param buffer      where to add the transferred elements\n   * @param numElements the number of elements to be waited for\n   * @param timeout     how long to wait before giving up, in units of {@code unit}\n   * @param unit        a {@code TimeUnit} determining how to interpret the timeout parameter\n   * @param <E>         the type of the queue\n   * @return the number of elements transferred\n   * @throws InterruptedException if interrupted while waiting\n   */\n  private static <E> int drain(BlockingQueue<E> q, Collection<? super E> buffer, int numElements,\n                              long timeout, TimeUnit unit) throws InterruptedException {\n    buffer = Objects.requireNonNull(buffer);\n    /*\n     * This code performs one System.nanoTime() more than necessary, and in return, the time to\n     * execute Queue#drainTo is not added *on top* of waiting for the timeout (which could make\n     * the timeout arbitrarily inaccurate, given a queue that is slow to drain).\n     */\n    long deadline = System.nanoTime() + unit.toNanos(timeout);\n    int added = 0;\n    while (added < numElements) {\n      // we could rely solely on #poll, but #drainTo might be more efficient when there are multiple\n      // elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)\n      added += q.drainTo(buffer, numElements - added);\n      if (added < numElements) { // not enough elements immediately available; will have to poll\n        E e = q.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);\n        if (e == null) {\n          break; // we already waited enough, and there are no more elements in sight\n        }\n        buffer.add(e);\n        added++;\n      }\n    }\n    return added;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42210058b8ae092085fa2658880b69931512e8bf","date":1579289439,"type":3,"author":"Mike","isMerge":false,"pathNew":"lucene/monitor/src/java/org/apache/lucene/monitor/ConcurrentQueryLoader#[E]_drain(BlockingQueue[E],Collection[#-super-E],int,long,TimeUnit).mjava","pathOld":"lucene/monitor/src/java/org/apache/lucene/monitor/ConcurrentQueryLoader#[E]_drain(BlockingQueue[E],Collection[#-super-E],int,long,TimeUnit).mjava","sourceNew":"  /**\n   * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested\n   * {@code numElements} elements are not available, it will wait for them up to the specified\n   * timeout.\n   * <p>\n   * Taken from Google Guava 18.0 Queues\n   *\n   * @param q           the blocking queue to be drained\n   * @param buffer      where to add the transferred elements\n   * @param numElements the number of elements to be waited for\n   * @param timeout     how long to wait before giving up, in units of {@code unit}\n   * @param unit        a {@code TimeUnit} determining how to interpret the timeout parameter\n   * @param <E>         the type of the queue\n   * @return the number of elements transferred\n   * @throws InterruptedException if interrupted while waiting\n   */\n  private static <E> int drain(BlockingQueue<E> q, Collection<? super E> buffer, int numElements,\n                              long timeout, TimeUnit unit) throws InterruptedException {\n    Objects.requireNonNull(buffer);\n    /*\n     * This code performs one System.nanoTime() more than necessary, and in return, the time to\n     * execute Queue#drainTo is not added *on top* of waiting for the timeout (which could make\n     * the timeout arbitrarily inaccurate, given a queue that is slow to drain).\n     */\n    long deadline = System.nanoTime() + unit.toNanos(timeout);\n    int added = 0;\n    while (added < numElements) {\n      // we could rely solely on #poll, but #drainTo might be more efficient when there are multiple\n      // elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)\n      added += q.drainTo(buffer, numElements - added);\n      if (added < numElements) { // not enough elements immediately available; will have to poll\n        E e = q.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);\n        if (e == null) {\n          break; // we already waited enough, and there are no more elements in sight\n        }\n        buffer.add(e);\n        added++;\n      }\n    }\n    return added;\n  }\n\n","sourceOld":"  /**\n   * Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested\n   * {@code numElements} elements are not available, it will wait for them up to the specified\n   * timeout.\n   * <p>\n   * Taken from Google Guava 18.0 Queues\n   *\n   * @param q           the blocking queue to be drained\n   * @param buffer      where to add the transferred elements\n   * @param numElements the number of elements to be waited for\n   * @param timeout     how long to wait before giving up, in units of {@code unit}\n   * @param unit        a {@code TimeUnit} determining how to interpret the timeout parameter\n   * @param <E>         the type of the queue\n   * @return the number of elements transferred\n   * @throws InterruptedException if interrupted while waiting\n   */\n  private static <E> int drain(BlockingQueue<E> q, Collection<? super E> buffer, int numElements,\n                              long timeout, TimeUnit unit) throws InterruptedException {\n    buffer = Objects.requireNonNull(buffer);\n    /*\n     * This code performs one System.nanoTime() more than necessary, and in return, the time to\n     * execute Queue#drainTo is not added *on top* of waiting for the timeout (which could make\n     * the timeout arbitrarily inaccurate, given a queue that is slow to drain).\n     */\n    long deadline = System.nanoTime() + unit.toNanos(timeout);\n    int added = 0;\n    while (added < numElements) {\n      // we could rely solely on #poll, but #drainTo might be more efficient when there are multiple\n      // elements already available (e.g. LinkedBlockingQueue#drainTo locks only once)\n      added += q.drainTo(buffer, numElements - added);\n      if (added < numElements) { // not enough elements immediately available; will have to poll\n        E e = q.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);\n        if (e == null) {\n          break; // we already waited enough, and there are no more elements in sight\n        }\n        buffer.add(e);\n        added++;\n      }\n    }\n    return added;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"42210058b8ae092085fa2658880b69931512e8bf":["7c529b189e09de25455d82ebd7260748cf11ee14"],"7c529b189e09de25455d82ebd7260748cf11ee14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["42210058b8ae092085fa2658880b69931512e8bf"]},"commit2Childs":{"42210058b8ae092085fa2658880b69931512e8bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c529b189e09de25455d82ebd7260748cf11ee14":["42210058b8ae092085fa2658880b69931512e8bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c529b189e09de25455d82ebd7260748cf11ee14"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}