{"path":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","commits":[{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BinaryUpdateRequestHandler#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      } catch (Exception e) {\n        log.error(\"Exception while processing update request\", e);\n        break;\n      }\n      if (update.getDeleteById() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      } catch (Exception e) {\n        log.error(\"Exception while processing update request\", e);\n        break;\n      }\n      if (update.getDeleteById() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07da04837dda68434fe9bba384d3c4faaa21235","date":1339673862,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteById() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      } catch (Exception e) {\n        log.error(\"Exception while processing update request\", e);\n        break;\n      }\n      if (update.getDeleteById() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":["0e75d826d1f37079d934ae6ec2016a235d96c041"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","date":1378862385,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteById() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab8657e27d6bdd6107b9d64da71c635e1f47b59e","date":1390524786,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n        \n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61a4a35e13b1b983d53f4fc14642b1f796f81483","date":1395516544,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n        \n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n        \n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":["0e75d826d1f37079d934ae6ec2016a235d96c041"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b","date":1432083803,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n        \n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0c8def5755ce61b5e44678cc3abfeae21560dc0","date":1517222560,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    if (in.peek() == -1) return;\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fed9912ce71a23392c6fcb90f526fa2c80398140","date":1517297148,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    if (in.peek() == -1) return;\n    for (; ; ) {\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac35531329b1809368fb0780bcf1e72d0add3c21","date":1525474926,"type":4,"author":"Mark Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":null,"sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cff47d27eb02068a9e554ff2d11e4bfd83875c20","date":1525634759,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"/dev/null","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b6c193737882b94fcb01749c75371bf7d7d4c93","date":1539067480,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          // Perhaps commit from the parameters\n          try {\n            RequestHandlerUtils.handleCommit(req, processor, updateRequest.getParams(), false);\n            RequestHandlerUtils.handleRollback(req, processor, updateRequest.getParams(), false);\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR handling commit/rollback\");\n          }\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":["cff47d27eb02068a9e554ff2d11e4bfd83875c20"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4996819a2e14e1ee8bf4273ae5ccc179860bd28e","date":1546928779,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec()\n            .setReadStringAsCharSeq(true)\n            .unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec().unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3665b66adafb1514bba04cd1d5c477fcaa93d592","date":1576153597,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec()\n            .unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec()\n            .setReadStringAsCharSeq(true)\n            .unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JavabinLoader#parseAndLoadDocs(SolrQueryRequest,SolrQueryResponse,InputStream,UpdateRequestProcessor).mjava","sourceNew":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec()\n            .unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","sourceOld":"  private void parseAndLoadDocs(final SolrQueryRequest req, SolrQueryResponse rsp, InputStream stream,\n                                final UpdateRequestProcessor processor) throws IOException {\n    if (req.getParams().getBool(\"multistream\", false)) {\n      handleMultiStream(req, rsp, stream, processor);\n      return;\n    }\n    UpdateRequest update = null;\n    JavaBinUpdateRequestCodec.StreamingUpdateHandler handler = new JavaBinUpdateRequestCodec.StreamingUpdateHandler() {\n      private AddUpdateCommand addCmd = null;\n\n      @Override\n      public void update(SolrInputDocument document, UpdateRequest updateRequest, Integer commitWithin, Boolean overwrite) {\n        if (document == null) {\n          return;\n        }\n        if (addCmd == null) {\n          addCmd = getAddCommand(req, updateRequest.getParams());\n        }\n        addCmd.solrDoc = document;\n        if (commitWithin != null) {\n          addCmd.commitWithin = commitWithin;\n        }\n        if (overwrite != null) {\n          addCmd.overwrite = overwrite;\n        }\n\n        if (updateRequest.isLastDocInBatch()) {\n          // this is a hint to downstream code that indicates we've sent the last doc in a batch\n          addCmd.isLastDocInBatch = true;\n        }\n\n        try {\n          processor.processAdd(addCmd);\n          addCmd.clear();\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ERROR adding document \" + document, e);\n        }\n      }\n    };\n    FastInputStream in = FastInputStream.wrap(stream);\n    for (; ; ) {\n      if (in.peek() == -1) return;\n      try {\n        update = new JavaBinUpdateRequestCodec()\n            .setReadStringAsCharSeq(true)\n            .unmarshal(in, handler);\n      } catch (EOFException e) {\n        break; // this is expected\n      }\n      if (update.getDeleteByIdMap() != null || update.getDeleteQuery() != null) {\n        delete(req, update, processor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cff47d27eb02068a9e554ff2d11e4bfd83875c20":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"b07da04837dda68434fe9bba384d3c4faaa21235":["042e4d934397657ba04c82b46cc5665076bc5c58"],"7b6c193737882b94fcb01749c75371bf7d7d4c93":["cff47d27eb02068a9e554ff2d11e4bfd83875c20"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["7b6c193737882b94fcb01749c75371bf7d7d4c93"],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["b07da04837dda68434fe9bba384d3c4faaa21235"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e"],"4996819a2e14e1ee8bf4273ae5ccc179860bd28e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["fed9912ce71a23392c6fcb90f526fa2c80398140"],"a0c8def5755ce61b5e44678cc3abfeae21560dc0":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"fed9912ce71a23392c6fcb90f526fa2c80398140":["a0c8def5755ce61b5e44678cc3abfeae21560dc0"],"61a4a35e13b1b983d53f4fc14642b1f796f81483":["ab8657e27d6bdd6107b9d64da71c635e1f47b59e"],"df724d84dab24a0cc54bec95a8680867adc7f171":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e","3665b66adafb1514bba04cd1d5c477fcaa93d592"],"ab8657e27d6bdd6107b9d64da71c635e1f47b59e":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["61a4a35e13b1b983d53f4fc14642b1f796f81483"],"042e4d934397657ba04c82b46cc5665076bc5c58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3665b66adafb1514bba04cd1d5c477fcaa93d592"]},"commit2Childs":{"cff47d27eb02068a9e554ff2d11e4bfd83875c20":["7b6c193737882b94fcb01749c75371bf7d7d4c93"],"b07da04837dda68434fe9bba384d3c4faaa21235":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"7b6c193737882b94fcb01749c75371bf7d7d4c93":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e"],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["ab8657e27d6bdd6107b9d64da71c635e1f47b59e"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4996819a2e14e1ee8bf4273ae5ccc179860bd28e":["3665b66adafb1514bba04cd1d5c477fcaa93d592","df724d84dab24a0cc54bec95a8680867adc7f171"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["cff47d27eb02068a9e554ff2d11e4bfd83875c20"],"a0c8def5755ce61b5e44678cc3abfeae21560dc0":["fed9912ce71a23392c6fcb90f526fa2c80398140"],"fed9912ce71a23392c6fcb90f526fa2c80398140":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"61a4a35e13b1b983d53f4fc14642b1f796f81483":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"ab8657e27d6bdd6107b9d64da71c635e1f47b59e":["61a4a35e13b1b983d53f4fc14642b1f796f81483"],"042e4d934397657ba04c82b46cc5665076bc5c58":["b07da04837dda68434fe9bba384d3c4faaa21235"],"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["a0c8def5755ce61b5e44678cc3abfeae21560dc0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042e4d934397657ba04c82b46cc5665076bc5c58"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}