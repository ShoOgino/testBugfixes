{"path":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","commits":[{"id":"d3c3c2404d1200c39220fa15054fae854db4e1ee","date":1140827958,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"/dev/null","sourceNew":"\t/**\r\n     * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t \r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * \r\n\t * \r\n\t *\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, false, false);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d084a2207d6589b283810431b6373c7a44fbd5b","date":1142958370,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\r\n     * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t \r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * \r\n\t * \r\n\t *\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","sourceOld":"\t/**\r\n     * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t \r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * \r\n\t * \r\n\t *\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, false, false);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d6b01d80027a259ec049e498817cddb208d00b","date":1164235523,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\r\n\t * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","sourceOld":"\t/**\r\n     * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t *\r\n\t \r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * \r\n\t * \r\n\t *\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\r\n\t * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n                final Token reusableToken = new Token();\r\n\t\tfor (Token nextToken = ts.next(reusableToken); nextToken != null; nextToken = ts.next(reusableToken)) {\r\n\t\t\tString word = nextToken.term();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","sourceOld":"\t/**\r\n\t * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\torg.apache.lucene.analysis.Token t;\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n\t\twhile ( (t = ts.next()) != null)\r\n\t\t{\r\n\t\t\tString word = t.termText();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a361a621b184d9b73c9c9a37323a9845b8f8260","date":1226370946,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n                final Token reusableToken = new Token();\n\t\tfor (Token nextToken = ts.next(reusableToken); nextToken != null; nextToken = ts.next(reusableToken)) {\n\t\t\tString word = nextToken.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\r\n\t * Simple similarity query generators.\r\n\t * Takes every unique word and forms a boolean query where all words are optional.\r\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\r\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\r\n\t * need to then ignore that.\r\n\t *\r\n\t * <p>\r\n\t * So, if you have a code fragment like this:\r\n\t * <br>\r\n\t * <code>\r\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\r\n\t * </code>\r\n\t *\r\n\t * <p>\r\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\r\n\t *\r\n\t * <p>\r\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\r\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\r\n\t *\r\n\t * <P>\r\n\t * This method is fail-safe in that if a long 'body' is passed in and\r\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\r\n\t * throws\r\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\r\n\t * query as it is will be returned.\r\n\t *\r\n\t * @param body the body of the document you want to find similar documents to\r\n\t * @param a the analyzer to use to parse the body\r\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\r\n\t * @param stop optional set of stop words to ignore\r\n\t * @return a query with all unique words in 'body'\r\n\t * @throws IOException this can't happen...\r\n\t */\r\n    public static Query formSimilarQuery( String body,\r\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\r\n\t\t\t\t\t\t\t\t\t\t  String field,\r\n\t\t\t\t\t\t\t\t\t\t  Set stop)\r\n\t\t\t\t\t\t\t\t\t\t  throws IOException\r\n\t{\t\r\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\r\n\t\tBooleanQuery tmp = new BooleanQuery();\r\n\t\tSet already = new HashSet(); // ignore dups\r\n                final Token reusableToken = new Token();\r\n\t\tfor (Token nextToken = ts.next(reusableToken); nextToken != null; nextToken = ts.next(reusableToken)) {\r\n\t\t\tString word = nextToken.term();\r\n\t\t\t// ignore opt stop words\r\n\t\t\tif ( stop != null &&\r\n\t\t\t\t stop.contains( word)) continue;\r\n\t\t\t// ignore dups\r\n\t\t\tif ( ! already.add( word)) continue;\r\n\t\t\t// add to query\r\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\r\n\t\t\t}\r\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\r\n\t\t\t{\r\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tmp;\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b5756469957918cac40a831acec9cf01c8c2bb3","date":1249167152,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = (TermAttribute) ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n                final Token reusableToken = new Token();\n\t\tfor (Token nextToken = ts.next(reusableToken); nextToken != null; nextToken = ts.next(reusableToken)) {\n\t\t\tString word = nextToken.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = (TermAttribute) ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucenes scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = (TermAttribute) ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d78f014fded44fbde905f4f84cdc21907b371e8","date":1254383623,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = (TermAttribute) ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60cdc0e643184821eb066795a8791cd82559f46e","date":1257941914,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set[#]).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set<?> stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet<String> already = new HashSet<String>(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60cdc0e643184821eb066795a8791cd82559f46e":["8d78f014fded44fbde905f4f84cdc21907b371e8"],"7e2cb543b41c145f33390f460ee743d6693c9c6c":["98d6b01d80027a259ec049e498817cddb208d00b"],"2d084a2207d6589b283810431b6373c7a44fbd5b":["d3c3c2404d1200c39220fa15054fae854db4e1ee"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["9b5756469957918cac40a831acec9cf01c8c2bb3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9b5756469957918cac40a831acec9cf01c8c2bb3":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"d3c3c2404d1200c39220fa15054fae854db4e1ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8d78f014fded44fbde905f4f84cdc21907b371e8":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"98d6b01d80027a259ec049e498817cddb208d00b":["2d084a2207d6589b283810431b6373c7a44fbd5b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60cdc0e643184821eb066795a8791cd82559f46e"]},"commit2Childs":{"60cdc0e643184821eb066795a8791cd82559f46e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7e2cb543b41c145f33390f460ee743d6693c9c6c":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"2d084a2207d6589b283810431b6373c7a44fbd5b":["98d6b01d80027a259ec049e498817cddb208d00b"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["8d78f014fded44fbde905f4f84cdc21907b371e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3c3c2404d1200c39220fa15054fae854db4e1ee"],"9b5756469957918cac40a831acec9cf01c8c2bb3":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"d3c3c2404d1200c39220fa15054fae854db4e1ee":["2d084a2207d6589b283810431b6373c7a44fbd5b"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["9b5756469957918cac40a831acec9cf01c8c2bb3"],"8d78f014fded44fbde905f4f84cdc21907b371e8":["60cdc0e643184821eb066795a8791cd82559f46e"],"98d6b01d80027a259ec049e498817cddb208d00b":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}