{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","commits":[{"id":"d0e67453ef2c855797898e384afc5dd4a4d6bac5","date":1428334932,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState(true);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"182acd29cf4cb1644a02b8517f3a5b867c0d7cce","date":1432665213,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState(true);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState(true);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState();\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState(true);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().updateClusterState();\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3","date":1460654262,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = getShardLeader(testCollectionName, shardId, 30 /* timeout secs */);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    String replicaState = null;\n    int timeoutSecs = 15;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = null;\n    String replicaState = null;\n    int timeoutSecs = 30;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      Replica tmp = null;\n      try {\n        tmp = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n      } catch (Exception exc) {}\n      if (tmp != null && \"active\".equals(tmp.getStr(ZkStateReader.STATE_PROP))) {\n        leader = tmp;\n        replicaState = \"active\";\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    assertNotNull(\"Could not find active leader for \" + shardId + \" of \" +\n        testCollectionName + \" after \"+timeoutSecs+\" secs; clusterState: \" +\n        printClusterStateInfo(testCollectionName), leader);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    timeoutSecs = 15;\n    timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":["d0e67453ef2c855797898e384afc5dd4a4d6bac5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a02c54923e5f4de08097fa9028e09e8cf5caa82","date":1475573567,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = getShardLeader(testCollectionName, shardId, 30 /* timeout secs */);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    String replicaState = null;\n    int timeoutSecs = 15;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1967bed916cc89da82a1c2085f27976da6d08cbd","date":1475588750,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = getShardLeader(testCollectionName, shardId, 30 /* timeout secs */);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    String replicaState = null;\n    int timeoutSecs = 15;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n    waitForThingsToLevelOut(30000);\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    String testCollectionName = \"c8n_1x1\";\n    String shardId = \"shard1\";\n    createCollectionRetry(testCollectionName, 1, 1, 1);\n    cloudClient.setDefaultCollection(testCollectionName);\n\n    Replica leader = getShardLeader(testCollectionName, shardId, 30 /* timeout secs */);\n\n    // reload collection and wait to see the core report it has been reloaded\n    boolean wasReloaded = reloadCollection(leader, testCollectionName);\n    assertTrue(\"Collection '\"+testCollectionName+\"' failed to reload within a reasonable amount of time!\",\n        wasReloaded);\n\n    // cause session loss\n    chaosMonkey.expireSession(getJettyOnPort(getReplicaPort(leader)));\n\n    // TODO: have to wait a while for the node to get marked down after ZK session loss\n    // but tests shouldn't be so timing dependent!\n    Thread.sleep(15000);\n\n    // wait up to 15 seconds to see the replica in the active state\n    String replicaState = null;\n    int timeoutSecs = 15;\n    long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutSecs, TimeUnit.SECONDS);\n    while (System.nanoTime() < timeout) {\n      // state of leader should be active after session loss recovery - see SOLR-7338\n      cloudClient.getZkStateReader().forceUpdateCollection(testCollectionName);\n      ClusterState cs = cloudClient.getZkStateReader().getClusterState();\n      Slice slice = cs.getSlice(testCollectionName, shardId);\n      replicaState = slice.getReplica(leader.getName()).getStr(ZkStateReader.STATE_PROP);\n      if (\"active\".equals(replicaState))\n        break;\n\n      Thread.sleep(1000);\n    }\n    assertEquals(\"Leader state should be active after recovering from ZK session loss, but after \" +\n        timeoutSecs + \" seconds, it is \" + replicaState, \"active\", replicaState);\n\n    // try to clean up\n    try {\n      new CollectionAdminRequest.Delete()\n              .setCollectionName(testCollectionName).process(cloudClient);\n    } catch (Exception e) {\n      // don't fail the test\n      log.warn(\"Could not delete collection {} after test completed\", testCollectionName);\n    }\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionReloadTest#testReloadedLeaderStateAfterZkSessionLoss().mjava","sourceNew":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","sourceOld":"  @Test\n  public void testReloadedLeaderStateAfterZkSessionLoss() throws Exception {\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss initialized OK ... running test logic\");\n\n    final String testCollectionName = \"c8n_1x1\";\n    CollectionAdminRequest.createCollection(testCollectionName, \"conf\", 1, 1)\n        .process(cluster.getSolrClient());\n\n    Replica leader\n        = cluster.getSolrClient().getZkStateReader().getLeaderRetry(testCollectionName, \"shard1\", DEFAULT_TIMEOUT);\n\n    long coreStartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n    CollectionAdminRequest.reloadCollection(testCollectionName).process(cluster.getSolrClient());\n\n    RetryUtil.retryUntil(\"Timed out waiting for core to reload\", 30, 1000, TimeUnit.MILLISECONDS, () -> {\n      long restartTime = 0;\n      try {\n        restartTime = getCoreStatus(leader).getCoreStartTime().getTime();\n      } catch (Exception e) {\n        log.warn(\"Exception getting core start time: {}\", e.getMessage());\n        return false;\n      }\n      return restartTime > coreStartTime;\n    });\n\n    final int initialStateVersion = getCollectionState(testCollectionName).getZNodeVersion();\n\n    cluster.expireZkSession(cluster.getReplicaJetty(leader));\n\n    waitForState(\"Timed out waiting for core to re-register as ACTIVE after session expiry\", testCollectionName, (n, c) -> {\n      log.info(\"Collection state: {}\", c.toString());\n      Replica expiredReplica = c.getReplica(leader.getName());\n      return expiredReplica.getState() == Replica.State.ACTIVE && c.getZNodeVersion() > initialStateVersion;\n    });\n\n    log.info(\"testReloadedLeaderStateAfterZkSessionLoss succeeded ... shutting down now!\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1967bed916cc89da82a1c2085f27976da6d08cbd","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"d0e67453ef2c855797898e384afc5dd4a4d6bac5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1967bed916cc89da82a1c2085f27976da6d08cbd":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3","5a02c54923e5f4de08097fa9028e09e8cf5caa82"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["d0e67453ef2c855797898e384afc5dd4a4d6bac5"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"5a02c54923e5f4de08097fa9028e09e8cf5caa82":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3","1967bed916cc89da82a1c2085f27976da6d08cbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1967bed916cc89da82a1c2085f27976da6d08cbd":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d0e67453ef2c855797898e384afc5dd4a4d6bac5":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d0e67453ef2c855797898e384afc5dd4a4d6bac5"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3"],"29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3":["1967bed916cc89da82a1c2085f27976da6d08cbd","5a02c54923e5f4de08097fa9028e09e8cf5caa82","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"5a02c54923e5f4de08097fa9028e09e8cf5caa82":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}