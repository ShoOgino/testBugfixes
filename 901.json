{"path":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.perThread.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreads();\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > maxRamSoFar && next.perThread.getNumDocsInRAM() > 0) {\n          maxRamSoFar = nextRam;\n          maxRamUsingThreadState = next;\n        }\n      }\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.perThread.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreads();\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > maxRamSoFar && next.perThread.getNumDocsInRAM() > 0) {\n          maxRamSoFar = nextRam;\n          maxRamUsingThreadState = next;\n        }\n      }\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","date":1329061481,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > maxRamSoFar && next.dwpt.getNumDocsInRAM() > 0) {\n          maxRamSoFar = nextRam;\n          maxRamUsingThreadState = next;\n        }\n      }\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.perThread.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreads();\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > maxRamSoFar && next.perThread.getNumDocsInRAM() > 0) {\n          maxRamSoFar = nextRam;\n          maxRamUsingThreadState = next;\n        }\n      }\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b22f57666273c2c1f71d0151a6a35245741fcd06","date":1399627618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > maxRamSoFar && next.dwpt.getNumDocsInRAM() > 0) {\n          maxRamSoFar = nextRam;\n          maxRamUsingThreadState = next;\n        }\n      }\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c854b8b24d8ca0061ba83cc6437f3dd0615684f","date":1400356148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4be95c403f45330d2a078afc9b6fab4515c8ce","date":1512064647,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = control.findLargestNonPendingWriter();\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = control.findLargestNonPendingWriter();\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    long maxRamSoFar = perThreadState.bytesUsed;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = perThreadState;\n    assert !perThreadState.flushPending : \"DWPT should have flushed\";\n    Iterator<ThreadState> activePerThreadsIterator = control.allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,DocumentsWriterPerThread).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FlushPolicy#findLargestNonPendingWriter(DocumentsWriterFlushControl,ThreadState).mjava","sourceNew":"  /**\n   * Returns the current most RAM consuming non-pending {@link DocumentsWriterPerThread} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected DocumentsWriterPerThread findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, DocumentsWriterPerThread perThread) {\n    assert perThread.getNumDocsInRAM() > 0;\n    // the dwpt which needs to be flushed eventually\n    DocumentsWriterPerThread maxRamUsingWriter = control.findLargestNonPendingWriter();\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingWriter;\n  }\n\n","sourceOld":"  /**\n   * Returns the current most RAM consuming non-pending {@link ThreadState} with\n   * at least one indexed document.\n   * <p>\n   * This method will never return <code>null</code>\n   */\n  protected ThreadState findLargestNonPendingWriter(\n      DocumentsWriterFlushControl control, ThreadState perThreadState) {\n    assert perThreadState.dwpt.getNumDocsInRAM() > 0;\n    // the dwpt which needs to be flushed eventually\n    ThreadState maxRamUsingThreadState = control.findLargestNonPendingWriter();\n    assert assertMessage(\"set largest ram consuming thread pending on lower watermark\");\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"264935965977b4a9e2f3920420647072c9c49176":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["3c854b8b24d8ca0061ba83cc6437f3dd0615684f","ad4be95c403f45330d2a078afc9b6fab4515c8ce"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad4be95c403f45330d2a078afc9b6fab4515c8ce":["3c854b8b24d8ca0061ba83cc6437f3dd0615684f"],"56572ec06f1407c066d6b7399413178b33176cd8":["b22f57666273c2c1f71d0151a6a35245741fcd06","3c854b8b24d8ca0061ba83cc6437f3dd0615684f"],"3c854b8b24d8ca0061ba83cc6437f3dd0615684f":["b22f57666273c2c1f71d0151a6a35245741fcd06"],"b22f57666273c2c1f71d0151a6a35245741fcd06":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["264935965977b4a9e2f3920420647072c9c49176"],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"264935965977b4a9e2f3920420647072c9c49176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["264935965977b4a9e2f3920420647072c9c49176"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ad4be95c403f45330d2a078afc9b6fab4515c8ce":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"3c854b8b24d8ca0061ba83cc6437f3dd0615684f":["1aad05eeff7818b0833c02ac6b743aa72054963b","ad4be95c403f45330d2a078afc9b6fab4515c8ce","56572ec06f1407c066d6b7399413178b33176cd8"],"b22f57666273c2c1f71d0151a6a35245741fcd06":["56572ec06f1407c066d6b7399413178b33176cd8","3c854b8b24d8ca0061ba83cc6437f3dd0615684f"],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["b22f57666273c2c1f71d0151a6a35245741fcd06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}