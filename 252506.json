{"path":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","commits":[{"id":"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","date":1439091488,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Sholdn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads shoul be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","sourceNew":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Shouldn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads should be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Sholdn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads shoul be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","sourceNew":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Shouldn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads should be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Sholdn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads shoul be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock#testReloadDeadlock().mjava","sourceNew":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Shouldn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads should be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testReloadDeadlock() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(5);\n    final int deleteByQueryPercent = 20 + random().nextInt(20);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(50));\n    int nWriteThreads = 5 + random().nextInt(10);\n\n    // query variables\n    final AtomicLong reloads = new AtomicLong(50);  // number of reloads. Increase this number to force failure.\n\n    ifVerbose(\"commitPercent\", commitPercent, \"deleteByQueryPercent\", deleteByQueryPercent\n        , \"ndocs\", ndocs, \"nWriteThreads\", nWriteThreads, \"reloads\", reloads);\n\n    initModel(ndocs);\n\n    final AtomicBoolean areCommitting = new AtomicBoolean();\n\n    List<Thread> threads = new ArrayList<>();\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n    for (int i = 0; i < nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\" + i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (reloads.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (areCommitting.compareAndSet(false, true)) {\n                  Map<Integer, DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized (TestReloadDeadlock.this) {\n                    newCommittedModel = new HashMap<>(model);  // take a snapshot\n                    version = snapshotCount++;\n                  }\n\n                  ifVerbose(\"hardCommit start\");\n                  assertU(commit());\n                  ifVerbose(\"hardCommit end\");\n\n                  synchronized (TestReloadDeadlock.this) {\n                    // install this model snapshot only if it's newer than the current one\n                    if (version >= committedModelClock) {\n                      ifVerbose(\"installing new committedModel version=\" + committedModelClock);\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                  areCommitting.set(false);\n                }\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  // reuse the last ID half of the time to force more race conditions\n              }\n\n              // set the lastId before we actually change it sometimes to try and\n              // uncover more race conditions between writing and reading\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val) + 1;\n\n              long version = testVersion.incrementAndGet();\n\n              // yield after getting the next version to increase the odds of updates happening out of order\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deleteByQueryPercent) {\n                deleteByQuery(id, nextVal, version);\n              } else {\n                addDoc(id, nextVal, version);\n              }\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            reloads.set(-1L);\n            log.error(\"\", e);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    // The reload operation really doesn't need to happen from multiple threads, we just want it firing pretty often.\n    while (reloads.get() > 0) {\n      Thread.sleep(10 + random().nextInt(250));\n      reloads.decrementAndGet();\n      h.getCoreContainer().reload(\"collection1\");\n    }\n\n    try {\n      for (Thread thread : threads) {\n        thread.join(10000); // Normally they'll all return immediately (or close to that).\n      }\n    } catch (InterruptedException ie) {\n      fail(\"Sholdn't have sat around here this long waiting for the threads to join.\");\n    }\n    for (Thread thread : threads) { // Probably a silly test, but what the heck.\n      assertFalse(\"All threads shoul be dead, but at least thread \" + thread.getName() + \" is not\", thread.isAlive());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}