{"path":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","commits":[{"id":"cb88a28fb92adce0607c5b28f8f1cce9e3171639","date":1492689807,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"/dev/null","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList, \n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"docFreq\", (long) docFreq);\n            termStats.add(\"totalTermFreq\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60481acc5083329d2ffbf27397331a25baad88de","date":1492691547,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList, \n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"docFreq\", (long) docFreq);\n            termStats.add(\"totalTermFreq\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"/dev/null","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a92ffe0d2961113e5588e614f8dc22b42bf10a95","date":1503304229,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f7ebafe1543d3847a1cb09988cb6c46d48741f8","date":1503180131,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3051d6122751c8f6cc1e9cf24592658b59843ec2","date":1503298024,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      FieldType fieldType = indexSearcher.getSchema().getField(field).getType();\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46464f0986d463eb98c702a5d34c185304c6b06b","date":1503590145,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"182384b20c064aa16998ddebe9f36e649279c5a6","date":1503596494,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acc205c9a28b75ff49ea105240dd87c1a9687342","date":1503604483,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82873e945a4c6bea4384112b77e7ee51832428e5","date":1503643945,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    String[] splitTerms = termList.split(\",\");\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    // Sort the terms once\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermStates[] termStates = new TermStates[terms.length];\n      collectTermStates(topReaderContext, termStates, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termStates[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termStates[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termStates[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermStates[] termStates = new TermStates[terms.length];\n      collectTermStates(topReaderContext, termStates, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termStates[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termStates[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termStates[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermContext[] termContexts = new TermContext[terms.length];\n      collectTermContext(topReaderContext, termContexts, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termContexts[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termContexts[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termContexts[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a45ddee14ecadf18bc50fff428911687afb4745d","date":1560519742,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      \n      if (fieldType.isPointField()) {\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n      } else {\n\n        // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n        Term[] terms = new Term[splitTerms.length];\n        for (int i = 0; i < splitTerms.length; i++) {\n          terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n        }\n  \n        TermStates[] termStates = new TermStates[terms.length];\n        collectTermStates(topReaderContext, termStates, terms);\n  \n        for (int i = 0; i < terms.length; i++) {\n          if (termStates[i] != null) {\n            String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n            int docFreq = termStates[i].docFreq();\n            addTermToNamedList(termsMap, outTerm, docFreq, termStates[i].totalTermFreq(), includeTotalTermFreq);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n\n      if (fieldType.isPointField()) {\n        NamedList<Object> termsMap = new SimpleOrderedMap<>();\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n        result.add(field, termsMap);\n        continue;\n      }\n\n      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n      Term[] terms = new Term[splitTerms.length];\n      for (int i = 0; i < splitTerms.length; i++) {\n        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n      }\n\n      TermStates[] termStates = new TermStates[terms.length];\n      collectTermStates(topReaderContext, termStates, terms);\n\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      for (int i = 0; i < terms.length; i++) {\n        if (termStates[i] != null) {\n          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n          int docFreq = termStates[i].docFreq();\n          if (!includeTotalTermFreq) {\n            termsMap.add(outTerm, docFreq);\n          } else {\n            long totalTermFreq = termStates[i].totalTermFreq();\n            NamedList<Long> termStats = new SimpleOrderedMap<>();\n            termStats.add(\"df\", (long) docFreq);\n            termStats.add(\"ttf\", totalTermFreq);\n            termsMap.add(outTerm, termStats);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":["a6e9f769521480a623f897c0d59089b919fa4239","2f7ebafe1543d3847a1cb09988cb6c46d48741f8","cb88a28fb92adce0607c5b28f8f1cce9e3171639","60481acc5083329d2ffbf27397331a25baad88de","46464f0986d463eb98c702a5d34c185304c6b06b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8998ebc47a334c61dfed58318c481a7d84e3eaeb","date":1560839882,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#fetchTerms(SolrIndexSearcher,String[],String,boolean,NamedList[Object]).mjava","sourceNew":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n      NamedList<Object> termsMap = new NamedList<>();\n\n      if (fieldType.isPointField()) {\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n      } else {\n\n        // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n        Term[] terms = new Term[splitTerms.length];\n        for (int i = 0; i < splitTerms.length; i++) {\n          terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n        }\n\n        TermStates[] termStates = new TermStates[terms.length];\n        collectTermStates(topReaderContext, termStates, terms);\n\n        for (int i = 0; i < terms.length; i++) {\n          if (termStates[i] != null) {\n            String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n            int docFreq = termStates[i].docFreq();\n            addTermToNamedList(termsMap, outTerm, docFreq, termStates[i].totalTermFreq(), includeTotalTermFreq);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","sourceOld":"  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,\n      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {\n    List<String> splitTermList = StrUtils.splitSmart(termList, \",\", true);\n    // Sort the terms once\n    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);\n    // Not a great idea to trim here, but it was in the original implementation\n    for (int i = 0; i < splitTerms.length; i++) {\n      splitTerms[i] = splitTerms[i].trim();\n    }\n    Arrays.sort(splitTerms);\n\n    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();\n    for (String field : fields) {\n      SchemaField sf = indexSearcher.getSchema().getField(field);\n      FieldType fieldType = sf.getType();\n      NamedList<Object> termsMap = new SimpleOrderedMap<>();\n      \n      if (fieldType.isPointField()) {\n        for (String term : splitTerms) {\n          Query q = fieldType.getFieldQuery(null, sf, term);\n          int count = indexSearcher.getDocSet(q).size();\n          termsMap.add(term, count);\n        }\n      } else {\n\n        // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.\n        Term[] terms = new Term[splitTerms.length];\n        for (int i = 0; i < splitTerms.length; i++) {\n          terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));\n        }\n  \n        TermStates[] termStates = new TermStates[terms.length];\n        collectTermStates(topReaderContext, termStates, terms);\n  \n        for (int i = 0; i < terms.length; i++) {\n          if (termStates[i] != null) {\n            String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());\n            int docFreq = termStates[i].docFreq();\n            addTermToNamedList(termsMap, outTerm, docFreq, termStates[i].totalTermFreq(), includeTotalTermFreq);\n          }\n        }\n      }\n\n      result.add(field, termsMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"acc205c9a28b75ff49ea105240dd87c1a9687342":["182384b20c064aa16998ddebe9f36e649279c5a6"],"b94236357aaa22b76c10629851fe4e376e0cea82":["82873e945a4c6bea4384112b77e7ee51832428e5","a6e9f769521480a623f897c0d59089b919fa4239"],"60481acc5083329d2ffbf27397331a25baad88de":["cb88a28fb92adce0607c5b28f8f1cce9e3171639"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":["e9017cf144952056066919f1ebc7897ff9bd71b1","2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["60481acc5083329d2ffbf27397331a25baad88de","2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"46464f0986d463eb98c702a5d34c185304c6b06b":["a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"82873e945a4c6bea4384112b77e7ee51832428e5":["182384b20c064aa16998ddebe9f36e649279c5a6","acc205c9a28b75ff49ea105240dd87c1a9687342"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","60481acc5083329d2ffbf27397331a25baad88de"],"a6e9f769521480a623f897c0d59089b919fa4239":["82873e945a4c6bea4384112b77e7ee51832428e5"],"cb88a28fb92adce0607c5b28f8f1cce9e3171639":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a45ddee14ecadf18bc50fff428911687afb4745d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["3051d6122751c8f6cc1e9cf24592658b59843ec2","82873e945a4c6bea4384112b77e7ee51832428e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f7ebafe1543d3847a1cb09988cb6c46d48741f8":["60481acc5083329d2ffbf27397331a25baad88de"],"182384b20c064aa16998ddebe9f36e649279c5a6":["a92ffe0d2961113e5588e614f8dc22b42bf10a95","46464f0986d463eb98c702a5d34c185304c6b06b"],"8998ebc47a334c61dfed58318c481a7d84e3eaeb":["a45ddee14ecadf18bc50fff428911687afb4745d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8998ebc47a334c61dfed58318c481a7d84e3eaeb"]},"commit2Childs":{"acc205c9a28b75ff49ea105240dd87c1a9687342":["82873e945a4c6bea4384112b77e7ee51832428e5"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a45ddee14ecadf18bc50fff428911687afb4745d"],"60481acc5083329d2ffbf27397331a25baad88de":["a92ffe0d2961113e5588e614f8dc22b42bf10a95","e9017cf144952056066919f1ebc7897ff9bd71b1","2f7ebafe1543d3847a1cb09988cb6c46d48741f8"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["46464f0986d463eb98c702a5d34c185304c6b06b","182384b20c064aa16998ddebe9f36e649279c5a6"],"46464f0986d463eb98c702a5d34c185304c6b06b":["182384b20c064aa16998ddebe9f36e649279c5a6"],"82873e945a4c6bea4384112b77e7ee51832428e5":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["3051d6122751c8f6cc1e9cf24592658b59843ec2"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cb88a28fb92adce0607c5b28f8f1cce9e3171639":["60481acc5083329d2ffbf27397331a25baad88de"],"a45ddee14ecadf18bc50fff428911687afb4745d":["8998ebc47a334c61dfed58318c481a7d84e3eaeb"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"182384b20c064aa16998ddebe9f36e649279c5a6":["acc205c9a28b75ff49ea105240dd87c1a9687342","82873e945a4c6bea4384112b77e7ee51832428e5"],"2f7ebafe1543d3847a1cb09988cb6c46d48741f8":["3051d6122751c8f6cc1e9cf24592658b59843ec2","a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","cb88a28fb92adce0607c5b28f8f1cce9e3171639"],"8998ebc47a334c61dfed58318c481a7d84e3eaeb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}