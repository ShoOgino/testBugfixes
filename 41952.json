{"path":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws IOException {\n\n    if (args.length != 1) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockVerifyServer port\\n\");\n      System.exit(1);\n    }\n\n    final int port = Integer.parseInt(args[0]);\n\n    ServerSocket s = new ServerSocket(port);\n    s.setReuseAddress(true);\n    System.out.println(\"\\nReady on port \" + port + \"...\");\n\n    int lockedID = 0;\n    long startTime = System.currentTimeMillis();\n\n    while(true) {\n      Socket cs = s.accept();\n      OutputStream out = cs.getOutputStream();\n      InputStream in = cs.getInputStream();\n\n      int id = in.read();\n      int command = in.read();\n\n      boolean err = false;\n\n      if (command == 1) {\n        // Locked\n        if (lockedID != 0) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" got lock, but \" + lockedID + \" already holds the lock\");\n        }\n        lockedID = id;\n      } else if (command == 0) {\n        if (lockedID != id) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" released the lock, but \" + lockedID + \" is the one holding the lock\");\n        }\n        lockedID = 0;\n      } else\n        throw new RuntimeException(\"unrecognized command \" + command);\n\n      System.out.print(\".\");\n\n      if (err)\n        out.write(1);\n      else\n        out.write(0);\n\n      out.close();\n      in.close();\n      cs.close();\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws IOException {\n\n    if (args.length != 1) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockVerifyServer port\\n\");\n      System.exit(1);\n    }\n\n    final int port = Integer.parseInt(args[0]);\n\n    ServerSocket s = new ServerSocket(port);\n    s.setReuseAddress(true);\n    System.out.println(\"\\nReady on port \" + port + \"...\");\n\n    int lockedID = 0;\n    long startTime = System.currentTimeMillis();\n\n    while(true) {\n      Socket cs = s.accept();\n      OutputStream out = cs.getOutputStream();\n      InputStream in = cs.getInputStream();\n\n      int id = in.read();\n      int command = in.read();\n\n      boolean err = false;\n\n      if (command == 1) {\n        // Locked\n        if (lockedID != 0) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" got lock, but \" + lockedID + \" already holds the lock\");\n        }\n        lockedID = id;\n      } else if (command == 0) {\n        if (lockedID != id) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" released the lock, but \" + lockedID + \" is the one holding the lock\");\n        }\n        lockedID = 0;\n      } else\n        throw new RuntimeException(\"unrecognized command \" + command);\n\n      System.out.print(\".\");\n\n      if (err)\n        out.write(1);\n      else\n        out.write(0);\n\n      out.close();\n      in.close();\n      cs.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"813fc8a2a50c4f282fc2463daeb353492aceabbd","date":1397856769,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 2) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockVerifyServer bindToIp clients\\n\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final String hostname = args[arg++];\n    final int maxClients = Integer.parseInt(args[arg++]);\n\n    try (final ServerSocket s = new ServerSocket()) {\n      s.setReuseAddress(true);\n      s.setSoTimeout(30000); // initially 30 secs to give clients enough time to startup\n      s.bind(new InetSocketAddress(hostname, 0));\n      final InetSocketAddress localAddr = (InetSocketAddress) s.getLocalSocketAddress();\n      System.out.println(\"Listening on \" + localAddr + \"...\");\n      \n      // we set the port as a sysprop, so the ANT task can read it. For that to work, this server must run in-process:\n      System.setProperty(\"lockverifyserver.port\", Integer.toString(localAddr.getPort()));\n      \n      final Object localLock = new Object();\n      final int[] lockedID = new int[1];\n      lockedID[0] = -1;\n      final CountDownLatch startingGun = new CountDownLatch(1);\n      final Thread[] threads = new Thread[maxClients];\n      \n      for (int count = 0; count < maxClients; count++) {\n        final Socket cs = s.accept();\n        threads[count] = new Thread() {\n          @Override\n          public void run() {\n            try (InputStream in = cs.getInputStream(); OutputStream os = cs.getOutputStream()) {\n              final int id = in.read();\n              if (id < 0) {\n                throw new IOException(\"Client closed connection before communication started.\");\n              }\n              \n              startingGun.await();\n              os.write(43);\n              os.flush();\n              \n              while(true) {\n                final int command = in.read();\n                if (command < 0) {\n                  return; // closed\n                }\n                \n                synchronized(localLock) {\n                  final int currentLock = lockedID[0];\n                  if (currentLock == -2) {\n                    return; // another thread got error, so we exit, too!\n                  }\n                  switch (command) {\n                    case 1:\n                      // Locked\n                      if (currentLock != -1) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" got lock, but \" + currentLock + \" already holds the lock\");\n                      }\n                      lockedID[0] = id;\n                      break;\n                    case 0:\n                      // Unlocked\n                      if (currentLock != id) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" released the lock, but \" + currentLock + \" is the one holding the lock\");\n                      }\n                      lockedID[0] = -1;\n                      break;\n                    default:\n                      throw new RuntimeException(\"Unrecognized command: \" + command);\n                  }\n                  os.write(command);\n                  os.flush();\n                }\n              }\n            } catch (RuntimeException | Error e) {\n              throw e;\n            } catch (Exception ioe) {\n              throw new RuntimeException(ioe);\n            } finally {\n              IOUtils.closeWhileHandlingException(cs);\n            }\n          }\n        };\n        threads[count].start();\n      }\n      \n      // start\n      System.out.println(\"All clients started, fire gun...\");\n      startingGun.countDown();\n      \n      // wait for all threads to finish\n      for (Thread t : threads) {\n        t.join();\n      }\n      \n      // cleanup sysprop\n      System.clearProperty(\"lockverifyserver.port\");\n\n      System.out.println(\"Server terminated.\");\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws IOException {\n\n    if (args.length != 1) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockVerifyServer port\\n\");\n      System.exit(1);\n    }\n\n    final int port = Integer.parseInt(args[0]);\n\n    ServerSocket s = new ServerSocket(port);\n    s.setReuseAddress(true);\n    System.out.println(\"\\nReady on port \" + port + \"...\");\n\n    int lockedID = 0;\n    long startTime = System.currentTimeMillis();\n\n    while(true) {\n      Socket cs = s.accept();\n      OutputStream out = cs.getOutputStream();\n      InputStream in = cs.getInputStream();\n\n      int id = in.read();\n      int command = in.read();\n\n      boolean err = false;\n\n      if (command == 1) {\n        // Locked\n        if (lockedID != 0) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" got lock, but \" + lockedID + \" already holds the lock\");\n        }\n        lockedID = id;\n      } else if (command == 0) {\n        if (lockedID != id) {\n          err = true;\n          System.out.println(getTime(startTime) + \" ERROR: id \" + id + \" released the lock, but \" + lockedID + \" is the one holding the lock\");\n        }\n        lockedID = 0;\n      } else\n        throw new RuntimeException(\"unrecognized command \" + command);\n\n      System.out.print(\".\");\n\n      if (err)\n        out.write(1);\n      else\n        out.write(0);\n\n      out.close();\n      in.close();\n      cs.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e6d6f6217dc04f29ee177d2837147dd47627787","date":1429543326,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  public static void main(String[] args) throws Exception {\n\n    if (args.length != 2) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockVerifyServer bindToIp clients\\n\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final String hostname = args[arg++];\n    final int maxClients = Integer.parseInt(args[arg++]);\n\n    try (final ServerSocket s = new ServerSocket()) {\n      s.setReuseAddress(true);\n      s.setSoTimeout(30000); // initially 30 secs to give clients enough time to startup\n      s.bind(new InetSocketAddress(hostname, 0));\n      final InetSocketAddress localAddr = (InetSocketAddress) s.getLocalSocketAddress();\n      System.out.println(\"Listening on \" + localAddr + \"...\");\n      \n      // we set the port as a sysprop, so the ANT task can read it. For that to work, this server must run in-process:\n      System.setProperty(\"lockverifyserver.port\", Integer.toString(localAddr.getPort()));\n      \n      final Object localLock = new Object();\n      final int[] lockedID = new int[1];\n      lockedID[0] = -1;\n      final CountDownLatch startingGun = new CountDownLatch(1);\n      final Thread[] threads = new Thread[maxClients];\n      \n      for (int count = 0; count < maxClients; count++) {\n        final Socket cs = s.accept();\n        threads[count] = new Thread() {\n          @Override\n          public void run() {\n            try (InputStream in = cs.getInputStream(); OutputStream os = cs.getOutputStream()) {\n              final int id = in.read();\n              if (id < 0) {\n                throw new IOException(\"Client closed connection before communication started.\");\n              }\n              \n              startingGun.await();\n              os.write(43);\n              os.flush();\n              \n              while(true) {\n                final int command = in.read();\n                if (command < 0) {\n                  return; // closed\n                }\n                \n                synchronized(localLock) {\n                  final int currentLock = lockedID[0];\n                  if (currentLock == -2) {\n                    return; // another thread got error, so we exit, too!\n                  }\n                  switch (command) {\n                    case 1:\n                      // Locked\n                      if (currentLock != -1) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" got lock, but \" + currentLock + \" already holds the lock\");\n                      }\n                      lockedID[0] = id;\n                      break;\n                    case 0:\n                      // Unlocked\n                      if (currentLock != id) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" released the lock, but \" + currentLock + \" is the one holding the lock\");\n                      }\n                      lockedID[0] = -1;\n                      break;\n                    default:\n                      throw new RuntimeException(\"Unrecognized command: \" + command);\n                  }\n                  os.write(command);\n                  os.flush();\n                }\n              }\n            } catch (RuntimeException | Error e) {\n              throw e;\n            } catch (Exception ioe) {\n              throw new RuntimeException(ioe);\n            } finally {\n              IOUtils.closeWhileHandlingException(cs);\n            }\n          }\n        };\n        threads[count].start();\n      }\n      \n      // start\n      System.out.println(\"All clients started, fire gun...\");\n      startingGun.countDown();\n      \n      // wait for all threads to finish\n      for (Thread t : threads) {\n        t.join();\n      }\n      \n      // cleanup sysprop\n      System.clearProperty(\"lockverifyserver.port\");\n\n      System.out.println(\"Server terminated.\");\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 2) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockVerifyServer bindToIp clients\\n\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final String hostname = args[arg++];\n    final int maxClients = Integer.parseInt(args[arg++]);\n\n    try (final ServerSocket s = new ServerSocket()) {\n      s.setReuseAddress(true);\n      s.setSoTimeout(30000); // initially 30 secs to give clients enough time to startup\n      s.bind(new InetSocketAddress(hostname, 0));\n      final InetSocketAddress localAddr = (InetSocketAddress) s.getLocalSocketAddress();\n      System.out.println(\"Listening on \" + localAddr + \"...\");\n      \n      // we set the port as a sysprop, so the ANT task can read it. For that to work, this server must run in-process:\n      System.setProperty(\"lockverifyserver.port\", Integer.toString(localAddr.getPort()));\n      \n      final Object localLock = new Object();\n      final int[] lockedID = new int[1];\n      lockedID[0] = -1;\n      final CountDownLatch startingGun = new CountDownLatch(1);\n      final Thread[] threads = new Thread[maxClients];\n      \n      for (int count = 0; count < maxClients; count++) {\n        final Socket cs = s.accept();\n        threads[count] = new Thread() {\n          @Override\n          public void run() {\n            try (InputStream in = cs.getInputStream(); OutputStream os = cs.getOutputStream()) {\n              final int id = in.read();\n              if (id < 0) {\n                throw new IOException(\"Client closed connection before communication started.\");\n              }\n              \n              startingGun.await();\n              os.write(43);\n              os.flush();\n              \n              while(true) {\n                final int command = in.read();\n                if (command < 0) {\n                  return; // closed\n                }\n                \n                synchronized(localLock) {\n                  final int currentLock = lockedID[0];\n                  if (currentLock == -2) {\n                    return; // another thread got error, so we exit, too!\n                  }\n                  switch (command) {\n                    case 1:\n                      // Locked\n                      if (currentLock != -1) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" got lock, but \" + currentLock + \" already holds the lock\");\n                      }\n                      lockedID[0] = id;\n                      break;\n                    case 0:\n                      // Unlocked\n                      if (currentLock != id) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" released the lock, but \" + currentLock + \" is the one holding the lock\");\n                      }\n                      lockedID[0] = -1;\n                      break;\n                    default:\n                      throw new RuntimeException(\"Unrecognized command: \" + command);\n                  }\n                  os.write(command);\n                  os.flush();\n                }\n              }\n            } catch (RuntimeException | Error e) {\n              throw e;\n            } catch (Exception ioe) {\n              throw new RuntimeException(ioe);\n            } finally {\n              IOUtils.closeWhileHandlingException(cs);\n            }\n          }\n        };\n        threads[count].start();\n      }\n      \n      // start\n      System.out.println(\"All clients started, fire gun...\");\n      startingGun.countDown();\n      \n      // wait for all threads to finish\n      for (Thread t : threads) {\n        t.join();\n      }\n      \n      // cleanup sysprop\n      System.clearProperty(\"lockverifyserver.port\");\n\n      System.out.println(\"Server terminated.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760","date":1599669750,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    if (args.length != 2) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockVerifyServer bindToIp clients\\n\");\n      System.exit(1);\n    }\n\n    run(args[0], Integer.parseInt(args[1]), addr -> {});\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  public static void main(String[] args) throws Exception {\n\n    if (args.length != 2) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockVerifyServer bindToIp clients\\n\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final String hostname = args[arg++];\n    final int maxClients = Integer.parseInt(args[arg++]);\n\n    try (final ServerSocket s = new ServerSocket()) {\n      s.setReuseAddress(true);\n      s.setSoTimeout(30000); // initially 30 secs to give clients enough time to startup\n      s.bind(new InetSocketAddress(hostname, 0));\n      final InetSocketAddress localAddr = (InetSocketAddress) s.getLocalSocketAddress();\n      System.out.println(\"Listening on \" + localAddr + \"...\");\n      \n      // we set the port as a sysprop, so the ANT task can read it. For that to work, this server must run in-process:\n      System.setProperty(\"lockverifyserver.port\", Integer.toString(localAddr.getPort()));\n      \n      final Object localLock = new Object();\n      final int[] lockedID = new int[1];\n      lockedID[0] = -1;\n      final CountDownLatch startingGun = new CountDownLatch(1);\n      final Thread[] threads = new Thread[maxClients];\n      \n      for (int count = 0; count < maxClients; count++) {\n        final Socket cs = s.accept();\n        threads[count] = new Thread() {\n          @Override\n          public void run() {\n            try (InputStream in = cs.getInputStream(); OutputStream os = cs.getOutputStream()) {\n              final int id = in.read();\n              if (id < 0) {\n                throw new IOException(\"Client closed connection before communication started.\");\n              }\n              \n              startingGun.await();\n              os.write(43);\n              os.flush();\n              \n              while(true) {\n                final int command = in.read();\n                if (command < 0) {\n                  return; // closed\n                }\n                \n                synchronized(localLock) {\n                  final int currentLock = lockedID[0];\n                  if (currentLock == -2) {\n                    return; // another thread got error, so we exit, too!\n                  }\n                  switch (command) {\n                    case 1:\n                      // Locked\n                      if (currentLock != -1) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" got lock, but \" + currentLock + \" already holds the lock\");\n                      }\n                      lockedID[0] = id;\n                      break;\n                    case 0:\n                      // Unlocked\n                      if (currentLock != id) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" released the lock, but \" + currentLock + \" is the one holding the lock\");\n                      }\n                      lockedID[0] = -1;\n                      break;\n                    default:\n                      throw new RuntimeException(\"Unrecognized command: \" + command);\n                  }\n                  os.write(command);\n                  os.flush();\n                }\n              }\n            } catch (RuntimeException | Error e) {\n              throw e;\n            } catch (Exception ioe) {\n              throw new RuntimeException(ioe);\n            } finally {\n              IOUtils.closeWhileHandlingException(cs);\n            }\n          }\n        };\n        threads[count].start();\n      }\n      \n      // start\n      System.out.println(\"All clients started, fire gun...\");\n      startingGun.countDown();\n      \n      // wait for all threads to finish\n      for (Thread t : threads) {\n        t.join();\n      }\n      \n      // cleanup sysprop\n      System.clearProperty(\"lockverifyserver.port\");\n\n      System.out.println(\"Server terminated.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e6d6f6217dc04f29ee177d2837147dd47627787":["813fc8a2a50c4f282fc2463daeb353492aceabbd"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"813fc8a2a50c4f282fc2463daeb353492aceabbd":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["7e6d6f6217dc04f29ee177d2837147dd47627787"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"]},"commit2Childs":{"7e6d6f6217dc04f29ee177d2837147dd47627787":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["813fc8a2a50c4f282fc2463daeb353492aceabbd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"813fc8a2a50c4f282fc2463daeb353492aceabbd":["7e6d6f6217dc04f29ee177d2837147dd47627787"],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}