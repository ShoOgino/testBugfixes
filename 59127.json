{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","commits":[{"id":"0acfa728bc42d7e2f275b294280ebfe610828af7","date":1507795704,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(controllerClient, new Overseer.Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      assertTrue(workQueue.peek() == null);\n      assertTrue(q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","sourceNew":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(controllerClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      assertTrue(workQueue.peek() == null);\n      assertTrue(q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(controllerClient, new Overseer.Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      assertTrue(workQueue.peek() == null);\n      assertTrue(q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","sourceNew":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(zkClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = getOpenOverseer().getStateUpdateQueue();\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      while(!timeOut.hasTimedOut()) {\n        if (q.peek() == null) {\n          break;\n        }\n        Thread.sleep(50);\n      }\n      \n      assertTrue(showQpeek(workQueue), workQueue.peek() == null);\n      assertTrue(showQpeek(q),  q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(controllerClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      assertTrue(workQueue.peek() == null);\n      assertTrue(q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":["0acfa728bc42d7e2f275b294280ebfe610828af7","85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","sourceNew":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(zkClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = getOpenOverseer().getStateUpdateQueue();\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      while(!timeOut.hasTimedOut()) {\n        if (q.peek() == null) {\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      assertTrue(showQpeek(workQueue), workQueue.peek() == null);\n      assertTrue(showQpeek(q),  q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(zkClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = getOpenOverseer().getStateUpdateQueue();\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      while(!timeOut.hasTimedOut()) {\n        if (q.peek() == null) {\n          break;\n        }\n        Thread.sleep(50);\n      }\n      \n      assertTrue(showQpeek(workQueue), workQueue.peek() == null);\n      assertTrue(showQpeek(q),  q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(reader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testExceptionWhenFlushClusterState().mjava","sourceNew":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections/collection1 -> this message will cause exception when Overseer tries to flush\n      // the collection state\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(zkClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = getOpenOverseer().getStateUpdateQueue();\n      q.offer(Utils.toJSON(badMessage));\n\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      while(!timeOut.hasTimedOut()) {\n        if (q.peek() == null) {\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      assertTrue(showQpeek(workQueue), workQueue.peek() == null);\n      assertTrue(showQpeek(q),  q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExceptionWhenFlushClusterState() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      // We did not create /collections -> this message will cause exception when Overseer try to flush the clusterstate\n      ZkNodeProps badMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection1\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"2\",\n          \"createNodeSet\", \"\");\n      ZkNodeProps goodMessage = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n          \"name\", \"collection2\",\n          ZkStateReader.REPLICATION_FACTOR, \"1\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          DocCollection.STATE_FORMAT, \"1\",\n          \"createNodeSet\", \"\");\n      ZkDistributedQueue workQueue = Overseer.getInternalWorkQueue(zkClient, new Stats());\n      workQueue.offer(Utils.toJSON(badMessage));\n      workQueue.offer(Utils.toJSON(goodMessage));\n      overseerClient = electNewOverseer(server.getZkAddress());\n      waitForCollections(reader, \"collection2\");\n\n      ZkDistributedQueue q = getOpenOverseer().getStateUpdateQueue();\n      q.offer(Utils.toJSON(badMessage));\n      q.offer(Utils.toJSON(goodMessage.plus(\"name\", \"collection3\")));\n      waitForCollections(reader, \"collection2\", \"collection3\");\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection2\"));\n      assertNotNull(reader.getClusterState().getCollectionOrNull(\"collection3\"));\n\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      while(!timeOut.hasTimedOut()) {\n        if (q.peek() == null) {\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      assertTrue(showQpeek(workQueue), workQueue.peek() == null);\n      assertTrue(showQpeek(q),  q.peek() == null);\n    } finally {\n      close(overseerClient);\n      close(reader);\n    }\n  }\n\n","bugFix":["0acfa728bc42d7e2f275b294280ebfe610828af7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["0acfa728bc42d7e2f275b294280ebfe610828af7"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0acfa728bc42d7e2f275b294280ebfe610828af7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0acfa728bc42d7e2f275b294280ebfe610828af7"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"0acfa728bc42d7e2f275b294280ebfe610828af7":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}