{"path":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","commits":[{"id":"2fff41ba33f73a49aabac5f5989da64c69ef6ba5","date":1354305675,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","pathOld":"/dev/null","sourceNew":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\" }) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","pathOld":"/dev/null","sourceNew":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\" }) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdac0dff04219451c7511d62225080a93a0181ea","date":1451212020,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","sourceNew":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F, 1.6F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\",\n                                       \"int\", \"xx_dyn_int\"}) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n          \n          // 1.6: useDocValuesAsStored defaults to true\n          assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                       ( v < 1.6F ? false : true), \n                       field.useDocValuesAsStored());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit useDocValuesAsStored values on field or type \n        // should be correct\n        for (String f : new String[] { \"ft_intdvas_f\", \"ft_intdvas_t\",\n                                        \"intdvas_f\", \"intdvas_t\",\n                                        \"xx_dyn_ft_intdvas_f\", \"xx_dyn_ft_intdvas_f\", \n                                        \"xx_dyn_intdvas_f\", \"xx_dyn_intdvas_f\"}) {\n\n          boolean expected = f.endsWith(\"dvas_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's useDocValuesAsStored is wrong for ver=\" + ver,\n                       expected, field.useDocValuesAsStored());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                         ( v < 1.6F ? false : true), \n                         ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          \n          }\n        }\n\n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","sourceOld":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\" }) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/SchemaVersionSpecificBehaviorTest#testVersionBehavior().mjava","sourceNew":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F, 1.6F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\",\n                                       \"int\", \"xx_dyn_int\"}) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n          \n          // 1.6: useDocValuesAsStored defaults to true\n          assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                       ( v < 1.6F ? false : true), \n                       field.useDocValuesAsStored());\n          \n          // uninvertable defaults to true (for now)\n          assertEquals(f + \" field's type has wrong uninvertable for ver=\" + ver,\n                       true,\n                       field.isUninvertible());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit useDocValuesAsStored values on field or type \n        // should be correct\n        for (String f : new String[] { \"ft_intdvas_f\", \"ft_intdvas_t\",\n                                        \"intdvas_f\", \"intdvas_t\",\n                                        \"xx_dyn_ft_intdvas_f\", \"xx_dyn_ft_intdvas_f\", \n                                        \"xx_dyn_intdvas_f\", \"xx_dyn_intdvas_f\"}) {\n\n          boolean expected = f.endsWith(\"dvas_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's useDocValuesAsStored is wrong for ver=\" + ver,\n                       expected, field.useDocValuesAsStored());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                         ( v < 1.6F ? false : true), \n                         ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          \n          }\n        }\n\n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","sourceOld":"  public void testVersionBehavior() throws Exception {\n    for (float v : new float[] { 1.0F, 1.1F, 1.2F, 1.3F, 1.4F, 1.5F, 1.6F }) {\n      try {\n        final IndexSchema schema = initCoreUsingSchemaVersion(v);\n        final String ver = String.valueOf(v);\n\n        // check defaults for fields where neither the field nor the field type\n        // have any properties set on them\n        for (String f : new String[] { \"text\", \"xx_dyn_text\",\n                                       \"bool\", \"xx_dyn_bool\",\n                                       \"str\", \"xx_dyn_str\",\n                                       \"int\", \"xx_dyn_int\"}) {\n\n          SchemaField field = schema.getField(f);\n\n          // 1.1: multiValued default changed\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       (v < 1.1F), field.multiValued());\n\n          // 1.2: omitTermFreqAndPositions default changed \n          // to true for non TextField\n          assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                       ( v < 1.2F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitTermFreqAndPositions());\n\n          // 1.4: autoGeneratePhraseQueries default changed to false\n          if (field.getType() instanceof TextField) {\n            TextField ft = (TextField) field.getType();\n            assertEquals(f + \" field's autoPhrase is wrong for ver=\" + ver,\n                         (v < 1.4F), ft.getAutoGeneratePhraseQueries());\n          }\n\n          // 1.5: omitNorms default changed to true for non TextField\n          assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                       ( v < 1.5F ? false : \n                         ! (field.getType() instanceof TextField)), \n                       field.omitNorms());\n          \n          // 1.6: useDocValuesAsStored defaults to true\n          assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                       ( v < 1.6F ? false : true), \n                       field.useDocValuesAsStored());\n        }\n\n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"multi_f\", \"multi_t\", \n                                       \"ft_multi_f\", \"ft_multi_t\",\n                                       \"xx_dyn_str_multi_f\",\n                                       \"xx_dyn_str_multi_t\",\n                                       \"xx_dyn_str_ft_multi_f\",\n                                       \"xx_dyn_str_ft_multi_t\"  }) {\n\n          boolean expected = f.endsWith(\"multi_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's multiValued is wrong for ver=\" + ver,\n                       expected, field.multiValued());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_multi\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's multiValued doesn't match type for ver=\" + ver,\n                         expected, ft.isMultiValued());\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong multiValued is wrong for ver=\" + ver,\n                         (v < 1.1F), ft.isMultiValued());\n          \n          }\n        }\n        \n        // regardless of version, explicit useDocValuesAsStored values on field or type \n        // should be correct\n        for (String f : new String[] { \"ft_intdvas_f\", \"ft_intdvas_t\",\n                                        \"intdvas_f\", \"intdvas_t\",\n                                        \"xx_dyn_ft_intdvas_f\", \"xx_dyn_ft_intdvas_f\", \n                                        \"xx_dyn_intdvas_f\", \"xx_dyn_intdvas_f\"}) {\n\n          boolean expected = f.endsWith(\"dvas_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's useDocValuesAsStored is wrong for ver=\" + ver,\n                       expected, field.useDocValuesAsStored());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong useDocValuesAsStored for ver=\" + ver,\n                         ( v < 1.6F ? false : true), \n                         ft.hasProperty(FieldType.USE_DOCVALUES_AS_STORED));\n          \n          }\n        }\n\n        // regardless of version, explicit omitTfP values on field or type \n        // should be correct\n        for (String f : new String[] { \"strTfP_f\", \"strTfP_t\", \n                                       \"txtTfP_f\", \"txtTfP_t\", \n                                       \"ft_strTfP_f\", \"ft_strTfP_t\",\n                                       \"ft_txtTfP_f\", \"ft_txtTfP_t\",\n                                       \"xx_dyn_strTfP_f\", \"xx_dyn_strTfP_t\",\n                                       \"xx_dyn_txtTfP_f\", \"xx_dyn_txtTfP_t\",\n                                       \"xx_dyn_ft_strTfP_f\", \"xx_dyn_ft_strTfP_t\",\n                                       \"xx_dyn_ft_txtTfP_f\", \"xx_dyn_ft_txtTfP_t\" }) {\n\n          boolean expected = f.endsWith(\"TfP_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitTfP is wrong for ver=\" + ver,\n                       expected, field.omitTermFreqAndPositions());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitTfP doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitTfP for ver=\" + ver,\n                         ( v < 1.2F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_TF_POSITIONS));\n          \n          }\n        }\n\n        // regardless of version, explicit autophrase values on type \n        // should be correct\n        for (String f : new String[] { \"ft_txt_phrase_f\", \"ft_txt_phrase_t\",\n                                       \"xx_dyn_ft_txt_phrase_f\", \n                                       \"xx_dyn_ft_txt_phrase_t\" }) {\n\n          boolean expected = f.endsWith(\"phrase_t\");\n          FieldType ft = schema.getFieldType(f);\n          assertTrue(\"broken test, assert only valid on text fields: \" + f,\n                     ft instanceof TextField);\n          assertEquals(f + \" field's autophrase is wrong for ver=\" + ver,\n                       expected, \n                       ((TextField)ft).getAutoGeneratePhraseQueries() );\n        }\n \n        // regardless of version, explicit multiValued values on field or type \n        // should be correct\n        for (String f : new String[] { \"strnorm_f\", \"strnorm_t\", \n                                       \"txtnorm_f\", \"txtnorm_t\", \n                                       \"ft_strnorm_f\", \"ft_strnorm_t\",\n                                       \"ft_txtnorm_f\", \"ft_txtnorm_t\",\n                                       \"xx_dyn_strnorm_f\", \"xx_dyn_strnorm_t\",\n                                       \"xx_dyn_txtnorm_f\", \"xx_dyn_txtnorm_t\",\n                                       \"xx_dyn_ft_strnorm_f\", \"xx_dyn_ft_strnorm_t\",\n                                       \"xx_dyn_ft_txtnorm_f\", \"xx_dyn_ft_txtnorm_t\" }) {\n\n          boolean expected = f.endsWith(\"norm_t\");\n          SchemaField field = schema.getField(f);\n          assertEquals(f + \" field's omitNorm is wrong for ver=\" + ver,\n                       expected, field.omitNorms());\n\n          FieldType ft = field.getType();\n          if (f.contains(\"ft_\")) {\n            // sanity check that we really are inheriting from fieldtype\n            assertEquals(f + \" field's omitNorm doesn't match type for ver=\" + ver,\n                         expected, ft.hasProperty(FieldType.OMIT_NORMS));\n          } else {\n            // for fields where the property is explicit, make sure\n            // we aren't getting a false negative because someone changed the\n            // schema and we're inheriting from fieldType\n            assertEquals(f + \" field's type has wrong omitNorm for ver=\" + ver,\n                         ( v < 1.5F ? false : \n                           ! (field.getType() instanceof TextField)), \n                         ft.hasProperty(FieldType.OMIT_NORMS));\n          \n          }\n        }\n         \n      } finally {\n        deleteCore();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2fff41ba33f73a49aabac5f5989da64c69ef6ba5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2fff41ba33f73a49aabac5f5989da64c69ef6ba5"],"bdac0dff04219451c7511d62225080a93a0181ea":["2fff41ba33f73a49aabac5f5989da64c69ef6ba5"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["bdac0dff04219451c7511d62225080a93a0181ea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"]},"commit2Childs":{"2fff41ba33f73a49aabac5f5989da64c69ef6ba5":["407687e67faf6e1f02a211ca078d8e3eed631027","bdac0dff04219451c7511d62225080a93a0181ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fff41ba33f73a49aabac5f5989da64c69ef6ba5","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"bdac0dff04219451c7511d62225080a93a0181ea":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}