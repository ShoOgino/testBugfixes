{"path":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","commits":[{"id":"444d4b906d0e3398f87d6a5c4967c508f11a7f0b","date":1466507434,"type":1,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(LeafReader,Analyzer,Query,Integer,Double,String,String).mjava","sourceNew":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param threshold      the threshold used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double threshold, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = indexReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param leafReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param threshold      the threshold used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(LeafReader leafReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double threshold, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(leafReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param threshold      the threshold used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double threshold, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = indexReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f47bd829c0cc2c9959c321f4b5ffba15e58fa41","date":1491555560,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","sourceNew":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param bias      the bias used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double bias, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (bias == null || bias == 0d) {\n      // automatic assign the bias to be the average total term freq\n      double t = (double) indexReader.getSumTotalTermFreq(textFieldName) / (double) indexReader.getDocCount(textFieldName);\n      if (t != -1) {\n        this.bias = t;\n      } else {\n        throw new IOException(\n                \"bias cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.bias = bias;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param threshold      the threshold used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double threshold, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = indexReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","sourceNew":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param bias      the bias used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double bias, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (bias == null || bias == 0d) {\n      // automatic assign the bias to be the average total term freq\n      double t = (double) indexReader.getSumTotalTermFreq(textFieldName) / (double) indexReader.getDocCount(textFieldName);\n      if (t != -1) {\n        this.bias = t;\n      } else {\n        throw new IOException(\n                \"bias cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.bias = bias;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param threshold      the threshold used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double threshold, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = indexReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(IndexReader,Analyzer,Query,Integer,Double,String,String).mjava","sourceNew":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param bias      the bias used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double bias, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiTerms.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (bias == null || bias == 0d) {\n      // automatic assign the bias to be the average total term freq\n      double t = (double) indexReader.getSumTotalTermFreq(textFieldName) / (double) indexReader.getDocCount(textFieldName);\n      if (t != -1) {\n        this.bias = t;\n      } else {\n        throw new IOException(\n                \"bias cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.bias = bias;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link BooleanPerceptronClassifier}\n   *\n   * @param indexReader     the reader on the index to be used for classification\n   * @param analyzer       an {@link Analyzer} used to analyze unseen text\n   * @param query          a {@link Query} to eventually filter the docs used for training the classifier, or {@code null}\n   *                       if all the indexed docs should be used\n   * @param batchSize      the size of the batch of docs to use for updating the perceptron weights\n   * @param bias      the bias used for class separation\n   * @param classFieldName the name of the field used as the output for the classifier\n   * @param textFieldName  the name of the field used as input for the classifier\n   * @throws IOException if the building of the underlying {@link FST} fails and / or {@link TermsEnum} for the text field\n   *                     cannot be found\n   */\n  public BooleanPerceptronClassifier(IndexReader indexReader, Analyzer analyzer, Query query, Integer batchSize,\n                                     Double bias, String classFieldName, String textFieldName) throws IOException {\n    this.textTerms = MultiFields.getTerms(indexReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (bias == null || bias == 0d) {\n      // automatic assign the bias to be the average total term freq\n      double t = (double) indexReader.getSumTotalTermFreq(textFieldName) / (double) indexReader.getDocCount(textFieldName);\n      if (t != -1) {\n        this.bias = t;\n      } else {\n        throw new IOException(\n                \"bias cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.bias = bias;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n\n    int batchCount = 0;\n\n    BooleanQuery.Builder q = new BooleanQuery.Builder();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q.build(),\n            Integer.MAX_VALUE).scoreDocs) {\n      Document doc = indexSearcher.doc(scoreDoc.doc);\n\n      IndexableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      IndexableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(indexReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"444d4b906d0e3398f87d6a5c4967c508f11a7f0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["444d4b906d0e3398f87d6a5c4967c508f11a7f0b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f47bd829c0cc2c9959c321f4b5ffba15e58fa41":["444d4b906d0e3398f87d6a5c4967c508f11a7f0b"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["0f47bd829c0cc2c9959c321f4b5ffba15e58fa41"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","444d4b906d0e3398f87d6a5c4967c508f11a7f0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"444d4b906d0e3398f87d6a5c4967c508f11a7f0b":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","0f47bd829c0cc2c9959c321f4b5ffba15e58fa41","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["444d4b906d0e3398f87d6a5c4967c508f11a7f0b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0f47bd829c0cc2c9959c321f4b5ffba15e58fa41":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}