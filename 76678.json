{"path":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","commits":[{"id":"ea256c5290971ea9db5a3dab42c4b8d9662e513a","date":1354022529,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  private ClassificationResult selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<String, Integer> classCounts = new HashMap<String, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      String cl = indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue();\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    String assignedClass = null;\n    for (String cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl;\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult(assignedClass, score);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  private ClassificationResult selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<String, Integer> classCounts = new HashMap<String, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      String cl = indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue();\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    String assignedClass = null;\n    for (String cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl;\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult(assignedClass, score);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d70dbb6b688e5d00fdf510da452291910f5efa4","date":1357228093,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      if (cl != null) {\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<String, Integer> classCounts = new HashMap<String, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      String cl = indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue();\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    String assignedClass = null;\n    for (String cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl;\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      if (cl != null) {\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<String, Integer> classCounts = new HashMap<String, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      String cl = indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue();\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    String assignedClass = null;\n    for (String cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl;\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45ae8f6354b0826d27014deff71fe330604a9783","date":1378195819,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      if (cl != null) {\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42752f746c2f3b1cfc8a971a2890d8098ebfb4b4","date":1385109382,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      if (count > max) {\n        max = count;\n        assignedClass = entry.getKey().clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      if (count > max) {\n        max = count;\n        assignedClass = entry.getKey().clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (BytesRef cl : classCounts.keySet()) {\n      Integer count = classCounts.get(cl);\n      if (count > max) {\n        max = count;\n        assignedClass = cl.clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      if (count > max) {\n        max = count;\n        assignedClass = entry.getKey().clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<>(assignedClass, score);\n  }\n\n","sourceOld":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<BytesRef, Integer>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      if (count > max) {\n        max = count;\n        assignedClass = entry.getKey().clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<BytesRef>(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7533828cbcc5f498a44cca5d9bce92692663778","date":1408525002,"type":4,"author":"Tommaso Teofili","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier#selectClassFromNeighbors(TopDocs).mjava","sourceNew":null,"sourceOld":"  private ClassificationResult<BytesRef> selectClassFromNeighbors(TopDocs topDocs) throws IOException {\n    // TODO : improve the nearest neighbor selection\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      BytesRef cl = new BytesRef(indexSearcher.doc(scoreDoc.doc).getField(classFieldName).stringValue());\n      Integer count = classCounts.get(cl);\n      if (count != null) {\n        classCounts.put(cl, count + 1);\n      } else {\n        classCounts.put(cl, 1);\n      }\n    }\n    double max = 0;\n    BytesRef assignedClass = new BytesRef();\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      if (count > max) {\n        max = count;\n        assignedClass = entry.getKey().clone();\n      }\n    }\n    double score = max / (double) k;\n    return new ClassificationResult<>(assignedClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","1d70dbb6b688e5d00fdf510da452291910f5efa4"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["42752f746c2f3b1cfc8a971a2890d8098ebfb4b4"],"ea256c5290971ea9db5a3dab42c4b8d9662e513a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e7533828cbcc5f498a44cca5d9bce92692663778":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ea256c5290971ea9db5a3dab42c4b8d9662e513a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["45ae8f6354b0826d27014deff71fe330604a9783","42752f746c2f3b1cfc8a971a2890d8098ebfb4b4"],"1d70dbb6b688e5d00fdf510da452291910f5efa4":["ea256c5290971ea9db5a3dab42c4b8d9662e513a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7533828cbcc5f498a44cca5d9bce92692663778"],"42752f746c2f3b1cfc8a971a2890d8098ebfb4b4":["45ae8f6354b0826d27014deff71fe330604a9783"],"45ae8f6354b0826d27014deff71fe330604a9783":["1d70dbb6b688e5d00fdf510da452291910f5efa4"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e7533828cbcc5f498a44cca5d9bce92692663778"],"ea256c5290971ea9db5a3dab42c4b8d9662e513a":["407687e67faf6e1f02a211ca078d8e3eed631027","1d70dbb6b688e5d00fdf510da452291910f5efa4"],"e7533828cbcc5f498a44cca5d9bce92692663778":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ea256c5290971ea9db5a3dab42c4b8d9662e513a","407687e67faf6e1f02a211ca078d8e3eed631027"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"1d70dbb6b688e5d00fdf510da452291910f5efa4":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","45ae8f6354b0826d27014deff71fe330604a9783"],"42752f746c2f3b1cfc8a971a2890d8098ebfb4b4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"45ae8f6354b0826d27014deff71fe330604a9783":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","42752f746c2f3b1cfc8a971a2890d8098ebfb4b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}