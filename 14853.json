{"path":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","commits":[{"id":"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b","date":1414400081,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","pathOld":"/dev/null","sourceNew":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","sourceNew":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = ArrayUtil.copyOfSubArray(bits, 0, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","sourceOld":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","sourceNew":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = ArrayUtil.copyOfSubArray(bits, 0, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","sourceOld":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#or(int,long,long[],int).mjava","sourceNew":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = ArrayUtil.copyOfSubArray(bits, 0, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","sourceOld":"  private void or(final int i4096, final long index, long[] bits, int nonZeroLongCount) {\n    assert Long.bitCount(index) == nonZeroLongCount;\n    final long currentIndex = indices[i4096];\n    if (currentIndex == 0) {\n      // fast path: if we currently have nothing in the block, just copy the data\n      // this especially happens all the time if you call OR on an empty set\n      indices[i4096] = index;\n      this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);\n      this.nonZeroLongCount += nonZeroLongCount;\n      return;\n    }\n    final long[] currentBits = this.bits[i4096];\n    final long[] newBits;\n    final long newIndex = currentIndex | index;\n    final int requiredCapacity = Long.bitCount(newIndex);\n    if (currentBits.length >= requiredCapacity) {\n      newBits = currentBits;\n    } else {\n      newBits = new long[oversize(requiredCapacity)];\n    }\n    // we iterate backwards in order to not override data we might need on the next iteration if the\n    // array is reused\n    for (int i = Long.numberOfLeadingZeros(newIndex), newO = Long.bitCount(newIndex) - 1;\n        i < 64;\n        i += 1 + Long.numberOfLeadingZeros(newIndex << (i + 1)), newO -= 1) {\n      // bitIndex is the index of a bit which is set in newIndex and newO is the number of 1 bits on its right\n      final int bitIndex = 63 - i;\n      assert newO == Long.bitCount(newIndex & ((1L << bitIndex) - 1));\n      newBits[newO] = longBits(currentIndex, currentBits, bitIndex) | longBits(index, bits, bitIndex);\n    }\n    indices[i4096] = newIndex;\n    this.bits[i4096] = newBits;\n    this.nonZeroLongCount += nonZeroLongCount - Long.bitCount(currentIndex & index);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b","9798d0818e7a880546802b509792d3f3d57babd2"],"9798d0818e7a880546802b509792d3f3d57babd2":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9798d0818e7a880546802b509792d3f3d57babd2"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b":["b70042a8a492f7054d480ccdd2be9796510d4327","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"9798d0818e7a880546802b509792d3f3d57babd2":["b70042a8a492f7054d480ccdd2be9796510d4327","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}