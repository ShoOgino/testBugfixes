{"path":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random()), 10), inputBufferSize, random());\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7be25195304fffb0961b22414915e675ac3c9f6","date":1363889959,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        new RandomAccessFile(tmpInputFile, \"r\"), newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(\"NIOFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        FileChannel.open(tmpInputFile.toPath(), StandardOpenOption.READ), newIOContext(random()), 10), \n        inputBufferSize, random());\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random()), 10), inputBufferSize, random());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        new RandomAccessFile(tmpInputFile, \"r\"), newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(\"NIOFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        FileChannel.open(tmpInputFile.toPath(), StandardOpenOption.READ), newIOContext(random()), 10), \n        inputBufferSize, random());\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        new RandomAccessFile(tmpInputFile, \"r\"), newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(\"NIOFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        FileChannel.open(tmpInputFile.toPath(), StandardOpenOption.READ), newIOContext(random()), 10), \n        inputBufferSize, random());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcf83b1542b01ad5cddb41b01dc51f751215919","date":1376231222,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        new RandomAccessFile(tmpInputFile, \"r\"), newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(\"NIOFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        FileChannel.open(tmpInputFile.toPath(), StandardOpenOption.READ), newIOContext(random()), 10), \n        inputBufferSize, random());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random());\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        new RandomAccessFile(tmpInputFile, \"r\"), newIOContext(random()), 10), inputBufferSize, random());\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(\"NIOFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", \n        FileChannel.open(tmpInputFile.toPath(), StandardOpenOption.READ), newIOContext(random()), 10), \n        inputBufferSize, random());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7be25195304fffb0961b22414915e675ac3c9f6":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["c7be25195304fffb0961b22414915e675ac3c9f6"],"0dcf83b1542b01ad5cddb41b01dc51f751215919":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["c7be25195304fffb0961b22414915e675ac3c9f6"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dcf83b1542b01ad5cddb41b01dc51f751215919"]},"commit2Childs":{"c7be25195304fffb0961b22414915e675ac3c9f6":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"0dcf83b1542b01ad5cddb41b01dc51f751215919":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["0dcf83b1542b01ad5cddb41b01dc51f751215919"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["c7be25195304fffb0961b22414915e675ac3c9f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}