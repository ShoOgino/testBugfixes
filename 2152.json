{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","commits":[{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Collector,DocIdSetIterator[],Collector[],Bits[],Collector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != DocsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Collector collector, DocIdSetIterator[] disis, Collector[] sidewaysCollectors,\n                                   Bits[] bits, Collector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != DocsEnum.NO_MORE_DOCS) {\n      Collector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Collector,DocIdSetIterator[],Collector[],Bits[],Collector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != DocsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Collector collector, DocIdSetIterator[] disis, Collector[] sidewaysCollectors,\n                                   Bits[] bits, Collector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != DocsEnum.NO_MORE_DOCS) {\n      Collector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != DocsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5de121b64b42060b75c060b3d2fa3e4c12ac701c","date":1435251256,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(Bits,LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doQueryFirstScoring(LeafCollector,DocIdSetIterator[],LeafCollector[],Bits[],LeafCollector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(Bits acceptDocs, LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      if (acceptDocs != null && acceptDocs.get(docID) == false) {\n        docID = baseScorer.nextDoc();\n        continue;\n      }\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns, or when the docs must be scored at once\n   *  (i.e., like BooleanScorer2, not BooleanScorer).  In\n   *  this case we just .next() on base and .advance() on\n   *  the dim filters. */ \n  private void doQueryFirstScoring(LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors,\n                                   Bits[] bits, LeafCollector[] bitsSidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doQueryFirstScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    nextDoc: while (docID != PostingsEnum.NO_MORE_DOCS) {\n      LeafCollector failedCollector = null;\n      for (int i=0;i<disis.length;i++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        DocIdSetIterator disi = disis[i];\n        if (disi != null && disi.docID() < docID) {\n          disi.advance(docID);\n        }\n        if (disi == null || disi.docID() > docID) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = sidewaysCollectors[i];\n          }\n        }\n      }\n\n      // TODO: for the \"non-costly Bits\" we really should\n      // have passed them down as acceptDocs, but\n      // unfortunately we cannot distinguish today betwen\n      // \"bits() is so costly that you should apply it last\"\n      // from \"bits() is so cheap that you should apply it\n      // everywhere down low\"\n\n      // Fold in Filter Bits last, since they may be costly:\n      for(int i=0;i<bits.length;i++) {\n        if (bits[i].get(docID) == false) {\n          if (failedCollector != null) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedCollector = bitsSidewaysCollectors[i];\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedCollector == null) {\n        // Hit passed all filters, so it's \"real\":\n        collectHit(collector, sidewaysCollectors, bitsSidewaysCollectors);\n      } else {\n        // Hit missed exactly one filter:\n        collectNearMiss(failedCollector);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae73da626f97850c922c42736f808d0378e165f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5de121b64b42060b75c060b3d2fa3e4c12ac701c":["51f5280f31484820499077f41fcdfe92d527d9dc"],"51f5280f31484820499077f41fcdfe92d527d9dc":["ae73da626f97850c922c42736f808d0378e165f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5de121b64b42060b75c060b3d2fa3e4c12ac701c"]},"commit2Childs":{"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","51f5280f31484820499077f41fcdfe92d527d9dc"],"5de121b64b42060b75c060b3d2fa3e4c12ac701c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"51f5280f31484820499077f41fcdfe92d527d9dc":["5de121b64b42060b75c060b3d2fa3e4c12ac701c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}