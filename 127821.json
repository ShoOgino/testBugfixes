{"path":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","commits":[{"id":"9f7c14f40c65357617cada58ca9b026ab9f81c24","date":1432120112,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery query = new BooleanQuery();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","sourceNew":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query.build(), 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery query = new BooleanQuery();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","sourceNew":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query.build(), 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query.build(), 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testMultipleQueriesIdfWorks().mjava","sourceNew":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query.build(), 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    Document bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    Document runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    Document worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testMultipleQueriesIdfWorks() throws Exception {\n    // With issue LUCENE-329 - it could be argued a MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite\n    // is the solution as it disables IDF.\n    // However - IDF is still useful as in this case where there are multiple FuzzyQueries.\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n\n    addDoc(\"michael smith\", writer);\n    addDoc(\"michael lucero\", writer);\n    addDoc(\"doug cutting\", writer);\n    addDoc(\"doug cuttin\", writer);\n    addDoc(\"michael wardle\", writer);\n    addDoc(\"micheal vegas\", writer);\n    addDoc(\"michael lydon\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n\n    writer.close();\n\n    BooleanQuery.Builder query = new BooleanQuery.Builder();\n    String commonSearchTerm = \"michael\";\n    FuzzyQuery commonQuery = new FuzzyQuery(new Term(\"field\", commonSearchTerm), 2, 1);\n    query.add(commonQuery, Occur.SHOULD);\n\n    String rareSearchTerm = \"cutting\";\n    FuzzyQuery rareQuery = new FuzzyQuery(new Term(\"field\", rareSearchTerm), 2, 1);\n    query.add(rareQuery, Occur.SHOULD);\n    ScoreDoc[] hits = searcher.search(query.build(), 1000).scoreDocs;\n\n    // Matches on the rare surname should be worth more than matches on the common forename\n    assertEquals(7, hits.length);\n    StoredDocument bestDoc = searcher.doc(hits[0].doc);\n    String topMatch = bestDoc.get(\"field\");\n    assertTrue(topMatch.contains(rareSearchTerm));\n\n    StoredDocument runnerUpDoc = searcher.doc(hits[1].doc);\n    String runnerUpMatch = runnerUpDoc.get(\"field\");\n    assertTrue(runnerUpMatch.contains(\"cuttin\"));\n\n    StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n    String worstMatch = worstDoc.get(\"field\");\n    assertTrue(worstMatch.contains(\"micheal\")); //misspelling of common name\n\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"9f7c14f40c65357617cada58ca9b026ab9f81c24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["81d0720146de53dd3a4a023d2a3d1089d86d748d"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"9f7c14f40c65357617cada58ca9b026ab9f81c24":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}