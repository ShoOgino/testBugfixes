{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#carryOverHardDeletes(ReadersAndUpdates,int,Bits,Bits,Bits,MergeState.DocMap,MergeState.DocMap).mjava","commits":[{"id":"36d84416fc00253f9e834f8dba14fa89b298e64e","date":1525428963,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#carryOverHardDeletes(ReadersAndUpdates,int,Bits,Bits,Bits,MergeState.DocMap,MergeState.DocMap).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method carries over hard-deleted documents that are applied to the source segment during a merge.\n   */\n  private static void carryOverHardDeletes(ReadersAndUpdates mergedReadersAndUpdates, int maxDoc,\n                                           Bits mergeLiveDocs, // the liveDocs used to build the segDocMaps\n                                           Bits prevHardLiveDocs, // the hard deletes when the merge reader was pulled\n                                           Bits currentHardLiveDocs, // the current hard deletes\n                                           MergeState.DocMap segDocMap, MergeState.DocMap segLeafDocMap) throws IOException {\n\n    assert mergeLiveDocs == null || mergeLiveDocs.length() == maxDoc;\n    // if we mix soft and hard deletes we need to make sure that we only carry over deletes\n    // that were not deleted before. Otherwise the segDocMap doesn't contain a mapping.\n    // yet this is also required if any MergePolicy modifies the liveDocs since this is\n    // what the segDocMap is build on.\n    final IntPredicate carryOverDelete = mergeLiveDocs == null || mergeLiveDocs == prevHardLiveDocs\n        ? docId -> currentHardLiveDocs.get(docId) == false\n        : docId -> mergeLiveDocs.get(docId) && currentHardLiveDocs.get(docId) == false;\n    if (prevHardLiveDocs != null) {\n      // If we had deletions on starting the merge we must\n      // still have deletions now:\n      assert currentHardLiveDocs != null;\n      assert mergeLiveDocs != null;\n      assert prevHardLiveDocs.length() == maxDoc;\n      assert currentHardLiveDocs.length() == maxDoc;\n\n      // There were deletes on this segment when the merge\n      // started.  The merge has collapsed away those\n      // deletes, but, if new deletes were flushed since\n      // the merge started, we must now carefully keep any\n      // newly flushed deletes but mapping them to the new\n      // docIDs.\n\n      // Since we copy-on-write, if any new deletes were\n      // applied after merging has started, we can just\n      // check if the before/after liveDocs have changed.\n      // If so, we must carefully merge the liveDocs one\n      // doc at a time:\n      if (currentHardLiveDocs != prevHardLiveDocs) {\n        // This means this segment received new deletes\n        // since we started the merge, so we\n        // must merge them:\n        for (int j = 0; j < maxDoc; j++) {\n          if (prevHardLiveDocs.get(j) == false) {\n            // if the document was deleted before, it better still be deleted!\n            assert currentHardLiveDocs.get(j) == false;\n          } else if (carryOverDelete.test(j)) {\n            // the document was deleted while we were merging:\n            mergedReadersAndUpdates.delete(segDocMap.get(segLeafDocMap.get(j)));\n          }\n        }\n      }\n    } else if (currentHardLiveDocs != null) {\n      assert currentHardLiveDocs.length() == maxDoc;\n      // This segment had no deletes before but now it\n      // does:\n      for (int j = 0; j < maxDoc; j++) {\n        if (carryOverDelete.test(j)) {\n          mergedReadersAndUpdates.delete(segDocMap.get(segLeafDocMap.get(j)));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"36d84416fc00253f9e834f8dba14fa89b298e64e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36d84416fc00253f9e834f8dba14fa89b298e64e"]},"commit2Childs":{"36d84416fc00253f9e834f8dba14fa89b298e64e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["36d84416fc00253f9e834f8dba14fa89b298e64e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}