{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f703b580a38c8a12d78077283f2372b6f65312a0","date":1566551787,"type":3,"author":"Julie Tibshirani","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      FieldDoc[] expectedHits = new FieldDoc[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        double distance = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        FieldDoc hit = new FieldDoc(id, 0.0f, new Object[] {Double.valueOf(distance)});\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<FieldDoc>() {\n          @Override\n          public int compare(FieldDoc a, FieldDoc  b) {\n            int cmp = Double.compare(((Double) a.fields[0]).doubleValue(), ((Double) b.fields[0]).doubleValue());\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.doc - b.doc;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        FieldDoc expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.doc+ \" lat=\" + lats[expected.doc] + \" lon=\" + lons[expected.doc]\n              + \" distance=\" + ((Double) expected.fields[0]).doubleValue() + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.doc, actual.doc);\n        assertEquals(((Double) expected.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected2.doc, actual.doc);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(1000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      FieldDoc[] expectedHits = new FieldDoc[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        double distance = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        FieldDoc hit = new FieldDoc(id, 0.0f, new Object[] {Double.valueOf(distance)});\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<FieldDoc>() {\n          @Override\n          public int compare(FieldDoc a, FieldDoc  b) {\n            int cmp = Double.compare(((Double) a.fields[0]).doubleValue(), ((Double) b.fields[0]).doubleValue());\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.doc - b.doc;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        FieldDoc expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.doc+ \" lat=\" + lats[expected.doc] + \" lon=\" + lons[expected.doc]\n              + \" distance=\" + ((Double) expected.fields[0]).doubleValue() + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.doc, actual.doc);\n        assertEquals(((Double) expected.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected2.doc, actual.doc);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      FieldDoc[] expectedHits = new FieldDoc[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        double distance = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        FieldDoc hit = new FieldDoc(id, 0.0f, new Object[] {Double.valueOf(distance)});\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<FieldDoc>() {\n          @Override\n          public int compare(FieldDoc a, FieldDoc  b) {\n            int cmp = Double.compare(((Double) a.fields[0]).doubleValue(), ((Double) b.fields[0]).doubleValue());\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.doc - b.doc;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        FieldDoc expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.doc+ \" lat=\" + lats[expected.doc] + \" lon=\" + lons[expected.doc]\n              + \" distance=\" + ((Double) expected.fields[0]).doubleValue() + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.doc, actual.doc);\n        assertEquals(((Double) expected.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected2.doc, actual.doc);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), ((Double) actual.fields[0]).doubleValue(), 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["f703b580a38c8a12d78077283f2372b6f65312a0"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f703b580a38c8a12d78077283f2372b6f65312a0":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["f703b580a38c8a12d78077283f2372b6f65312a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"f703b580a38c8a12d78077283f2372b6f65312a0":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}