{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqPayloadIterator).mjava","commits":[{"id":"ada2f7352a7f964fe49bccd13227c4ec38563d39","date":1381659982,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqPayloadIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqPayloadIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    TermFreqPayloadIterator payloads;\n    if (iterator instanceof TermFreqPayloadIterator) {\n      payloads = (TermFreqPayloadIterator) iterator;\n    } else {\n      payloads = null;\n    }\n    hasPayloads = payloads != null;\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = payloads.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(payloads != null)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41aee74b5f91a096e3fd950f4a336bc763f0e7a7","date":1381772070,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqPayloadIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqPayloadIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}