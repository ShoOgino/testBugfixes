{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","commits":[{"id":"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","date":1349450075,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + (PackedInts.Format.PACKED.nblocks(bitsPerValue, chunkDocs) << 3));\n\n    uncompressor.uncompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1","date":1351696336,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + (PackedInts.Format.PACKED.nblocks(bitsPerValue, chunkDocs) << 3));\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + (PackedInts.Format.PACKED.nblocks(bitsPerValue, chunkDocs) << 3));\n\n    uncompressor.uncompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c661dcad9680b8a6ce5bf2cc583a69ec965328bc","date":1352297862,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerValue));\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + (PackedInts.Format.PACKED.nblocks(bitsPerValue, chunkDocs) << 3));\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c","date":1352305464,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerLength));\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    final int bitsPerValue = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs\n        || bitsPerValue > 31) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs + \", bitsPerValue=\" + bitsPerValue);\n    }\n\n    final long filePointer = fieldsStream.getFilePointer();\n    final PackedInts.ReaderIterator lengths = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 1);\n    int offset = 0;\n    for (int i = docBase; i < docID; ++i) {\n      offset += lengths.next();\n    }\n    final int length = (int) lengths.next();\n    // skip the last values\n    fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerValue));\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    final int numFields = documentInput.readVInt();\n    for (int fieldIDX = 0; fieldIDX < numFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          break;\n        case NO: \n          skipField(documentInput, bits);\n          break;\n        case STOP: \n          return;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ee663728a95682ffb5dee37517ac9e863cd0820","date":1352758633,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length, totalLength;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n      totalLength = length;\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n        totalLength = chunkDocs * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        off += length;\n        for (int i = docID - docBase + 1; i < chunkDocs; ++i) {\n          off += it.next();\n        }\n        totalLength = off;\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, totalLength, offset, length, bytes);\n    assert bytes.length == length;\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerLength));\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","date":1352818449,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length, totalLength;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n      totalLength = length;\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n        totalLength = chunkDocs * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        off += length;\n        for (int i = docID - docBase + 1; i < chunkDocs; ++i) {\n          off += it.next();\n        }\n        totalLength = off;\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, totalLength, offset, length, bytes);\n    assert bytes.length == length;\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length, totalLength;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n      totalLength = length;\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n        totalLength = chunkDocs * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        off += length;\n        for (int i = docID - docBase + 1; i < chunkDocs; ++i) {\n          off += it.next();\n        }\n        totalLength = off;\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, totalLength, offset, length, bytes);\n    assert bytes.length == length;\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsReader#visitDocument(int,StoredFieldVisitor).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void visitDocument(int docID, StoredFieldVisitor visitor)\n      throws IOException {\n    fieldsStream.seek(indexReader.getStartPointer(docID));\n\n    final int docBase = fieldsStream.readVInt();\n    final int chunkDocs = fieldsStream.readVInt();\n    if (docID < docBase\n        || docID >= docBase + chunkDocs\n        || docBase + chunkDocs > numDocs) {\n      throw new CorruptIndexException(\"Corrupted: docID=\" + docID\n          + \", docBase=\" + docBase + \", chunkDocs=\" + chunkDocs\n          + \", numDocs=\" + numDocs);\n    }\n\n    final int numStoredFields, offset, length;\n    if (chunkDocs == 1) {\n      numStoredFields = fieldsStream.readVInt();\n      offset = 0;\n      length = fieldsStream.readVInt();\n    } else {\n      final int bitsPerStoredFields = fieldsStream.readVInt();\n      if (bitsPerStoredFields == 0) {\n        numStoredFields = fieldsStream.readVInt();\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerStoredFields=\" + bitsPerStoredFields);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.Reader reader = PackedInts.getDirectReaderNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerStoredFields);\n        numStoredFields = (int) (reader.get(docID - docBase));\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerStoredFields));\n      }\n\n      final int bitsPerLength = fieldsStream.readVInt();\n      if (bitsPerLength == 0) {\n        length = fieldsStream.readVInt();\n        offset = (docID - docBase) * length;\n      } else if (bitsPerStoredFields > 31) {\n        throw new CorruptIndexException(\"bitsPerLength=\" + bitsPerLength);\n      } else {\n        final long filePointer = fieldsStream.getFilePointer();\n        final PackedInts.ReaderIterator it = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerLength, 1);\n        int off = 0;\n        for (int i = 0; i < docID - docBase; ++i) {\n          off += it.next();\n        }\n        offset = off;\n        length = (int) it.next();\n        fieldsStream.seek(filePointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion, chunkDocs, bitsPerLength));\n      }\n    }\n\n    if ((length == 0) != (numStoredFields == 0)) {\n      throw new CorruptIndexException(\"length=\" + length + \", numStoredFields=\" + numStoredFields);\n    }\n    if (numStoredFields == 0) {\n      // nothing to do\n      return;\n    }\n\n    decompressor.decompress(fieldsStream, offset, length, bytes);\n\n    final ByteArrayDataInput documentInput = new ByteArrayDataInput(bytes.bytes, bytes.offset, bytes.length);\n    for (int fieldIDX = 0; fieldIDX < numStoredFields; fieldIDX++) {\n      final long infoAndBits = documentInput.readVLong();\n      final int fieldNumber = (int) (infoAndBits >>> TYPE_BITS);\n      FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);\n\n      final int bits = (int) (infoAndBits & TYPE_MASK);\n      assert bits <= NUMERIC_DOUBLE: \"bits=\" + Integer.toHexString(bits);\n\n      switch(visitor.needsField(fieldInfo)) {\n        case YES:\n          readField(documentInput, visitor, fieldInfo, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case NO:\n          skipField(documentInput, bits);\n          assert documentInput.getPosition() <= bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + bytes.length;\n          break;\n        case STOP:\n          return;\n      }\n    }\n    assert documentInput.getPosition() == bytes.offset + bytes.length : documentInput.getPosition() + \" \" + bytes.offset + \" \" + bytes.length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"9ee663728a95682ffb5dee37517ac9e863cd0820":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["9ee663728a95682ffb5dee37517ac9e863cd0820"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c","5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"]},"commit2Childs":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"9ee663728a95682ffb5dee37517ac9e863cd0820":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["eba3cb2a268b9fb6f5be011fbaaf698699dcf24c"],"eba3cb2a268b9fb6f5be011fbaaf698699dcf24c":["9ee663728a95682ffb5dee37517ac9e863cd0820","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}