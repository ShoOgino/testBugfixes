{"path":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e00f80591de714c6975f454e33e0fa5218b5902","date":1294514405,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":["365f98746545c0785c9778597f8558f5f91db4ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b","date":1313816278,"type":5,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    // found a match\n                    Query tq = ignoreTF ? new ConstantScoreQuery(new TermQuery(st.term)) : new TermQuery(st.term, 1);                    \n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b":["3e00f80591de714c6975f454e33e0fa5218b5902"],"3e00f80591de714c6975f454e33e0fa5218b5902":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["9454a6510e2db155fb01faa5c049b06ece95fab9","3e00f80591de714c6975f454e33e0fa5218b5902"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["9454a6510e2db155fb01faa5c049b06ece95fab9","3e00f80591de714c6975f454e33e0fa5218b5902"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f9fdc0777b84633cc8cfa8995ff5b0d411e4515b"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f9fdc0777b84633cc8cfa8995ff5b0d411e4515b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3e00f80591de714c6975f454e33e0fa5218b5902":["f9fdc0777b84633cc8cfa8995ff5b0d411e4515b","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["3e00f80591de714c6975f454e33e0fa5218b5902","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}