{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a6ee6c302710254b6c2474ccd2755f9f2323ee3","date":1330700384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (fst.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & fst.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8510775f25a49d13008fe3890abce947ec95564","date":1346177474,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with FST<Long>, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final FST.BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.pos = arc.posArcsStart;\n            in.skip(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f93c27491251c14ea21df71ebbf6feb9f891e6cb","date":1358211079,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader(0);\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":["f04dea8ce9675dc75eb2483feb840a86f765fb82","2a6ee6c302710254b6c2474ccd2755f9f2323ee3","87e78f3c129251e74ecc2ff73a32de0f27cf09d5","b3be20ca1091c0b7cdb2308b9023606a5e451cec","4708e7bf7695781d702d204d178627b4faddc03f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39","date":1370266419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs and only works when you shared\n   *  the outputs (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}).\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRef result = new IntsRef();\n    \n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":["4708e7bf7695781d702d204d178627b4faddc03f","f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offsets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long).mjava","sourceNew":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offsets (when appending to a file)\n   *  fit this. */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","sourceOld":"  /** Reverse lookup (lookup by output instead of by input),\n   *  in the special case when your FSTs outputs are\n   *  strictly ascending.  This locates the input/output\n   *  pair where the output is equal to the target, and will\n   *  return null if that output does not exist.\n   *\n   *  <p>NOTE: this only works with {@code FST<Long>}, only\n   *  works when the outputs are ascending in order with\n   *  the inputs.\n   *  For example, simple ordinals (0, 1,\n   *  2, ...), or file offsets (when appending to a file)\n   *  fit this. */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {\n\n    final BytesReader in = fst.getBytesReader();\n\n    // TODO: would be nice not to alloc this on every lookup\n    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());\n    \n    FST.Arc<Long> scratchArc = new FST.Arc<>();\n\n    final IntsRefBuilder result = new IntsRefBuilder();\n    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["f93c27491251c14ea21df71ebbf6feb9f891e6cb","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c8510775f25a49d13008fe3890abce947ec95564","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["c8510775f25a49d13008fe3890abce947ec95564"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3","c8510775f25a49d13008fe3890abce947ec95564"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"59a1204a92958bea883656169000a87a6c55c2d0":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["82557a475db3e0849171dc0be5b02e3ae0745ddb","c4015cd39dff8d4dec562d909f9766debac53aa6"],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8510775f25a49d13008fe3890abce947ec95564":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59a1204a92958bea883656169000a87a6c55c2d0"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["c4015cd39dff8d4dec562d909f9766debac53aa6","d4d69c535930b5cce125cff868d40f6373dc27d4"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["82557a475db3e0849171dc0be5b02e3ae0745ddb","8917bfede3b4ca30f4305c1e391e9218959cd723"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","05a14b2611ead08655a2b2bdc61632eb31316e57","c8510775f25a49d13008fe3890abce947ec95564"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"59a1204a92958bea883656169000a87a6c55c2d0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["59a1204a92958bea883656169000a87a6c55c2d0"],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c8510775f25a49d13008fe3890abce947ec95564":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5","05a14b2611ead08655a2b2bdc61632eb31316e57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}