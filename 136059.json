{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24736f886f499d15345d6c4b717b9fe84a70dae2","date":1274900864,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":["5350389bf83287111f7760b9e3db3af8e3648474"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be20f9fed1d3edcb1c84abcc39df87a90fab22df","date":1275590285,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b832cbed6eb3d54a8bb9339296bdda8eeb53014","date":1279708040,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":null,"sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"334c1175813aea771a71728cd2c4ee4754fd0603","date":1279710173,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fe956d65251358d755c56f14fe8380644790e47","date":1279711318,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":null,"sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n    \n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n\n    boolean flushed = threadPool.executePerThread(this, doc,\n        new DocumentsWriterThreadPool.PerThreadTask<Boolean>() {\n          @Override\n          public Boolean process(final DocumentsWriterPerThread perThread) throws IOException {\n            long perThreadRAMUsedBeforeAdd = perThread.bytesUsed();\n            perThread.addDocument(doc, analyzer);\n\n            sequenceIDLock.lock();\n            try {\n              ensureOpen();\n              if (delTerm != null) {\n                deleteTerm(delTerm, true);\n              }\n              perThread.commitDocument();\n              numDocsInRAM.incrementAndGet();\n            } finally {\n              sequenceIDLock.unlock();\n            }\n\n            if (finishAddDocument(perThread, perThreadRAMUsedBeforeAdd)) {\n              super.clearThreadBindings();\n              return true;\n            }\n            return false;\n          }\n        });\n\n    if (flushed) {\n      indexWriter.maybeMerge();\n      return true;\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc5ecd93bcd50b2199757091d526fc1bcbce0db1","date":1293154244,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n\n    boolean flushed = threadPool.executePerThread(this, doc,\n        new DocumentsWriterThreadPool.PerThreadTask<Boolean>() {\n          @Override\n          public Boolean process(final DocumentsWriterPerThread perThread) throws IOException {\n            long perThreadRAMUsedBeforeAdd = perThread.bytesUsed();\n            perThread.addDocument(doc, analyzer);\n\n            synchronized(DocumentsWriter.this) {\n              ensureOpen();\n              if (delTerm != null) {\n                deleteTerm(delTerm, true);\n              }\n              perThread.commitDocument();\n              numDocsInRAM.incrementAndGet();\n            }\n\n            if (finishAddDocument(perThread, perThreadRAMUsedBeforeAdd)) {\n              super.clearThreadBindings();\n              return true;\n            }\n            return false;\n          }\n        });\n\n    if (flushed) {\n      indexWriter.maybeMerge();\n      return true;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n\n    boolean flushed = threadPool.executePerThread(this, doc,\n        new DocumentsWriterThreadPool.PerThreadTask<Boolean>() {\n          @Override\n          public Boolean process(final DocumentsWriterPerThread perThread) throws IOException {\n            long perThreadRAMUsedBeforeAdd = perThread.bytesUsed();\n            perThread.addDocument(doc, analyzer);\n\n            sequenceIDLock.lock();\n            try {\n              ensureOpen();\n              if (delTerm != null) {\n                deleteTerm(delTerm, true);\n              }\n              perThread.commitDocument();\n              numDocsInRAM.incrementAndGet();\n            } finally {\n              sequenceIDLock.unlock();\n            }\n\n            if (finishAddDocument(perThread, perThreadRAMUsedBeforeAdd)) {\n              super.clearThreadBindings();\n              return true;\n            }\n            return false;\n          }\n        });\n\n    if (flushed) {\n      indexWriter.maybeMerge();\n      return true;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff78505662c0b741e2663a9f38a4889c12a32c9f","date":1294908561,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    Collection<String> flushedFiles = null;\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      synchronized(DocumentsWriter.this) {\n        if (delTerm != null) {\n          deleteTerm(delTerm);\n        }\n        dwpt.commitDocument();\n        numDocsInRAM.incrementAndGet();\n      }\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n        flushedFiles = new HashSet<String>();\n        flushedFiles.addAll(dwpt.flushState.flushedFiles);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment, flushedFiles);\n      return true;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n\n    boolean flushed = threadPool.executePerThread(this, doc,\n        new DocumentsWriterThreadPool.PerThreadTask<Boolean>() {\n          @Override\n          public Boolean process(final DocumentsWriterPerThread perThread) throws IOException {\n            long perThreadRAMUsedBeforeAdd = perThread.bytesUsed();\n            perThread.addDocument(doc, analyzer);\n\n            synchronized(DocumentsWriter.this) {\n              ensureOpen();\n              if (delTerm != null) {\n                deleteTerm(delTerm, true);\n              }\n              perThread.commitDocument();\n              numDocsInRAM.incrementAndGet();\n            }\n\n            if (finishAddDocument(perThread, perThreadRAMUsedBeforeAdd)) {\n              super.clearThreadBindings();\n              return true;\n            }\n            return false;\n          }\n        });\n\n    if (flushed) {\n      indexWriter.maybeMerge();\n      return true;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      synchronized(DocumentsWriter.this) {\n        if (delTerm != null) {\n          deleteTerm(delTerm);\n        }\n        dwpt.commitDocument();\n        numDocsInRAM.incrementAndGet();\n      }\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    Collection<String> flushedFiles = null;\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      synchronized(DocumentsWriter.this) {\n        if (delTerm != null) {\n          deleteTerm(delTerm);\n        }\n        dwpt.commitDocument();\n        numDocsInRAM.incrementAndGet();\n      }\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n        flushedFiles = new HashSet<String>();\n        flushedFiles.addAll(dwpt.flushState.flushedFiles);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment, flushedFiles);\n      return true;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3161e3ffcf20c09a22504a589d4d9bd273e11e33","date":1295142360,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      if (delTerm != null) {\n        deleteTerm(delTerm);\n      }\n      dwpt.commitDocument();\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      synchronized(DocumentsWriter.this) {\n        if (delTerm != null) {\n          deleteTerm(delTerm);\n        }\n        dwpt.commitDocument();\n        numDocsInRAM.incrementAndGet();\n      }\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14975dba6846360ff627c6797726fa4899a3413d","date":1295174738,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      if (delTerm != null) {\n        dwpt.deleteTerm(delTerm);\n      }\n      dwpt.commitDocument();\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null && dwpt.pendingDeletes.any()) {\n        bufferedDeletes.pushDeletes(dwpt.pendingDeletes, newSegment);\n        dwpt.pendingDeletes = new SegmentDeletes();\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      if (delTerm != null) {\n        deleteTerm(delTerm);\n      }\n      dwpt.commitDocument();\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        perThreadPool.clearThreadBindings(perThread);\n      }\n\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86c34ea6a885f625f2e464756450d45b72653ef3","date":1295256222,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n    SegmentDeletes segmentDeletes = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        fieldInfos.update(dwpt.getFieldInfos());\n        if (dwpt.pendingDeletes.any()) {\n          segmentDeletes = dwpt.pendingDeletes;\n          dwpt.pendingDeletes = new SegmentDeletes();\n        }\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (segmentDeletes != null) {\n      pushDeletes(newSegment, segmentDeletes);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      indexWriter.addFlushedSegment(newSegment);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.addDocument(doc, analyzer);\n\n      if (delTerm != null) {\n        dwpt.deleteTerm(delTerm);\n      }\n      dwpt.commitDocument();\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null && dwpt.pendingDeletes.any()) {\n        bufferedDeletes.pushDeletes(dwpt.pendingDeletes, newSegment);\n        dwpt.pendingDeletes = new SegmentDeletes();\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      finishFlushedSegment(newSegment);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n    BufferedDeletes segmentDeletes = null;\n    BitVector deletedDocs = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        deletedDocs = dwpt.flushState.deletedDocs;\n        if (dwpt.pendingDeletes.any()) {\n          segmentDeletes = dwpt.pendingDeletes;\n          dwpt.pendingDeletes = new BufferedDeletes(false);\n        }\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (segmentDeletes != null) {\n      pushDeletes(newSegment, segmentDeletes);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      indexWriter.addFlushedSegment(newSegment, deletedDocs);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n    SegmentDeletes segmentDeletes = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        fieldInfos.update(dwpt.getFieldInfos());\n        if (dwpt.pendingDeletes.any()) {\n          segmentDeletes = dwpt.pendingDeletes;\n          dwpt.pendingDeletes = new SegmentDeletes();\n        }\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (segmentDeletes != null) {\n      pushDeletes(newSegment, segmentDeletes);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      indexWriter.addFlushedSegment(newSegment);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","date":1298618128,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    FlushedSegment newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n    } finally {\n      perThread.unlock();\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      return true;\n    }\n\n    return false;\n    }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    SegmentInfo newSegment = null;\n    BufferedDeletes segmentDeletes = null;\n    BitVector deletedDocs = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n      if (newSegment != null) {\n        deletedDocs = dwpt.flushState.deletedDocs;\n        if (dwpt.pendingDeletes.any()) {\n          segmentDeletes = dwpt.pendingDeletes;\n          dwpt.pendingDeletes = new BufferedDeletes(false);\n        }\n      }\n    } finally {\n      perThread.unlock();\n    }\n\n    if (segmentDeletes != null) {\n      pushDeletes(newSegment, segmentDeletes);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      indexWriter.addFlushedSegment(newSegment, deletedDocs);\n      return true;\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2ed1b9b7b46829fe3199afe9a8bc203f201b175","date":1301491807,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      final DocumentsWriterPerThread flushingDWPT;\n      flushingDWPT = flushControl.getFlushIfPending(null);\n       // don't push the delete here since the update could fail!\n      maybeMerge = doFlush(flushingDWPT);\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    DocumentsWriterPerThread flushingDWPT = null;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm);\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n      numDocsInRAM.incrementAndGet();\n    } finally {\n      perThread.unlock();\n    }\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (isUpdate) {\n      deleteTerm(delTerm, perThread);\n    }\n    maybeMerge |= doFlush(flushingDWPT);\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer, final Term delTerm)\n      throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    FlushedSegment newSegment = null;\n\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this, doc);\n    try {\n      DocumentsWriterPerThread dwpt = perThread.perThread;\n      long perThreadRAMUsedBeforeAdd = dwpt.bytesUsed();\n      dwpt.updateDocument(doc, analyzer, delTerm);\n      numDocsInRAM.incrementAndGet();\n\n      newSegment = finishAddDocument(dwpt, perThreadRAMUsedBeforeAdd);\n    } finally {\n      perThread.unlock();\n    }\n\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (delTerm != null) {\n      deleteTerm(delTerm, perThread);\n    }\n\n    if (newSegment != null) {\n      finishFlushedSegment(newSegment);\n    }\n\n    if (newSegment != null) {\n      perThreadPool.clearThreadBindings(perThread);\n      return true;\n    }\n\n    return false;\n    }\n\n","bugFix":null,"bugIntro":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      DocumentsWriterPerThread flushingDWPT;\n      while ( (flushingDWPT = flushControl.nextPendingFlush()) != null){\n       // don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.isStalled()) {\n          break;\n        }\n      }\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    final DocumentsWriterPerThread dwpt;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    maybeMerge |= doFlush(flushingDWPT);\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      final DocumentsWriterPerThread flushingDWPT;\n      flushingDWPT = flushControl.getFlushIfPending(null);\n       // don't push the delete here since the update could fail!\n      maybeMerge = doFlush(flushingDWPT);\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    DocumentsWriterPerThread flushingDWPT = null;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm);\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n      numDocsInRAM.incrementAndGet();\n    } finally {\n      perThread.unlock();\n    }\n    // delete term from other DWPTs later, so that this thread\n    // doesn't have to lock multiple DWPTs at the same time\n    if (isUpdate) {\n      deleteTerm(delTerm, perThread);\n    }\n    maybeMerge |= doFlush(flushingDWPT);\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d37796041ff1a34fbe02a8b646945bac6c1d5a0f","date":1302855028,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      DocumentsWriterPerThread flushingDWPT;\n      while ( (flushingDWPT = flushControl.nextPendingFlush()) != null){\n       // don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.isStalled()) {\n          break;\n        }\n      }\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    final DocumentsWriterPerThread dwpt;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      DocumentsWriterPerThread flushingDWPT;\n      while ( (flushingDWPT = flushControl.nextPendingFlush()) != null){\n       // don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.isStalled()) {\n          break;\n        }\n      }\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    final DocumentsWriterPerThread dwpt;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    maybeMerge |= doFlush(flushingDWPT);\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6f4cae61e16730201371ab7e9912721c19324e7","date":1303199575,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.isStalled()) {\n      /*\n       * if we are allowed to hijack threads for flushing we try to flush out \n       * as many pending DWPT to release memory and get back healthy status.\n       */\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter is stalled try to hijack thread to flush pending segment\");\n      }\n      // try pick up pending threads here if possile\n      DocumentsWriterPerThread flushingDWPT;\n      while ( (flushingDWPT = flushControl.nextPendingFlush()) != null){\n       // don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.isStalled()) {\n          break;\n        }\n      }\n      if (infoStream != null && healthiness.isStalled()) {\n        message(\"WARNING DocumentsWriter is stalled might block thread until DocumentsWriter is not stalled anymore\");\n      }\n      healthiness.waitIfStalled(); // block if stalled\n    }\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    final DocumentsWriterPerThread dwpt;\n    try {\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if(dwpt.checkAndResetHasAborted()) {\n            flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4f6945f5eb72bd7d9722ab064a98eb1d8543afc","date":1303831082,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32f306edd62f81390a6e263e8b913f089f3e98a1","date":1305615519,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":["327863a2fd61e831028b6c56c8fef6b00a44eb0b","f6f4cae61e16730201371ab7e9912721c19324e7","d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (healthiness.anyStalledThreads()) {\n\n      // Help out flushing any pending DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"WARNING DocumentsWriter has stalled threads; will hijack this thread to flush pending segment(s)\");\n      }\n\n      // Try pick up pending threads here if possible\n      DocumentsWriterPerThread flushingDWPT;\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        // Don't push the delete here since the update could fail!\n        maybeMerge = doFlush(flushingDWPT);\n        if (!healthiness.anyStalledThreads()) {\n          break;\n        }\n      }\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter still has stalled threads; waiting\");\n      }\n\n      healthiness.waitIfStalled(); // block if stalled\n\n      if (infoStream != null && healthiness.anyStalledThreads()) {\n        message(\"WARNING DocumentsWriter done waiting\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // Possibly trigger a flush, or wait until any running flush completes:\n    boolean doFlush = flushControl.waitUpdate(1, delTerm != null ? 1 : 0);\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc;\n      try {\n        perDoc = state.consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n\n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n\n      success = true;\n    } finally {\n      if (!success) {\n\n        // If this thread state had decided to flush, we\n        // must clear it so another thread can flush\n        if (doFlush) {\n          flushControl.clearFlushPending();\n        }\n\n        if (infoStream != null) {\n          message(\"exception in updateDocument aborting=\" + aborting);\n        }\n\n        synchronized(this) {\n\n          state.isIdle = true;\n          notifyAll();\n            \n          if (aborting) {\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                abort();\n                return false;\n              }\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            deleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    doFlush |= flushControl.flushByRAMUsage(\"new document\");\n\n    return doFlush;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27","date":1306166545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    final boolean isUpdate = delTerm != null;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream != null) {\n        message(\"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream != null && flushControl.anyStalledThreads()) {\n          message(\"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream != null) {\n        message(\"continue indexing after helpling out flushing DocumentsWriter is healthy\");\n      }\n    }\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(),\n        this, doc);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n    \n    if (flushingDWPT != null) {\n      maybeMerge |= doFlush(flushingDWPT);\n    } else {\n      final DocumentsWriterPerThread nextPendingFlush = flushControl.nextPendingFlush();\n      if (nextPendingFlush != null) {\n        maybeMerge |= doFlush(nextPendingFlush);\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00afe74a80796ed1f30a9509b150ff104746a1f","date":1312881735,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = perThreadPool.getAndLock(Thread.currentThread(), this);\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","bugFix":["2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","sourceOld":"  boolean updateDocument(final Document doc, final Analyzer analyzer,\n      final Term delTerm) throws CorruptIndexException, IOException {\n\n    boolean maybeMerge = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    \n    try {\n\n      if (!perThread.isActive()) {\n        ensureOpen();\n        assert false: \"perThread is not active but we are still open\";\n      }\n       \n      final DocumentsWriterPerThread dwpt = perThread.perThread;\n      try {\n        dwpt.updateDocument(doc, analyzer, delTerm); \n        numDocsInRAM.incrementAndGet();\n      } finally {\n        if (dwpt.checkAndResetHasAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n    } finally {\n      perThread.unlock();\n    }\n\n    return postUpdate(flushingDWPT, maybeMerge);\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["334c1175813aea771a71728cd2c4ee4754fd0603"],"24736f886f499d15345d6c4b717b9fe84a70dae2":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["8fe956d65251358d755c56f14fe8380644790e47","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"f6f4cae61e16730201371ab7e9912721c19324e7":["d37796041ff1a34fbe02a8b646945bac6c1d5a0f"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27"],"d37796041ff1a34fbe02a8b646945bac6c1d5a0f":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27"],"32f306edd62f81390a6e263e8b913f089f3e98a1":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["86c34ea6a885f625f2e464756450d45b72653ef3","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"1224a4027481acce15495b03bce9b48b93b42722":["14ec33385f6fbb6ce172882d14605790418a5d31"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["c3a8a449466c1ff7ce2274fe73dab487256964b4","2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27"],"ff78505662c0b741e2663a9f38a4889c12a32c9f":["dc5ecd93bcd50b2199757091d526fc1bcbce0db1"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["24736f886f499d15345d6c4b717b9fe84a70dae2"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["1224a4027481acce15495b03bce9b48b93b42722","f4f6945f5eb72bd7d9722ab064a98eb1d8543afc"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["334c1175813aea771a71728cd2c4ee4754fd0603","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"334c1175813aea771a71728cd2c4ee4754fd0603":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"f4f6945f5eb72bd7d9722ab064a98eb1d8543afc":["f6f4cae61e16730201371ab7e9912721c19324e7"],"2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"3161e3ffcf20c09a22504a589d4d9bd273e11e33":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"dc5ecd93bcd50b2199757091d526fc1bcbce0db1":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["135621f3a0670a9394eb563224a3b76cc4dddc0f","32f306edd62f81390a6e263e8b913f089f3e98a1"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","1224a4027481acce15495b03bce9b48b93b42722"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"a3776dccca01c11e7046323cfad46a3b4a471233":["1224a4027481acce15495b03bce9b48b93b42722","32f306edd62f81390a6e263e8b913f089f3e98a1"],"86c34ea6a885f625f2e464756450d45b72653ef3":["14975dba6846360ff627c6797726fa4899a3413d"],"8fe956d65251358d755c56f14fe8380644790e47":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"14975dba6846360ff627c6797726fa4899a3413d":["3161e3ffcf20c09a22504a589d4d9bd273e11e33"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["ff78505662c0b741e2663a9f38a4889c12a32c9f","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1509f151d7692d84fae414b2b799ac06ba60fcb4"]},"commit2Childs":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","ab5cb6a74aefb78aa0569857970b9151dfe2e787","dc5ecd93bcd50b2199757091d526fc1bcbce0db1","b0c7a8f7304b75b1528814c5820fa23a96816c27","868da859b43505d9d2a023bfeae6dd0c795f5295"],"24736f886f499d15345d6c4b717b9fe84a70dae2":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["dc5ecd93bcd50b2199757091d526fc1bcbce0db1"],"f6f4cae61e16730201371ab7e9912721c19324e7":["f4f6945f5eb72bd7d9722ab064a98eb1d8543afc"],"d37796041ff1a34fbe02a8b646945bac6c1d5a0f":["f6f4cae61e16730201371ab7e9912721c19324e7"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"14ec33385f6fbb6ce172882d14605790418a5d31":["1224a4027481acce15495b03bce9b48b93b42722"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"32f306edd62f81390a6e263e8b913f089f3e98a1":["2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["24736f886f499d15345d6c4b717b9fe84a70dae2"],"1224a4027481acce15495b03bce9b48b93b42722":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[],"ff78505662c0b741e2663a9f38a4889c12a32c9f":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014","8fe956d65251358d755c56f14fe8380644790e47"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["32f306edd62f81390a6e263e8b913f089f3e98a1","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"334c1175813aea771a71728cd2c4ee4754fd0603":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["d37796041ff1a34fbe02a8b646945bac6c1d5a0f"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["334c1175813aea771a71728cd2c4ee4754fd0603"],"f4f6945f5eb72bd7d9722ab064a98eb1d8543afc":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27":["c00afe74a80796ed1f30a9509b150ff104746a1f","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"dc5ecd93bcd50b2199757091d526fc1bcbce0db1":["ff78505662c0b741e2663a9f38a4889c12a32c9f"],"3161e3ffcf20c09a22504a589d4d9bd273e11e33":["14975dba6846360ff627c6797726fa4899a3413d"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"8fe956d65251358d755c56f14fe8380644790e47":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"86c34ea6a885f625f2e464756450d45b72653ef3":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"14975dba6846360ff627c6797726fa4899a3413d":["86c34ea6a885f625f2e464756450d45b72653ef3"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["3161e3ffcf20c09a22504a589d4d9bd273e11e33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}