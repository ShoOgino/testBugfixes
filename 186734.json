{"path":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","commits":[{"id":"51cd38b90c674ebecc798654e3574d5790a9aced","date":1202762089,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","pathOld":"/dev/null","sourceNew":"  /** Expunges all deletes from the index.  When and index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unusged data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#maxDoc - IndexReader#numDocs}.\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)}*/\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6175902c90e080540b28a317683aec12603dc9fb","date":1203221730,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","sourceNew":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#maxDoc - IndexReader#numDocs}.\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)} */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","sourceOld":"  /** Expunges all deletes from the index.  When and index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unusged data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#maxDoc - IndexReader#numDocs}.\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)}*/\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7fe9985d49937438f4dad2dbfabc93f8196c8b3","date":1222123293,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","sourceNew":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#numDeletedDocs}\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)} */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","sourceOld":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#maxDoc - IndexReader#numDocs}.\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)} */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9665d17707cc21b1db995118ff36129723139ab","date":1225384420,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","sourceNew":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#numDeletedDocs}\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)}\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","sourceOld":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#numDeletedDocs}\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)} */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#expungeDeletes().mjava","sourceNew":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#numDeletedDocs}\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)}\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","sourceOld":"  /** Expunges all deletes from the index.  When an index\n   *  has many document deletions (or updates to existing\n   *  documents), it's best to either call optimize or\n   *  expungeDeletes to remove all unused data in the index\n   *  associated with the deleted documents.  To see how\n   *  many deletions you have pending in your index, call\n   *  {@link IndexReader#numDeletedDocs}\n   *  This saves disk space and memory usage while\n   *  searching.  expungeDeletes should be somewhat faster\n   *  than optimize since it does not insist on reducing the\n   *  index to a single segment (though, this depends on the\n   *  {@link MergePolicy}; see {@link\n   *  MergePolicy#findMergesToExpungeDeletes}.). Note that\n   *  this call does not first commit any buffered\n   *  documents, so you must do so yourself if necessary.\n   *  See also {@link #expungeDeletes(boolean)}\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void expungeDeletes() throws CorruptIndexException, IOException {\n    expungeDeletes(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9665d17707cc21b1db995118ff36129723139ab":["b7fe9985d49937438f4dad2dbfabc93f8196c8b3"],"b7fe9985d49937438f4dad2dbfabc93f8196c8b3":["6175902c90e080540b28a317683aec12603dc9fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"51cd38b90c674ebecc798654e3574d5790a9aced":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6175902c90e080540b28a317683aec12603dc9fb":["51cd38b90c674ebecc798654e3574d5790a9aced"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e9665d17707cc21b1db995118ff36129723139ab"]},"commit2Childs":{"e9665d17707cc21b1db995118ff36129723139ab":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b7fe9985d49937438f4dad2dbfabc93f8196c8b3":["e9665d17707cc21b1db995118ff36129723139ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51cd38b90c674ebecc798654e3574d5790a9aced"],"51cd38b90c674ebecc798654e3574d5790a9aced":["6175902c90e080540b28a317683aec12603dc9fb"],"6175902c90e080540b28a317683aec12603dc9fb":["b7fe9985d49937438f4dad2dbfabc93f8196c8b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}