{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/FST#pack(int,int).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  ~8 bytes per node), but then should produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.length);\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0;node<inCounts.length;node++) {\n      if (inCounts[node] >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, inCounts[node]));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts[node] > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, inCounts[node]));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // TODO: we can use packed ints:\n    // +1 because node ords start at 1 (0 is reserved as\n    // stop node):\n    final int[] nodeRefToAddressIn = new int[topNodeMap.size()];\n\n    final FST<T> fst = new FST<T>(inputType, nodeRefToAddressIn, outputs);\n\n    final BytesWriter writer = fst.writer;\n    \n    final int[] newNodeAddress = new int[1+nodeCount];\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress[node] = 1 + bytes.length - nodeAddress[node];\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress[node]) {\n          addressError = address - newNodeAddress[node];\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress[node] = address;\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress[arc.target] + addressError;\n              }\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn[ent.getValue()] = newNodeAddress[ent.getKey()];\n    }\n\n    fst.startNode = newNodeAddress[startNode];\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  ~8 bytes per node), but then should produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.length);\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0;node<inCounts.length;node++) {\n      if (inCounts[node] >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, inCounts[node]));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts[node] > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, inCounts[node]));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // TODO: we can use packed ints:\n    // +1 because node ords start at 1 (0 is reserved as\n    // stop node):\n    final int[] nodeRefToAddressIn = new int[topNodeMap.size()];\n\n    final FST<T> fst = new FST<T>(inputType, nodeRefToAddressIn, outputs);\n\n    final BytesWriter writer = fst.writer;\n    \n    final int[] newNodeAddress = new int[1+nodeCount];\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress[node] = 1 + bytes.length - nodeAddress[node];\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress[node]) {\n          addressError = address - newNodeAddress[node];\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress[node] = address;\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress[arc.target] + addressError;\n              }\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn[ent.getValue()] = newNodeAddress[ent.getKey()];\n    }\n\n    fst.startNode = newNodeAddress[startNode];\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  ~8 bytes per node), but then should produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.length);\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0;node<inCounts.length;node++) {\n      if (inCounts[node] >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, inCounts[node]));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts[node] > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, inCounts[node]));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // TODO: we can use packed ints:\n    // +1 because node ords start at 1 (0 is reserved as\n    // stop node):\n    final int[] nodeRefToAddressIn = new int[topNodeMap.size()];\n\n    final FST<T> fst = new FST<T>(inputType, nodeRefToAddressIn, outputs);\n\n    final BytesWriter writer = fst.writer;\n    \n    final int[] newNodeAddress = new int[1+nodeCount];\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress[node] = 1 + bytes.length - nodeAddress[node];\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress[node]) {\n          addressError = address - newNodeAddress[node];\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress[node] = address;\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress[arc.target] + addressError;\n              }\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn[ent.getValue()] = newNodeAddress[ent.getKey()];\n    }\n\n    fst.startNode = newNodeAddress[startNode];\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edb74c83fff94196b864e08ca033d92823252cb7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["edb74c83fff94196b864e08ca033d92823252cb7"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["edb74c83fff94196b864e08ca033d92823252cb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"edb74c83fff94196b864e08ca033d92823252cb7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}