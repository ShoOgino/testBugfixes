{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","commits":[{"id":"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","date":1337196931,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              wait.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              wait.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","date":1337674113,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              assertTrue(wait.await(10, TimeUnit.SECONDS));\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + wait.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              wait.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","bugFix":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":["a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              assertTrue(wait.await(10, TimeUnit.SECONDS));\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + wait.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              wait.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3","date":1339345566,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            CountDownLatch join = latches[0];\n            CountDownLatch wait = latches[1];\n            join.countDown();\n            try {\n              assertTrue(wait.await(10, TimeUnit.SECONDS));\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + wait.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n          }\n          Thread.yield();\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n    }\n\n","bugFix":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e38f40562eb7c165ae08ab2367a031883138354","date":1340287338,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n        memCtrl.limit = 1000;\n        memCtrl.netBytes = release ? 1 : 2000;\n        memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(memCtrl);\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","sourceOld":"    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.Updater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","sourceOld":"    public void run() {\n      try {\n       \n        while (!stop.get()) {\n          int internalIters = release && random().nextBoolean() ? atLeast(5) : 1;\n          for (int i = 0; i < internalIters; i++) {\n            ctrl.updateStalled(random().nextBoolean());\n          }\n          if (checkPoint.get()) {\n            sync.updateJoin.countDown();\n            try {\n              assertTrue(sync.await());\n            } catch (InterruptedException e) {\n              System.out.println(\"[Updater] got interrupted - wait count: \" + sync.waiter.getCount());\n              throw new ThreadInterruptedException(e);\n            }\n            sync.leftCheckpoint.countDown();\n          }\n          if (random().nextBoolean()) {\n            Thread.yield();\n          }\n        }\n      } catch (Throwable e) {\n        e.printStackTrace();\n        exceptions.add(e);\n      }\n      sync.updateJoin.countDown();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["5e38f40562eb7c165ae08ab2367a031883138354","7530de27b87b961b51f01bd1299b7004d46e8823"],"5e38f40562eb7c165ae08ab2367a031883138354":["a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3","5e38f40562eb7c165ae08ab2367a031883138354"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["ef0d8a69209261514c5739c770bba706c2308450","7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["5e38f40562eb7c165ae08ab2367a031883138354"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"5e38f40562eb7c165ae08ab2367a031883138354":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe33227f6805edab2036cbb80645cc4e2d1fa424","7530de27b87b961b51f01bd1299b7004d46e8823"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","ef0d8a69209261514c5739c770bba706c2308450"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","ef0d8a69209261514c5739c770bba706c2308450"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["3599646b4d4c346cf74d334813488b8b337b5bf5","a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3":["5e38f40562eb7c165ae08ab2367a031883138354","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ef0d8a69209261514c5739c770bba706c2308450":["3599646b4d4c346cf74d334813488b8b337b5bf5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe33227f6805edab2036cbb80645cc4e2d1fa424","3599646b4d4c346cf74d334813488b8b337b5bf5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}