{"path":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","commits":[{"id":"10cd47aac3c4e8c583740a750335f8aab14555b3","date":1332522358,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<Object>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<Class<?>, ClassCache>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<Object>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8913cb9a44846cb65e41bee682ba0372f1636056","8913cb9a44846cb65e41bee682ba0372f1636056","8913cb9a44846cb65e41bee682ba0372f1636056","8913cb9a44846cb65e41bee682ba0372f1636056"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<Object>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<Class<?>, ClassCache>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<Object>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cb97c817fe57034d024bf390b66c10a99aaf2a0","date":1399904904,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","date":1400053604,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1eb6b3ce884c0b9e064e112da158013ec33cd91","date":1402692077,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Filter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Filter filter) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            if (filter.accept(f)) {\n              // Fast path to eliminate redundancies.\n              final Object o = f.get(ob);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["10cd47aac3c4e8c583740a750335f8aab14555b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0cb97c817fe57034d024bf390b66c10a99aaf2a0"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["0cb97c817fe57034d024bf390b66c10a99aaf2a0","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["0cb97c817fe57034d024bf390b66c10a99aaf2a0"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"0cb97c817fe57034d024bf390b66c10a99aaf2a0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","0cb97c817fe57034d024bf390b66c10a99aaf2a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["10cd47aac3c4e8c583740a750335f8aab14555b3"],"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36":[],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0cb97c817fe57034d024bf390b66c10a99aaf2a0":["a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","c6f080a2ab37c464dd98db173f6cbf10dc74f211","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}