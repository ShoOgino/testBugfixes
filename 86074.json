{"path":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","commits":[{"id":"9a5b816df64f2b489d1e711be80f9416f9862c1b","date":1487973679,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[]).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits) {\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    Boolean setShardIndex = null;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        if (shard.scoreDocs[0].shardIndex == -1) {\n          if (setShardIndex != null && setShardIndex == false) {\n            throw new IllegalStateException(\"scoreDocs at index \" + shardIDX + \" has undefined shard indices but previous scoreDocs were predefined\");\n          }\n          setShardIndex = true;\n        } else {\n          if (setShardIndex != null && setShardIndex) {\n            throw new IllegalStateException(\"scoreDocs at index \" + shardIDX + \" has predefined shard indices but previous scoreDocs were undefined\");\n          }\n          setShardIndex = false;\n        }\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // unless this index is already initialized potentially due to multiple merge phases, or explicitly by the user\n          // we set the shard index to the index of the TopDocs array this hit is coming from.\n          // this allows multiple merge phases if needed but requires extra accounting on the users end.\n          // at the same time this is fully backwards compatible since the value was initialize to -1 from the beginning\n          hit.shardIndex = ref.shardIndex;\n        }\n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        //System.out.println(\"  hitUpto=\" + hitUpto);\n        //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":5,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],Comparator[ScoreDoc]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits,\n                                  Comparator<ScoreDoc> tieBreaker) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits, tieBreaker);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits, tieBreaker);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    boolean unsetShardIndex = false;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n\n        // Irrespective of whether we use shard indices for tie breaking or not, we check for consistent\n        // order in shard indices to defend against potential bugs\n        if (hitUpto > 0) {\n          if (unsetShardIndex != (hit.shardIndex == -1)) {\n            throw new IllegalArgumentException(\"Inconsistent order of shard indices\");\n          }\n        }\n\n        unsetShardIndex |= hit.shardIndex == -1;\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],Comparator[ScoreDoc]).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits,\n                                  Comparator<ScoreDoc> tieBreaker) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits, tieBreaker);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits, tieBreaker);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    boolean unsetShardIndex = false;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n\n        // Irrespective of whether we use shard indices for tie breaking or not, we check for consistent\n        // order in shard indices to defend against potential bugs\n        if (hitUpto > 0) {\n          if (unsetShardIndex != (hit.shardIndex == -1)) {\n            throw new IllegalArgumentException(\"Inconsistent order of shard indices\");\n          }\n        }\n\n        unsetShardIndex |= hit.shardIndex == -1;\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":5,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],Comparator[ScoreDoc]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[],boolean).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits,\n                                  Comparator<ScoreDoc> tieBreaker) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits, tieBreaker);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits, tieBreaker);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    boolean unsetShardIndex = false;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n\n        // Irrespective of whether we use shard indices for tie breaking or not, we check for consistent\n        // order in shard indices to defend against potential bugs\n        if (hitUpto > 0) {\n          if (unsetShardIndex != (hit.shardIndex == -1)) {\n            throw new IllegalArgumentException(\"Inconsistent order of shard indices\");\n          }\n        }\n\n        unsetShardIndex |= hit.shardIndex == -1;\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","sourceOld":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits, boolean setShardIndex) {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    long totalHitCount = 0;\n    TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO;\n    int availHitCount = 0;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits.value;\n      // If any hit count is a lower bound then the merged\n      // total hit count is a lower bound as well\n      if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX, setShardIndex == false));\n      }\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.top();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        if (setShardIndex) {\n          // caller asked us to record shardIndex (index of the TopDocs array) this hit is coming from:\n          hit.shardIndex = ref.shardIndex;\n        } else if (hit.shardIndex == -1) {\n          throw new IllegalArgumentException(\"setShardIndex is false but TopDocs[\" + ref.shardIndex + \"].scoreDocs[\" + (ref.hitIndex-1) + \"] is not set\");\n        }\n          \n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.updateTop();\n        } else {\n          queue.pop();\n        }\n      }\n    }\n\n    TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation);\n    if (sort == null) {\n      return new TopDocs(totalHits, hits);\n    } else {\n      return new TopFieldDocs(totalHits, hits, sort.getSort());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"36510a8e3c1ec60d366b45f8f716e9dc47589661":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["9a5b816df64f2b489d1e711be80f9416f9862c1b","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["9a5b816df64f2b489d1e711be80f9416f9862c1b","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"]},"commit2Childs":{"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"fccd4a691aac1aff06ab8110d8693514a34160c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}