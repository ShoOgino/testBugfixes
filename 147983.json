{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","commits":[{"id":"b7b5b9bd55a953275a0efc3c5272ed76129541fb","date":1546921668,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"/dev/null","sourceNew":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = true;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else {\n            sdoc = (SolrInputDocument) o;\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4996819a2e14e1ee8bf4273ae5ccc179860bd28e","date":1546928779,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","sourceNew":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else {\n            sdoc = (SolrInputDocument) o;\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = true;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else {\n            sdoc = (SolrInputDocument) o;\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"074c4e385ea7c9ae29556e95c886ea0ccc614029","date":1571011658,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","sourceNew":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else {\n            sdoc = (SolrInputDocument) o;\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","sourceNew":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else {\n            sdoc = (SolrInputDocument) o;\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":"    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/request/JavaBinUpdateRequestCodec.StreamingCodec#readOuterMostDocIterator(DataInputInputStream).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.emptyList();\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private List readOuterMostDocIterator(DataInputInputStream fis) throws IOException {\n      if(namedList[0] == null) namedList[0] = new NamedList();\n      NamedList params = (NamedList) namedList[0].get(\"params\");\n      if (params == null) params = new NamedList();\n      updateRequest.setParams(new ModifiableSolrParams(params.toSolrParams()));\n      if (handler == null) return super.readIterator(fis);\n      Integer commitWithin = null;\n      Boolean overwrite = null;\n      Object o = null;\n      super.readStringAsCharSeq = JavaBinUpdateRequestCodec.this.readStringAsCharSeq;\n      try {\n        while (true) {\n          if (o == null) {\n            o = readVal(fis);\n          }\n\n          if (o == END_OBJ) {\n            break;\n          }\n\n          SolrInputDocument sdoc = null;\n          if (o instanceof List) {\n            sdoc = listToSolrInputDocument((List<NamedList>) o);\n          } else if (o instanceof NamedList) {\n            UpdateRequest req = new UpdateRequest();\n            req.setParams(new ModifiableSolrParams(((NamedList) o).toSolrParams()));\n            handler.update(null, req, null, null);\n          } else if (o instanceof Map.Entry) {\n            sdoc = (SolrInputDocument) ((Entry) o).getKey();\n            Map p = (Map) ((Entry) o).getValue();\n            if (p != null) {\n              commitWithin = (Integer) p.get(UpdateRequest.COMMIT_WITHIN);\n              overwrite = (Boolean) p.get(UpdateRequest.OVERWRITE);\n            }\n          } else if (o instanceof SolrInputDocument) {\n            sdoc = (SolrInputDocument) o;\n          } else if (o instanceof Map) {\n            sdoc = convertMapToSolrInputDoc((Map) o);\n          }\n\n          // peek at the next object to see if we're at the end\n          o = readVal(fis);\n          if (o == END_OBJ) {\n            // indicate that we've hit the last doc in the batch, used to enable optimizations when doing replication\n            updateRequest.lastDocInBatch();\n          }\n\n          handler.update(sdoc, updateRequest, commitWithin, overwrite);\n        }\n        return Collections.EMPTY_LIST;\n      } finally {\n        super.readStringAsCharSeq = false;\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b7b5b9bd55a953275a0efc3c5272ed76129541fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3adc4d119a7deba35b2721853853464857d9d0a9":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["074c4e385ea7c9ae29556e95c886ea0ccc614029"],"4996819a2e14e1ee8bf4273ae5ccc179860bd28e":["b7b5b9bd55a953275a0efc3c5272ed76129541fb"],"074c4e385ea7c9ae29556e95c886ea0ccc614029":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3adc4d119a7deba35b2721853853464857d9d0a9"],"b0b597c65628ca9e73913a07e81691f8229bae35":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e","074c4e385ea7c9ae29556e95c886ea0ccc614029"]},"commit2Childs":{"b7b5b9bd55a953275a0efc3c5272ed76129541fb":["4996819a2e14e1ee8bf4273ae5ccc179860bd28e"],"3adc4d119a7deba35b2721853853464857d9d0a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7b5b9bd55a953275a0efc3c5272ed76129541fb"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["3adc4d119a7deba35b2721853853464857d9d0a9"],"4996819a2e14e1ee8bf4273ae5ccc179860bd28e":["074c4e385ea7c9ae29556e95c886ea0ccc614029","b0b597c65628ca9e73913a07e81691f8229bae35"],"074c4e385ea7c9ae29556e95c886ea0ccc614029":["a7dfea4f7c80813344b0152e37fc18b31369e8ff","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}