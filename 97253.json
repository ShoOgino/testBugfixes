{"path":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"48d548a14602be2584dd07e610109753923812e2","date":1269205557,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":["a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43adc163640856c8b07e4cf1b2046c9af56d3ae7","date":1286989273,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      // nocommit: why did solrconfig override core descriptor !?\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      // nocommit: why did solrconfig override core descriptor !?\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b41588245d585490c9ceef6f2b986cb112b954","date":1287919882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      // nocommit: why did solrconfig override core descriptor !?\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e","date":1287925305,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      // nocommit: why did solrconfig override core descriptor !?\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"863f5f4b9cd4134d4bd9d6528419bf72ddbe4433","date":1293817845,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1c76c72faecc7c9b683ad67e99240c975ee37b3","date":1301109514,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55688cada84e99928d155229fc2768df65a45bdb","date":1306274128,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a71a0b2d4be2299a163f60626729852d81a8e02","date":1309442399,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384","c9767265f21f7d1246b13dd7e73e8a4ad88b4384","c9767265f21f7d1246b13dd7e73e8a4ad88b4384","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   * \n   * @param name\n   * @param dataDir the index directory\n   * @param config a solr config instance\n   * @param schema a solr schema instance\n   * @param cd\n   * \n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    this(name, dataDir, config, schema, cd, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["7a71a0b2d4be2299a163f60626729852d81a8e02","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c1c76c72faecc7c9b683ad67e99240c975ee37b3":["863f5f4b9cd4134d4bd9d6528419bf72ddbe4433"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["48d548a14602be2584dd07e610109753923812e2","bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["55688cada84e99928d155229fc2768df65a45bdb"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"48d548a14602be2584dd07e610109753923812e2":["1da8d55113b689b06716246649de6f62430f15c0"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c1c76c72faecc7c9b683ad67e99240c975ee37b3","55688cada84e99928d155229fc2768df65a45bdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"55688cada84e99928d155229fc2768df65a45bdb":["c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["d619839baa8ce5503e496b94a9e42ad6f079293f","55688cada84e99928d155229fc2768df65a45bdb"],"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["48d548a14602be2584dd07e610109753923812e2"],"70ad682703b8585f5d0a637efec044d57ec05efb":["b12d3e81e0f95a4527b5703953c503f71120ffcc","863f5f4b9cd4134d4bd9d6528419bf72ddbe4433"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"863f5f4b9cd4134d4bd9d6528419bf72ddbe4433":["bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e"],"bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e":["23b41588245d585490c9ceef6f2b986cb112b954"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["55688cada84e99928d155229fc2768df65a45bdb","7a71a0b2d4be2299a163f60626729852d81a8e02"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","7a71a0b2d4be2299a163f60626729852d81a8e02"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","863f5f4b9cd4134d4bd9d6528419bf72ddbe4433"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["70ad682703b8585f5d0a637efec044d57ec05efb","c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["48d548a14602be2584dd07e610109753923812e2","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"23b41588245d585490c9ceef6f2b986cb112b954":["43adc163640856c8b07e4cf1b2046c9af56d3ae7"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c1c76c72faecc7c9b683ad67e99240c975ee37b3":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","55688cada84e99928d155229fc2768df65a45bdb","d619839baa8ce5503e496b94a9e42ad6f079293f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["c26f00b574427b55127e869b935845554afde1fa","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","a258fbb26824fd104ed795e5d9033d2d040049ee"],"1da8d55113b689b06716246649de6f62430f15c0":["48d548a14602be2584dd07e610109753923812e2"],"48d548a14602be2584dd07e610109753923812e2":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","43adc163640856c8b07e4cf1b2046c9af56d3ae7","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"55688cada84e99928d155229fc2768df65a45bdb":["7a71a0b2d4be2299a163f60626729852d81a8e02","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[],"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","23b41588245d585490c9ceef6f2b986cb112b954"],"70ad682703b8585f5d0a637efec044d57ec05efb":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"863f5f4b9cd4134d4bd9d6528419bf72ddbe4433":["c1c76c72faecc7c9b683ad67e99240c975ee37b3","70ad682703b8585f5d0a637efec044d57ec05efb","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","863f5f4b9cd4134d4bd9d6528419bf72ddbe4433","b12d3e81e0f95a4527b5703953c503f71120ffcc"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["70ad682703b8585f5d0a637efec044d57ec05efb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["b12d3e81e0f95a4527b5703953c503f71120ffcc"],"23b41588245d585490c9ceef6f2b986cb112b954":["bd2e3889d01a6a0a07edf8eba4a5e40f6b48ae4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","2e10cb22a8bdb44339e282925a29182bb2f3174d","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}