{"path":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","commits":[{"id":"7951c2882ffa4f7ac92f0af23dac5c66a981f89c","date":1371494272,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"/dev/null","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2106271e380c198349e0f6eac0395bb462913fab","date":1397072894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(TrieDateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331","date":1437383270,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateFormatUtil.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(TrieDateField.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3f6c7717a0f1decd1668144537943efcc70cd95","date":1459359762,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateFormatUtil.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":["ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29","date":1463148204,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      log.debug(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      log.debug(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      log.debug(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      // SOLR-4547: Removed the filenames from this log entry because this\n      // method is only called from methods that have just logged them\n      // at DEBUG.\n      log.info(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC, Locale.ROOT);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy#updateCommits(List[#-extends-IndexCommit]).mjava","sourceNew":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      if (log.isDebugEnabled()) {\n        log.debug(\"newest commit generation = {}\", newest.getGeneration());\n      }\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","sourceOld":"  private void updateCommits(List<? extends IndexCommit> commits) {\n    // to be safe, we should only call delete on a commit point passed to us\n    // in this specific call (may be across diff IndexWriter instances).\n    // this will happen rarely, so just synchronize everything\n    // for safety and to avoid race conditions\n\n    synchronized (this) {\n      long maxCommitAgeTimeStamp = -1L;\n      IndexCommit newest = commits.get(commits.size() - 1);\n      log.debug(\"newest commit generation = \" + newest.getGeneration());\n      int singleSegKept = (newest.getSegmentCount() == 1) ? 1 : 0;\n      int totalKept = 1;\n\n      // work our way from newest to oldest, skipping the first since we always want to keep it.\n      for (int i=commits.size()-2; i>=0; i--) {\n        IndexCommit commit = commits.get(i);\n\n        // delete anything too old, regardless of other policies\n        try {\n          if (maxCommitAge != null) {\n            if (maxCommitAgeTimeStamp==-1) {\n              DateMathParser dmp = new DateMathParser(DateMathParser.UTC);\n              maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();\n            }\n            if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {\n              commit.delete();\n              continue;\n            }\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception while checking commit point's age for deletion\", e);\n        }\n\n        if (singleSegKept < maxOptimizedCommitsToKeep && commit.getSegmentCount() == 1) {\n          totalKept++;\n          singleSegKept++;\n          continue;\n        }\n\n        if (totalKept < maxCommitsToKeep) {\n          totalKept++;\n          continue;\n        }\n                                                  \n        commit.delete();\n      }\n\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3f6c7717a0f1decd1668144537943efcc70cd95":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7951c2882ffa4f7ac92f0af23dac5c66a981f89c"],"0ad30c6a479e764150a3316e57263319775f1df2":["d3f6c7717a0f1decd1668144537943efcc70cd95","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d3f6c7717a0f1decd1668144537943efcc70cd95","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["2106271e380c198349e0f6eac0395bb462913fab"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["d3f6c7717a0f1decd1668144537943efcc70cd95","0ad30c6a479e764150a3316e57263319775f1df2"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"a5d615d62cd8aff3690943d765e46942551f98b6":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"2106271e380c198349e0f6eac0395bb462913fab":["7951c2882ffa4f7ac92f0af23dac5c66a981f89c"],"140be51d03394488536f4aacedace29f9b318347":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7951c2882ffa4f7ac92f0af23dac5c66a981f89c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["d470c8182e92b264680e34081b75e70a9f2b3c89","a5d615d62cd8aff3690943d765e46942551f98b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"]},"commit2Childs":{"d3f6c7717a0f1decd1668144537943efcc70cd95":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a5d615d62cd8aff3690943d765e46942551f98b6","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["0ad30c6a479e764150a3316e57263319775f1df2"],"a5d615d62cd8aff3690943d765e46942551f98b6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"2106271e380c198349e0f6eac0395bb462913fab":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","7951c2882ffa4f7ac92f0af23dac5c66a981f89c"],"7951c2882ffa4f7ac92f0af23dac5c66a981f89c":["37a0f60745e53927c4c876cfe5b5a58170f0646c","2106271e380c198349e0f6eac0395bb462913fab"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","140be51d03394488536f4aacedace29f9b318347"],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}