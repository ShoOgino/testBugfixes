{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","commits":[{"id":"d60fd4bf1b42425aefd75d8a133d8d7ea41722e9","date":1564497726,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = tuple.getString(\"file\");\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deb4d0cfb021fa1b0c1e44571968b254f379ac6f","date":1564497726,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = tuple.getString(\"file\");\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = tuple.getString(\"file\");\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35cc45f54fe95a5534e02f9b8ca2a54af211ded5","date":1564774706,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = formatFile(tuple.getString(\"file\"));\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = tuple.getString(\"file\");\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":0,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = formatFile(tuple.getString(\"file\"));\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan HÃ¸ydahl","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = formatFile(tuple.getString(\"file\"));\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = tuple.getString(\"file\");\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CsvStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = formatFile(tuple.getString(\"file\"));\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple();\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple tuple = originalStream.read();\n    ++lineNumber;\n    if(tuple.EOF) {\n      return tuple;\n    } else {\n      String file = formatFile(tuple.getString(\"file\"));\n      String line = tuple.getString(\"line\");\n      if (file.equals(currentFile)) {\n        String[] fields = split(line);\n        if(fields.length != headers.length) {\n          throw new IOException(\"Headers and lines must have the same number of fields [file:\"+file+\" line number:\"+lineNumber+\"]\");\n        }\n        Tuple out = new Tuple(new HashMap());\n        out.put(\"id\", file+\"_\"+lineNumber);\n        for(int i=0; i<headers.length; i++) {\n          if(fields[i] != null && fields[i].length() > 0) {\n            out.put(headers[i], fields[i]);\n          }\n        }\n        return out;\n      } else {\n        this.currentFile = file;\n        this.headers = split(line);\n        this.lineNumber = 1; //New file so reset the lineNumber\n        return read();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d60fd4bf1b42425aefd75d8a133d8d7ea41722e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["deb4d0cfb021fa1b0c1e44571968b254f379ac6f","35cc45f54fe95a5534e02f9b8ca2a54af211ded5"],"804a8d5358fe7b7563b85ee7838714d720b89272":["35cc45f54fe95a5534e02f9b8ca2a54af211ded5"],"35cc45f54fe95a5534e02f9b8ca2a54af211ded5":["deb4d0cfb021fa1b0c1e44571968b254f379ac6f"],"deb4d0cfb021fa1b0c1e44571968b254f379ac6f":["d60fd4bf1b42425aefd75d8a133d8d7ea41722e9"],"f8061ddd97f3352007d927dae445884a6f3d857b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","35cc45f54fe95a5534e02f9b8ca2a54af211ded5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["804a8d5358fe7b7563b85ee7838714d720b89272"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d60fd4bf1b42425aefd75d8a133d8d7ea41722e9","f8061ddd97f3352007d927dae445884a6f3d857b"],"d60fd4bf1b42425aefd75d8a133d8d7ea41722e9":["deb4d0cfb021fa1b0c1e44571968b254f379ac6f"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"804a8d5358fe7b7563b85ee7838714d720b89272":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"deb4d0cfb021fa1b0c1e44571968b254f379ac6f":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","35cc45f54fe95a5534e02f9b8ca2a54af211ded5"],"35cc45f54fe95a5534e02f9b8ca2a54af211ded5":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","804a8d5358fe7b7563b85ee7838714d720b89272","f8061ddd97f3352007d927dae445884a6f3d857b"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}