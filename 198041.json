{"path":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.OfMatchesIteratorWithSubs#queryToTerm(Query).mjava","commits":[{"id":"795822cce6616d4035b5a4bdbb6c113ea2f715ba","date":1535599765,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.OfMatchesIteratorWithSubs#queryToTerm(Query).mjava","pathOld":"/dev/null","sourceNew":"    /** Maps a Query from {@link MatchesIterator#getQuery()} to {@link OffsetsEnum#getTerm()}.\n     * See {@link Passage#getMatchTerms()}. */\n    private BytesRef queryToTerm(Query query) {\n      // compute an approximate BytesRef term of a Query.  We cache this since we're likely to see the same query again.\n      // Our approach is to call extractTerms and visit each term in order, concatenating them with an adjoining space.\n      //  If we don't have any (perhaps due to an MTQ like a wildcard) then we fall back on the toString() of the query.\n      return queryToTermMap.computeIfAbsent(query, (Query q) -> {\n        try {\n          BytesRefBuilder bytesRefBuilder = new BytesRefBuilder();\n          UnifiedHighlighter.EMPTY_INDEXSEARCHER\n              .createWeight(UnifiedHighlighter.EMPTY_INDEXSEARCHER.rewrite(q), ScoreMode.COMPLETE_NO_SCORES, 1f)\n              .extractTerms(new TreeSet<Term>() {\n            @Override\n            public boolean add(Term term) {\n              if (bytesRefBuilder.length() > 0) {\n                bytesRefBuilder.append((byte) ' ');\n              }\n              bytesRefBuilder.append(term.bytes());\n              return true;\n            }\n          });\n          if (bytesRefBuilder.length() > 0) {\n            return bytesRefBuilder.get();\n          }\n        } catch (IOException e) {//ignore\n          // go to fallback...\n        }\n\n        // fallback:  (likely a MultiTermQuery)\n        return new BytesRef(q.toString());\n      });\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.OfMatchesIteratorWithSubs#queryToTerm(Query).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.OfMatchesIteratorWithSubs#queryToTerm(Query).mjava","sourceNew":"    /** Maps a Query from {@link MatchesIterator#getQuery()} to {@link OffsetsEnum#getTerm()}.\n     * See {@link Passage#getMatchTerms()}. */\n    private BytesRef queryToTerm(Query query) {\n      // compute an approximate BytesRef term of a Query.  We cache this since we're likely to see the same query again.\n      // Our approach is to visit each matching term in order, concatenating them with an adjoining space.\n      //  If we don't have any (perhaps due to an MTQ like a wildcard) then we fall back on the toString() of the query.\n      return queryToTermMap.computeIfAbsent(query, (Query q) -> {\n        BytesRefBuilder bytesRefBuilder = new BytesRefBuilder();\n        q.visit(new QueryVisitor() {\n          @Override\n          public void consumeTerms(Query query, Term... terms) {\n            for (Term term : terms) {\n              if (bytesRefBuilder.length() > 0) {\n                bytesRefBuilder.append((byte) ' ');\n              }\n              bytesRefBuilder.append(term.bytes());\n            }\n          }\n        });\n        if (bytesRefBuilder.length() > 0) {\n          return bytesRefBuilder.get();\n        }\n        // fallback:  (likely a MultiTermQuery)\n        return new BytesRef(q.toString());\n      });\n    }\n\n","sourceOld":"    /** Maps a Query from {@link MatchesIterator#getQuery()} to {@link OffsetsEnum#getTerm()}.\n     * See {@link Passage#getMatchTerms()}. */\n    private BytesRef queryToTerm(Query query) {\n      // compute an approximate BytesRef term of a Query.  We cache this since we're likely to see the same query again.\n      // Our approach is to call extractTerms and visit each term in order, concatenating them with an adjoining space.\n      //  If we don't have any (perhaps due to an MTQ like a wildcard) then we fall back on the toString() of the query.\n      return queryToTermMap.computeIfAbsent(query, (Query q) -> {\n        try {\n          BytesRefBuilder bytesRefBuilder = new BytesRefBuilder();\n          UnifiedHighlighter.EMPTY_INDEXSEARCHER\n              .createWeight(UnifiedHighlighter.EMPTY_INDEXSEARCHER.rewrite(q), ScoreMode.COMPLETE_NO_SCORES, 1f)\n              .extractTerms(new TreeSet<Term>() {\n            @Override\n            public boolean add(Term term) {\n              if (bytesRefBuilder.length() > 0) {\n                bytesRefBuilder.append((byte) ' ');\n              }\n              bytesRefBuilder.append(term.bytes());\n              return true;\n            }\n          });\n          if (bytesRefBuilder.length() > 0) {\n            return bytesRefBuilder.get();\n          }\n        } catch (IOException e) {//ignore\n          // go to fallback...\n        }\n\n        // fallback:  (likely a MultiTermQuery)\n        return new BytesRef(q.toString());\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"795822cce6616d4035b5a4bdbb6c113ea2f715ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["795822cce6616d4035b5a4bdbb6c113ea2f715ba"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["795822cce6616d4035b5a4bdbb6c113ea2f715ba"],"795822cce6616d4035b5a4bdbb6c113ea2f715ba":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}