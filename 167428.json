{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa9fef69a29d64a132d51b8bca52175417bdb0c1","date":1312388297,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      Map<String,String> coreAttribs = new HashMap<String,String>();\n      for (SolrCore solrCore : cores.values()) {\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":["8d2901bdb2faeb41d619d969ce5655adf783746d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4901f8624f774c2b648e66567b63c59e901ac7c8","date":1329431044,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name;\n        \n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    coresAttribs.put(\"adminPath\", adminPath);\n    if (adminHandler != null) coresAttribs.put(\"adminHandler\", adminHandler);\n    if (shareSchema) coresAttribs.put(\"shareSchema\", \"true\");\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    if (host != null) coresAttribs.put(\"host\", host);\n    if (hostPort != null) coresAttribs.put(\"hostPort\", hostPort);\n    if (zkClientTimeout != null) coresAttribs.put(\"zkClientTimeout\", Integer.toString(zkClientTimeout));\n    if (hostContext != null) coresAttribs.put(\"hostContext\", hostContext);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n        \n        coreAttribs.put(\"name\", dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name);\n        coreAttribs.put(\"instanceDir\", dcore.getInstanceDir());\n        // write config (if not default)\n        String opt = dcore.getConfigName();\n        if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {\n          coreAttribs.put(\"config\", opt);\n        }\n        // write schema (if not default)\n        opt = dcore.getSchemaName();\n        if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {\n          coreAttribs.put(\"schema\", opt);\n        }\n        opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        opt = dcore.dataDir;\n        if (opt != null) coreAttribs.put(\"dataDir\", opt);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        if (cd != null) {\n          opt = cd.getShardId();\n          if (opt != null) coreAttribs.put(\"shard\", opt);\n          // only write out the collection name if it's not the default (the\n          // core\n          // name)\n          opt = cd.getCollectionName();\n          if (opt != null && !opt.equals(dcore.name)) coreAttribs.put(\n              \"collection\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":["45903437caf2081e259d21447c117144056c6f78","46083459332303d872db23d62e641cc6165fe93c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e635cfcf66f9e8b914c54c24d337820e475f44a5","date":1335303739,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (!defaultCoreName.equals(\"\")) coresAttribs.put(\"defaultCoreName\",\n        defaultCoreName);\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name.equals(\"\") ? defaultCoreName\n            : dcore.name;\n        \n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45903437caf2081e259d21447c117144056c6f78","date":1342651318,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":["4901f8624f774c2b648e66567b63c59e901ac7c8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, \"name\", null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, \"name\", null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(\"name\", coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, \"instanceDir\", instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, \"conf\", configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, \"schema\", schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, \"dataDir\", dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, \"shard\", shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, \"collection\", collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(\"properties\", opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98c6ef0fabf756c297d397f33729ffe46e760a4f","date":1347661885,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46083459332303d872db23d62e641cc6165fe93c","date":1351189543,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":["4901f8624f774c2b648e66567b63c59e901ac7c8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b374d78db8148ec6796fdf37148b33897ab40a8c","date":1351606544,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    \n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        \n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ce60a6712f1e8ef7077bc4051aefc65f457f283","date":1352661483,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33399cc2618223f11ba493f9a3a2026fe05b579","date":1356813042,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_TRANSIENT, Boolean.toString(dcore.isTransient()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01cb64f927c1f8843967e9d4dcd57b4febf22ab1","date":1356978396,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        String ulogDir = dcore.ulogDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_ULOGDIR, ulogDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_TRANSIENT, Boolean.toString(dcore.isTransient()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_TRANSIENT, Boolean.toString(dcore.isTransient()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        String ulogDir = dcore.ulogDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_ULOGDIR, ulogDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_TRANSIENT, Boolean.toString(dcore.isTransient()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (swappableCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"swappableCacheSize\", Integer.toString(swappableCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();\n    \n    synchronized (cores) {\n      for (SolrCore solrCore : cores.values()) {\n        Map<String,String> coreAttribs = new HashMap<String,String>();\n        CoreDescriptor dcore = solrCore.getCoreDescriptor();\n\n        String coreName = dcore.name;\n        Node coreNode = null;\n        \n        if (cfg != null) {\n          NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n              XPathConstants.NODESET);\n          \n          String origCoreName = coreToOrigName.get(solrCore);\n\n          if (origCoreName == null) {\n            origCoreName = coreName;\n          }\n          \n          // look for an existing node\n          \n          // first look for an exact match\n          for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            \n            String name = DOMUtil.getAttr(node, CORE_NAME, null);\n            if (origCoreName.equals(name)) {\n              coreNode = node;\n              if (coreName.equals(origCoreName)) {\n                coreName = name;\n              }\n              break;\n            }\n          }\n          \n          if (coreNode == null) {\n            // see if we match with substitution\n            for (int i = 0; i < nodes.getLength(); i++) {\n              Node node = nodes.item(i);\n              String name = DOMUtil.getAttr(node, CORE_NAME, null);\n              if (origCoreName.equals(DOMUtil.substituteProperty(name,\n                  loader.getCoreProperties()))) {\n                coreNode = node;\n                if (coreName.equals(origCoreName)) {\n                  coreName = name;\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        coreAttribs.put(CORE_NAME, coreName);\n        \n        String instanceDir = dcore.getRawInstanceDir();\n        addCoreProperty(coreAttribs, coreNode, CORE_INSTDIR, instanceDir, null);\n        \n        // write config \n        String configName = dcore.getConfigName();\n        addCoreProperty(coreAttribs, coreNode, CORE_CONFIG, configName, dcore.getDefaultConfigName());\n        \n        // write schema\n        String schema = dcore.getSchemaName();\n        addCoreProperty(coreAttribs, coreNode, CORE_SCHEMA, schema, dcore.getDefaultSchemaName());\n        \n        String dataDir = dcore.dataDir;\n        String ulogDir = dcore.ulogDir;\n        addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_ULOGDIR, ulogDir, null);\n        addCoreProperty(coreAttribs, coreNode, CORE_TRANSIENT, Boolean.toString(dcore.isTransient()), null);\n        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);\n\n        CloudDescriptor cd = dcore.getCloudDescriptor();\n        String shard = null;\n        String roles = null;\n        if (cd != null) {\n          shard = cd.getShardId();\n          roles = cd.getRoles();\n        }\n        addCoreProperty(coreAttribs, coreNode, CORE_SHARD, shard, null);\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_ROLES, roles, null);\n        \n        String collection = null;\n        // only write out the collection name if it's not the default (the\n        // core\n        // name)\n        if (cd != null) {\n          collection = cd.getCollectionName();\n        }\n        \n        addCoreProperty(coreAttribs, coreNode, CORE_COLLECTION, collection, dcore.name);\n        \n        // we don't try and preserve sys prop defs in these\n        String opt = dcore.getPropertiesName();\n        if (opt != null) {\n          coreAttribs.put(CORE_PROPERTIES, opt);\n        }\n        \n        SolrCoreXMLDef solrCoreXMLDef = new SolrCoreXMLDef();\n        solrCoreXMLDef.coreAttribs = coreAttribs;\n        solrCoreXMLDef.coreProperties = dcore.getCoreProperties();\n        solrCoreXMLDefs.add(solrCoreXMLDef);\n      }\n      \n      SolrXMLDef solrXMLDef = new SolrXMLDef();\n      solrXMLDef.coresDefs = solrCoreXMLDefs;\n      solrXMLDef.containerProperties = containerProperties;\n      solrXMLDef.solrAttribs = rootSolrAttribs;\n      solrXMLDef.coresAttribs = coresAttribs;\n      solrXMLSerializer.persistFile(file == null ? configFile : file,\n          solrXMLDef);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9818efa55563ddfecdecafbdd43f4bee9f252e7d","date":1364853872,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, \"transientCacheSize\", Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    if (transientCacheSize != Integer.MAX_VALUE) {\n      coresAttribs.put(\"transientCacheSize\", Integer.toString(transientCacheSize));\n    }\n    \n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e475642767c688ede5728d7918326f70b4e0bf3a","date":1366072489,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    if (cfg != null && cfg.is50OrLater()) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  public void persistFile(File file) {\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, \"hostContext\", this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, \"leaderVoteWait\", this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, \"coreLoadThreads\", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, \"transientCacheSize\", Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0","date":1366659310,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      coreMaps.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    if (cfg != null && cfg.is50OrLater()) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9409650933cc688e77e565092a25e58adfc2e18d","date":1366663164,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      coreMaps.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b29abed5661c7911e4b45d5a3d79a186268e28c4","date":1366675770,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost(), null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\",zkSys.getHostPort(), ZkContainer.DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext(), ZkContainer.DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  //TODO: obsolete in SOLR 5.0\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", this.host, null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", this.hostPort, DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        this.hostContext, DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        this.leaderVoteWait, LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b9c2f673731eb874eddf5c503c3a8e6ed446bc6","date":1367988758,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost(), null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\",zkSys.getHostPort(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost(), null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\",zkSys.getHostPort(), ZkContainer.DEFAULT_HOST_PORT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext(), ZkContainer.DEFAULT_HOST_CONTEXT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc6e48afbb50ae0a22fa76e226f04fd585532938","date":1371429211,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\", Boolean.toString(isPersistent()));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost(), null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\",zkSys.getHostPort(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["f225b9b576dc345ee8c27f91147b4afc0350511c","96a802acd838449b6936d34e464baeeb82f9ef54"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96a802acd838449b6936d34e464baeeb82f9ef54","date":1371519049,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\", Boolean.toString(isPersistent()));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":["dc6e48afbb50ae0a22fa76e226f04fd585532938"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d264f386d864b5751209060e8886ca9845f70469","date":1372172126,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"354983dcdf70c800bf2573d10b54a7391b1dc167","date":1372183171,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7116474e2e390259937401cf928323e0cbc75e60","date":1372780249,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f225b9b576dc345ee8c27f91147b4afc0350511c","date":1373552135,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    /*\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n    */\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, cfg.getUnsubsititutedShardHandlerFactoryPluginNode(), file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, shardHandlerAttrib, shardHandlerProps, file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":["dc6e48afbb50ae0a22fa76e226f04fd585532938"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e764e9a107f93be9fa3c922bc6a197b3eec387e","date":1373560501,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":null,"sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? getConfigFile() : file));\n\n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_SHAREDLIB, \"sharedLib\", this.libDir);\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_PERSISTENT, \"persistent\",\n        Boolean.toString(isPersistent()), \"false\");\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    addAttrib(rootSolrAttribs, ConfigSolr.CfgProp.SOLR_ZKHOST, \"zkHost\", this.zkHost);\n\n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, this.getAdminPath());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA, \"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost());\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\", zkSys.getHostPort());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext());\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, \"genericCoreNodeNames\",\n        Boolean.toString(zkSys.getGenericCoreNodeNames()), \"false\");\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, \"distribUpdateConnTimeout\",\n        Integer.toString(this.distribUpdateConnTimeout), Integer.toString(this.distribUpdateConnTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, \"distribUpdateSoTimeout\",\n        Integer.toString(this.distribUpdateSoTimeout), Integer.toString(this.distribUpdateSoTimeout));\n    addAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, \"managementPath\",\n        this.managementPath);\n\n    // don't forget the logging stuff\n    Map<String, String> loggingAttribs = new HashMap<String, String>();\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null));\n    addAttrib(loggingAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, \"enabled\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, null));\n\n    Map<String, String> watcherAttribs = new HashMap<String, String>();\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, \"size\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, null));\n    addAttrib(watcherAttribs, ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, \"threshold\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null));\n\n\n    /*\n    Map<String, String> shardHandlerAttrib = new HashMap<String, String>();\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, \"class\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CLASS, null));\n    addAttrib(shardHandlerAttrib, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, \"name\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_NAME, null));\n\n    Map<String, String> shardHandlerProps = new HashMap<String, String>();\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, \"connTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_CONNTIMEOUT, null));\n    addAttrib(shardHandlerProps, ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, \"socketTimeout\",\n        cfg.get(ConfigSolr.CfgProp.SOLR_SHARDHANDLERFACTORY_SOCKETTIMEOUT, null));\n    */\n\n    try {\n      solrCores.persistCores(cfg.config.getOriginalConfig(), containerProperties, rootSolrAttribs,coresAttribs,\n          loggingAttribs, watcherAttribs, cfg.getUnsubsititutedShardHandlerFactoryPluginNode(), file, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#persistFile(File).mjava","sourceNew":null,"sourceOld":"  /** Persists the cores config file in a user provided file. */\n  @Deprecated\n  public void persistFile(File file) {\n    assert file != null;\n    // only the old solrxml persists\n    if (cfg != null && !(cfg instanceof ConfigSolrXmlOld)) return;\n\n    log.info(\"Persisting cores config to \" + (file == null ? configFile : file));\n\n    \n    // <solr attrib=\"value\">\n    Map<String,String> rootSolrAttribs = new HashMap<String,String>();\n    if (libDir != null) rootSolrAttribs.put(\"sharedLib\", libDir);\n    rootSolrAttribs.put(\"persistent\", Boolean.toString(isPersistent()));\n    \n    // <solr attrib=\"value\"> <cores attrib=\"value\">\n    Map<String,String> coresAttribs = new HashMap<String,String>();\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINPATH, \"adminPath\", this.adminPath, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ADMINHANDLER, \"adminHandler\", this.adminHandler, null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_SHARESCHEMA,\"shareSchema\",\n        Boolean.toString(this.shareSchema),\n        Boolean.toString(DEFAULT_SHARE_SCHEMA));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOST, \"host\", zkSys.getHost(), null);\n\n    if (! (null == defaultCoreName || defaultCoreName.equals(\"\")) ) {\n      coresAttribs.put(\"defaultCoreName\", defaultCoreName);\n    }\n\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTPORT, \"hostPort\",zkSys.getHostPort(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, \"zkClientTimeout\",\n        intToString(this.zkClientTimeout),\n        Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, \"hostContext\",\n        zkSys.getHostContext(), null);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, \"leaderVoteWait\",\n        zkSys.getLeaderVoteWait(), LEADER_VOTE_WAIT);\n    addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, \"coreLoadThreads\",\n        Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));\n    if (transientCacheSize != Integer.MAX_VALUE) { // This test\n    // is a consequence of testing. I really hate it.\n      addCoresAttrib(coresAttribs, ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, \"transientCacheSize\",\n          Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));\n    }\n\n    try {\n      solrCores.persistCores(origCfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);\n    } catch (XPathExpressionException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","01cb64f927c1f8843967e9d4dcd57b4febf22ab1"],"9b9c2f673731eb874eddf5c503c3a8e6ed446bc6":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"7116474e2e390259937401cf928323e0cbc75e60":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["9b9c2f673731eb874eddf5c503c3a8e6ed446bc6","6e764e9a107f93be9fa3c922bc6a197b3eec387e"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["5ce60a6712f1e8ef7077bc4051aefc65f457f283"],"5ce60a6712f1e8ef7077bc4051aefc65f457f283":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"f225b9b576dc345ee8c27f91147b4afc0350511c":["7116474e2e390259937401cf928323e0cbc75e60"],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["e475642767c688ede5728d7918326f70b4e0bf3a"],"dc6e48afbb50ae0a22fa76e226f04fd585532938":["9b9c2f673731eb874eddf5c503c3a8e6ed446bc6"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["9409650933cc688e77e565092a25e58adfc2e18d"],"fa9fef69a29d64a132d51b8bca52175417bdb0c1":["c26f00b574427b55127e869b935845554afde1fa"],"aba371508186796cc6151d8223a5b4e16d02e26e":["e635cfcf66f9e8b914c54c24d337820e475f44a5","45903437caf2081e259d21447c117144056c6f78"],"9409650933cc688e77e565092a25e58adfc2e18d":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b374d78db8148ec6796fdf37148b33897ab40a8c":["46083459332303d872db23d62e641cc6165fe93c"],"6e764e9a107f93be9fa3c922bc6a197b3eec387e":["f225b9b576dc345ee8c27f91147b4afc0350511c"],"46083459332303d872db23d62e641cc6165fe93c":["98c6ef0fabf756c297d397f33729ffe46e760a4f"],"f2126b84bd093fa3d921582a109a0ee578c28126":["98c6ef0fabf756c297d397f33729ffe46e760a4f","46083459332303d872db23d62e641cc6165fe93c"],"96a802acd838449b6936d34e464baeeb82f9ef54":["dc6e48afbb50ae0a22fa76e226f04fd585532938"],"e635cfcf66f9e8b914c54c24d337820e475f44a5":["4901f8624f774c2b648e66567b63c59e901ac7c8"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b374d78db8148ec6796fdf37148b33897ab40a8c","5ce60a6712f1e8ef7077bc4051aefc65f457f283"],"354983dcdf70c800bf2573d10b54a7391b1dc167":["d264f386d864b5751209060e8886ca9845f70469"],"e475642767c688ede5728d7918326f70b4e0bf3a":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"],"d264f386d864b5751209060e8886ca9845f70469":["96a802acd838449b6936d34e464baeeb82f9ef54"],"01cb64f927c1f8843967e9d4dcd57b4febf22ab1":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["a837c064b67fa63a9394136e31218b908cdcf783"],"4901f8624f774c2b648e66567b63c59e901ac7c8":["fa9fef69a29d64a132d51b8bca52175417bdb0c1"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e635cfcf66f9e8b914c54c24d337820e475f44a5","45903437caf2081e259d21447c117144056c6f78"],"45903437caf2081e259d21447c117144056c6f78":["e635cfcf66f9e8b914c54c24d337820e475f44a5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a837c064b67fa63a9394136e31218b908cdcf783":["01cb64f927c1f8843967e9d4dcd57b4febf22ab1"],"98c6ef0fabf756c297d397f33729ffe46e760a4f":["45903437caf2081e259d21447c117144056c6f78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6e764e9a107f93be9fa3c922bc6a197b3eec387e"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9b9c2f673731eb874eddf5c503c3a8e6ed446bc6":["37a0f60745e53927c4c876cfe5b5a58170f0646c","dc6e48afbb50ae0a22fa76e226f04fd585532938"],"7116474e2e390259937401cf928323e0cbc75e60":["f225b9b576dc345ee8c27f91147b4afc0350511c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c26f00b574427b55127e869b935845554afde1fa":["fa9fef69a29d64a132d51b8bca52175417bdb0c1"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["01cb64f927c1f8843967e9d4dcd57b4febf22ab1"],"5ce60a6712f1e8ef7077bc4051aefc65f457f283":["c33399cc2618223f11ba493f9a3a2026fe05b579","407687e67faf6e1f02a211ca078d8e3eed631027"],"f225b9b576dc345ee8c27f91147b4afc0350511c":["6e764e9a107f93be9fa3c922bc6a197b3eec387e"],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["9409650933cc688e77e565092a25e58adfc2e18d"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["9b9c2f673731eb874eddf5c503c3a8e6ed446bc6"],"dc6e48afbb50ae0a22fa76e226f04fd585532938":["96a802acd838449b6936d34e464baeeb82f9ef54"],"fa9fef69a29d64a132d51b8bca52175417bdb0c1":["4901f8624f774c2b648e66567b63c59e901ac7c8"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"9409650933cc688e77e565092a25e58adfc2e18d":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["5ce60a6712f1e8ef7077bc4051aefc65f457f283","407687e67faf6e1f02a211ca078d8e3eed631027"],"6e764e9a107f93be9fa3c922bc6a197b3eec387e":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46083459332303d872db23d62e641cc6165fe93c":["b374d78db8148ec6796fdf37148b33897ab40a8c","f2126b84bd093fa3d921582a109a0ee578c28126"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"e635cfcf66f9e8b914c54c24d337820e475f44a5":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","45903437caf2081e259d21447c117144056c6f78"],"96a802acd838449b6936d34e464baeeb82f9ef54":["d264f386d864b5751209060e8886ca9845f70469"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"e475642767c688ede5728d7918326f70b4e0bf3a":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"354983dcdf70c800bf2573d10b54a7391b1dc167":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"d264f386d864b5751209060e8886ca9845f70469":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"01cb64f927c1f8843967e9d4dcd57b4febf22ab1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a837c064b67fa63a9394136e31218b908cdcf783"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["7116474e2e390259937401cf928323e0cbc75e60"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["e475642767c688ede5728d7918326f70b4e0bf3a"],"4901f8624f774c2b648e66567b63c59e901ac7c8":["e635cfcf66f9e8b914c54c24d337820e475f44a5"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"45903437caf2081e259d21447c117144056c6f78":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","98c6ef0fabf756c297d397f33729ffe46e760a4f"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a837c064b67fa63a9394136e31218b908cdcf783":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"],"98c6ef0fabf756c297d397f33729ffe46e760a4f":["46083459332303d872db23d62e641cc6165fe93c","f2126b84bd093fa3d921582a109a0ee578c28126"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","aba371508186796cc6151d8223a5b4e16d02e26e","f2126b84bd093fa3d921582a109a0ee578c28126","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}