{"path":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","commits":[{"id":"68c354ba50abc8ed5c5fe98901e61d68f93952bb","date":1479836000,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted, false);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted, false);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (Map.Entry<String, Float> entry : a.fields.entrySet()) {\n\n          Query sub = getFieldQuery(entry.getKey(),queryText,quoted, false);\n          if (null != sub) {\n            if (null != entry.getValue()) {\n              sub = new BoostQuery(sub, entry.getValue());\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted, false);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrPluginUtils.DisjunctionMaxQueryParser#getFieldQuery(String,String,boolean,boolean).mjava","sourceNew":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (Map.Entry<String, Float> entry : a.fields.entrySet()) {\n\n          Query sub = getFieldQuery(entry.getKey(),queryText,quoted, false);\n          if (null != sub) {\n            if (null != entry.getValue()) {\n              sub = new BoostQuery(sub, entry.getValue());\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Delegates to the super class unless the field has been specified\n     * as an alias -- in which case we recurse on each of\n     * the aliased fields, and the results are composed into a\n     * DisjunctionMaxQuery.  (so yes: aliases which point at other\n     * aliases should work)\n     */\n    @Override\n    protected Query getFieldQuery(String field, String queryText, boolean quoted, boolean raw)\n        throws SyntaxError {\n\n      if (aliases.containsKey(field)) {\n\n        Alias a = aliases.get(field);\n\n        List<Query> disjuncts = new ArrayList<>();\n        for (String f : a.fields.keySet()) {\n\n          Query sub = getFieldQuery(f,queryText,quoted, false);\n          if (null != sub) {\n            if (null != a.fields.get(f)) {\n              sub = new BoostQuery(sub, a.fields.get(f));\n            }\n            disjuncts.add(sub);\n          }\n        }\n        return disjuncts.isEmpty()\n            ? null\n            : new DisjunctionMaxQuery(disjuncts, a.tie);\n\n      } else {\n        try {\n          return super.getFieldQuery(field, queryText, quoted, raw);\n        } catch (Exception e) {\n          return null;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"b0b597c65628ca9e73913a07e81691f8229bae35":["68c354ba50abc8ed5c5fe98901e61d68f93952bb","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","727bb765ff2542275f6d31f67be18d7104bae148","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}