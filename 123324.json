{"path":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"/dev/null","sourceNew":"  final void addDocument(Document doc) throws IOException {\n    indexStream.writeLong(fieldsStream.getFilePointer());\n    \n    int storedCount = 0;\n    Enumeration fields  = doc.fields();\n    while (fields.hasMoreElements()) {\n      Field field = (Field)fields.nextElement();\n      if (field.isStored())\n\tstoredCount++;\n    }\n    fieldsStream.writeVInt(storedCount);\n    \n    fields  = doc.fields();\n    while (fields.hasMoreElements()) {\n      Field field = (Field)fields.nextElement();\n      if (field.isStored()) {\n\tfieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n\tbyte bits = 0;\n\tif (field.isTokenized())\n\t  bits |= 1;\n\tfieldsStream.writeByte(bits);\n\n\tfieldsStream.writeString(field.stringValue());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0eacdfc94f700086189bb44f7f73ed9cfd85c75","date":1095252623,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= 1;\n                if (field.isBinary())\n                    bits |= 2;\n                fieldsStream.writeByte(bits);\n\n                if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                } else {\n                    fieldsStream.writeString(field.stringValue());\n                }\n            }\n        }\n    }\n\n","sourceOld":"  final void addDocument(Document doc) throws IOException {\n    indexStream.writeLong(fieldsStream.getFilePointer());\n    \n    int storedCount = 0;\n    Enumeration fields  = doc.fields();\n    while (fields.hasMoreElements()) {\n      Field field = (Field)fields.nextElement();\n      if (field.isStored())\n\tstoredCount++;\n    }\n    fieldsStream.writeVInt(storedCount);\n    \n    fields  = doc.fields();\n    while (fields.hasMoreElements()) {\n      Field field = (Field)fields.nextElement();\n      if (field.isStored()) {\n\tfieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n\tbyte bits = 0;\n\tif (field.isTokenized())\n\t  bits |= 1;\n\tfieldsStream.writeByte(bits);\n\n\tfieldsStream.writeString(field.stringValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3d038c41e70424a134ef69a524f3cc0fb40d854","date":1096548028,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  // check if it is a binary field\n                  if (field.isBinary()) {\n                    data = compress(field.binaryValue());\n                  }\n                  else {\n                    data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= 1;\n                if (field.isBinary())\n                    bits |= 2;\n                fieldsStream.writeByte(bits);\n\n                if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                } else {\n                    fieldsStream.writeString(field.stringValue());\n                }\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c0427a35a68b16ec73d3bf5f27e57719915f166","date":1155449527,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Fieldable field = (Fieldable) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Fieldable field = (Fieldable) fields.nextElement();\n            // if the field as an instanceof FieldsReader.FieldForMerge, we're in merge mode\n            // and field.binaryValue() already returns the compressed value for a field\n            // with isCompressed()==true, so we disable compression in that case\n            boolean disableCompression = (field instanceof FieldsReader.FieldForMerge);\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  \n                  if (disableCompression) {\n                      // optimized case for merging, the data\n                      // is already compressed\n                      data = field.binaryValue();\n                  } else {\n                      // check if it is a binary field\n                      if (field.isBinary()) {\n                        data = compress(field.binaryValue());\n                      }\n                      else {\n                        data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                      }\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Field field = (Field) fields.nextElement();\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  // check if it is a binary field\n                  if (field.isBinary()) {\n                    data = compress(field.binaryValue());\n                  }\n                  else {\n                    data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c205cd73e4706c6feceba2eed84d820ec83e0850","date":1164584418,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Iterator fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            // if the field as an instanceof FieldsReader.FieldForMerge, we're in merge mode\n            // and field.binaryValue() already returns the compressed value for a field\n            // with isCompressed()==true, so we disable compression in that case\n            boolean disableCompression = (field instanceof FieldsReader.FieldForMerge);\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  \n                  if (disableCompression) {\n                      // optimized case for merging, the data\n                      // is already compressed\n                      data = field.binaryValue();\n                  } else {\n                      // check if it is a binary field\n                      if (field.isBinary()) {\n                        data = compress(field.binaryValue());\n                      }\n                      else {\n                        data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                      }\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Enumeration fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Fieldable field = (Fieldable) fields.nextElement();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fields = doc.fields();\n        while (fields.hasMoreElements()) {\n            Fieldable field = (Fieldable) fields.nextElement();\n            // if the field as an instanceof FieldsReader.FieldForMerge, we're in merge mode\n            // and field.binaryValue() already returns the compressed value for a field\n            // with isCompressed()==true, so we disable compression in that case\n            boolean disableCompression = (field instanceof FieldsReader.FieldForMerge);\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  \n                  if (disableCompression) {\n                      // optimized case for merging, the data\n                      // is already compressed\n                      data = field.binaryValue();\n                  } else {\n                      // check if it is a binary field\n                      if (field.isBinary()) {\n                        data = compress(field.binaryValue());\n                      }\n                      else {\n                        data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                      }\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Iterator fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n              writeField(fieldInfos.fieldInfo(field.name()), field);\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Iterator fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            // if the field as an instanceof FieldsReader.FieldForMerge, we're in merge mode\n            // and field.binaryValue() already returns the compressed value for a field\n            // with isCompressed()==true, so we disable compression in that case\n            boolean disableCompression = (field instanceof FieldsReader.FieldForMerge);\n            if (field.isStored()) {\n                fieldsStream.writeVInt(fieldInfos.fieldNumber(field.name()));\n\n                byte bits = 0;\n                if (field.isTokenized())\n                    bits |= FieldsWriter.FIELD_IS_TOKENIZED;\n                if (field.isBinary())\n                    bits |= FieldsWriter.FIELD_IS_BINARY;\n                if (field.isCompressed())\n                    bits |= FieldsWriter.FIELD_IS_COMPRESSED;\n                \n                fieldsStream.writeByte(bits);\n                \n                if (field.isCompressed()) {\n                  // compression is enabled for the current field\n                  byte[] data = null;\n                  \n                  if (disableCompression) {\n                      // optimized case for merging, the data\n                      // is already compressed\n                      data = field.binaryValue();\n                  } else {\n                      // check if it is a binary field\n                      if (field.isBinary()) {\n                        data = compress(field.binaryValue());\n                      }\n                      else {\n                        data = compress(field.stringValue().getBytes(\"UTF-8\"));\n                      }\n                  }\n                  final int len = data.length;\n                  fieldsStream.writeVInt(len);\n                  fieldsStream.writeBytes(data, len);\n                }\n                else {\n                  // compression is disabled for the current field\n                  if (field.isBinary()) {\n                    byte[] data = field.binaryValue();\n                    final int len = data.length;\n                    fieldsStream.writeVInt(len);\n                    fieldsStream.writeBytes(data, len);\n                  }\n                  else {\n                    fieldsStream.writeString(field.stringValue());\n                  }\n                }\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d","date":1255859449,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        List<Fieldable> fields = doc.getFields();\n        for (Fieldable field : fields) {\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        \n\n        for (Fieldable field : fields) {\n            if (field.isStored())\n              writeField(fieldInfos.fieldInfo(field.name()), field);\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        Iterator fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        fieldIterator = doc.getFields().iterator();\n        while (fieldIterator.hasNext()) {\n            Fieldable field = (Fieldable) fieldIterator.next();\n            if (field.isStored())\n              writeField(fieldInfos.fieldInfo(field.name()), field);\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","pathOld":"src/java/org/apache/lucene/index/FieldsWriter#addDocument(Document).mjava","sourceNew":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        List<Fieldable> fields = doc.getFields();\n        for (Fieldable field : fields) {\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        \n\n        for (Fieldable field : fields) {\n            if (field.isStored())\n              writeField(fieldInfos.fieldInfo(field.name()), field);\n        }\n    }\n\n","sourceOld":"    final void addDocument(Document doc) throws IOException {\n        indexStream.writeLong(fieldsStream.getFilePointer());\n\n        int storedCount = 0;\n        List<Fieldable> fields = doc.getFields();\n        for (Fieldable field : fields) {\n            if (field.isStored())\n                storedCount++;\n        }\n        fieldsStream.writeVInt(storedCount);\n\n        \n\n        for (Fieldable field : fields) {\n            if (field.isStored())\n              writeField(fieldInfos.fieldInfo(field.name()), field);\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"0c0427a35a68b16ec73d3bf5f27e57719915f166":["b3d038c41e70424a134ef69a524f3cc0fb40d854"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e0eacdfc94f700086189bb44f7f73ed9cfd85c75":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["c205cd73e4706c6feceba2eed84d820ec83e0850"],"b3d038c41e70424a134ef69a524f3cc0fb40d854":["e0eacdfc94f700086189bb44f7f73ed9cfd85c75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"c205cd73e4706c6feceba2eed84d820ec83e0850":["0c0427a35a68b16ec73d3bf5f27e57719915f166"]},"commit2Childs":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["e0eacdfc94f700086189bb44f7f73ed9cfd85c75"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0c0427a35a68b16ec73d3bf5f27e57719915f166":["c205cd73e4706c6feceba2eed84d820ec83e0850"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"e0eacdfc94f700086189bb44f7f73ed9cfd85c75":["b3d038c41e70424a134ef69a524f3cc0fb40d854"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"b3d038c41e70424a134ef69a524f3cc0fb40d854":["0c0427a35a68b16ec73d3bf5f27e57719915f166"],"c205cd73e4706c6feceba2eed84d820ec83e0850":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}