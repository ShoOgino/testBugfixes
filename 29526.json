{"path":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"953de31d76c9d58f1e3f4e41ff8a48a1529226de","date":1277371072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5e679b9c5f68f1f331de920ae8366af75b44060","date":1295555804,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += similarity.sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += similarity.sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += similarity.sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0952c55e47c70ea2d8c8e2b634da066f9bde4e38","date":1310506639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += docScorer.computeSlopFactor(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += similarity.sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76bdd2a0d65c8a40e657fbefccfc915026e4902b","date":1315464700,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsConflict(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += docScorer.computeSlopFactor(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += docScorer.computeSlopFactor(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9ff635e6838a2facda02727dec5b77d9e64dc4c","date":1316672863,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsConflict(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += docScorer.computeSlopFactor(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":["8a9e385641d717e641408d8fbbc62be8fc766357","12716999e1e8b79bca2fa1f6ec4511c4bfbf6736","e9d9dc36efcf84dcc613e66f8eeef578481dfc8d","20645c714ca2a7b7707c2707d58ee9fa384c7362","0952c55e47c70ea2d8c8e2b634da066f9bde4e38","953de31d76c9d58f1e3f4e41ff8a48a1529226de","3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","0731e137bcbb58121034de6ddaa67332fbe6e5d1","b3e493496c35fb4f17315b8827d1ba1ae1585554","76bdd2a0d65c8a40e657fbefccfc915026e4902b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","sourceOld":"  /**\n   * Score a candidate doc for all slop-valid position-combinations (matches) \n   * encountered while traversing/hopping the PhrasePositions.\n   * <br> The score contribution of a match depends on the distance: \n   * <br> - highest score for distance=0 (exact match).\n   * <br> - score gets lower as distance gets higher.\n   * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n   * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n   * <br>Possibly not all valid combinations are encountered, because for efficiency  \n   * we always propagate the least PhrasePosition. This allows to base on \n   * PriorityQueue and move forward faster. \n   * As result, for example, document \"a b c b a\"\n   * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n   * they really are equivalent. \n   * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n   * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n   * We may want to fix this in the future (currently not, for performance reasons).\n   */\n  @Override\n  protected float phraseFreq() throws IOException {\n    int end = initPhrasePositions();\n    //printPositions(System.err, \"INIT DONE:\");\n    if (end==Integer.MIN_VALUE) {\n      return 0.0f;\n    }\n    \n    float freq = 0.0f;\n    PhrasePositions pp = pq.pop();\n    int matchLength = end - pp.position;\n    int next = pq.size()>0 ? pq.top().position : pp.position;\n    //printQueue(System.err, pp, \"Bef Loop: next=\"+next+\" mlen=\"+end+\"-\"+pp.position+\"=\"+matchLength);\n    while (pp.nextPosition() && (end=advanceRepeats(pp, end)) != Integer.MIN_VALUE)  {\n      if (pp.position > next) {\n        //printQueue(System.err, pp, \"A: >next=\"+next+\" matchLength=\"+matchLength);\n        if (matchLength <= slop) {\n          freq += docScorer.computeSlopFactor(matchLength); // score match\n        }      \n        pq.add(pp);\n        pp = pq.pop();\n        next = pq.size()>0 ? pq.top().position : pp.position;\n        matchLength = end - pp.position;\n        //printQueue(System.err, pp, \"B: >next=\"+next+\" matchLength=\"+matchLength);\n      } else {\n        int matchLength2 = end - pp.position;\n        //printQueue(System.err, pp, \"C: mlen2<mlen: next=\"+next+\" matchLength=\"+matchLength+\" matchLength2=\"+matchLength2);\n        if (matchLength2 < matchLength) {\n          matchLength = matchLength2;\n        }\n      }\n    }\n    if (matchLength <= slop) {\n      freq += docScorer.computeSlopFactor(matchLength); // score match\n    }    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"953de31d76c9d58f1e3f4e41ff8a48a1529226de":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"76bdd2a0d65c8a40e657fbefccfc915026e4902b":["0952c55e47c70ea2d8c8e2b634da066f9bde4e38"],"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["76bdd2a0d65c8a40e657fbefccfc915026e4902b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["953de31d76c9d58f1e3f4e41ff8a48a1529226de","e5e679b9c5f68f1f331de920ae8366af75b44060"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f4e87790277826a2aea119328600dfb07761f32":["9454a6510e2db155fb01faa5c049b06ece95fab9","953de31d76c9d58f1e3f4e41ff8a48a1529226de"],"0952c55e47c70ea2d8c8e2b634da066f9bde4e38":["e5e679b9c5f68f1f331de920ae8366af75b44060"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["953de31d76c9d58f1e3f4e41ff8a48a1529226de"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["5f4e87790277826a2aea119328600dfb07761f32","e5e679b9c5f68f1f331de920ae8366af75b44060"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"953de31d76c9d58f1e3f4e41ff8a48a1529226de":["29ef99d61cda9641b6250bf9567329a6e65f901d","5f4e87790277826a2aea119328600dfb07761f32","e5e679b9c5f68f1f331de920ae8366af75b44060"],"76bdd2a0d65c8a40e657fbefccfc915026e4902b":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"c9ff635e6838a2facda02727dec5b77d9e64dc4c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"0952c55e47c70ea2d8c8e2b634da066f9bde4e38":["76bdd2a0d65c8a40e657fbefccfc915026e4902b"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["29ef99d61cda9641b6250bf9567329a6e65f901d","0952c55e47c70ea2d8c8e2b634da066f9bde4e38","e79a6d080bdd5b2a8f56342cf571b5476de04180"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["953de31d76c9d58f1e3f4e41ff8a48a1529226de","5f4e87790277826a2aea119328600dfb07761f32"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","e79a6d080bdd5b2a8f56342cf571b5476de04180","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}