{"path":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillUsingLengthPrefix4(BytesRef,long).mjava","commits":[{"id":"2d84736c4614acce6720851cbd2c823d7cd516e4","date":1290551630,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillUsingLengthPrefix4(BytesRef,long).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting @ start and fill the\n     * given {@link BytesRef} with the byte slice starting after the length\n     * prefix.\n     * @lucene.internal\n     **/\n    public BytesRef fillUsingLengthPrefix4(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b7ae2d1141dd79feb2c7fbf0ccb84c2ed09b3e21"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","date":1291128345,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillUsingLengthPrefix4(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting @ start and fill the\n     * given {@link BytesRef} with the byte slice starting after the length\n     * prefix.\n     * @lucene.internal\n     **/\n    public BytesRef fillUsingLengthPrefix4(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"2d84736c4614acce6720851cbd2c823d7cd516e4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":[],"2d84736c4614acce6720851cbd2c823d7cd516e4":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2d84736c4614acce6720851cbd2c823d7cd516e4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}