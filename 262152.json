{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","commits":[{"id":"4ee5a5186e7187cd42c6f7ff64b6e7206a780325","date":1372914261,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n    params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n    collectionCmd(zkStateReader.getClusterState(), message, params, results, null);\n\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        Overseer.REMOVECOLLECTION, \"name\", message.getStr(\"name\"));\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n    // wait for a while until we don't see the collection\n    long now = System.currentTimeMillis();\n    long timeout = now + 30000;\n    boolean removed = false;\n    while (System.currentTimeMillis() < timeout) {\n      Thread.sleep(100);\n      removed = !zkStateReader.getClusterState().getCollections().contains(message.getStr(\"name\"));\n      if (removed) {\n        Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n        break;\n      }\n    }\n    if (!removed) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully remove collection: \" + message.getStr(\"name\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n    params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n    collectionCmd(zkStateReader.getClusterState(), message, params, results, null);\n\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        Overseer.REMOVECOLLECTION, \"name\", message.getStr(\"name\"));\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n    // wait for a while until we don't see the collection\n    long now = System.currentTimeMillis();\n    long timeout = now + 30000;\n    boolean removed = false;\n    while (System.currentTimeMillis() < timeout) {\n      Thread.sleep(100);\n      removed = !zkStateReader.getClusterState().getCollections().contains(message.getStr(\"name\"));\n      if (removed) {\n        Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n        break;\n      }\n    }\n    if (!removed) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully remove collection: \" + message.getStr(\"name\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb","date":1376485874,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().getCollections()\n            .contains(message.getStr(\"name\"));\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n    params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n    collectionCmd(zkStateReader.getClusterState(), message, params, results, null);\n\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        Overseer.REMOVECOLLECTION, \"name\", message.getStr(\"name\"));\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n    // wait for a while until we don't see the collection\n    long now = System.currentTimeMillis();\n    long timeout = now + 30000;\n    boolean removed = false;\n    while (System.currentTimeMillis() < timeout) {\n      Thread.sleep(100);\n      removed = !zkStateReader.getClusterState().getCollections().contains(message.getStr(\"name\"));\n      if (removed) {\n        Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n        break;\n      }\n    }\n    if (!removed) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully remove collection: \" + message.getStr(\"name\"));\n    }\n  }\n\n","bugFix":["4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"bugIntro":["06263309947a9804c326e35ce627be8768e123a4","06263309947a9804c326e35ce627be8768e123a4","06263309947a9804c326e35ce627be8768e123a4","06263309947a9804c326e35ce627be8768e123a4","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","2ffd63d34721624b26ed9880b4822f7d0bbbe6dc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().getCollections()\n            .contains(message.getStr(\"name\"));\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n    params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n    collectionCmd(zkStateReader.getClusterState(), message, params, results, null);\n\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        Overseer.REMOVECOLLECTION, \"name\", message.getStr(\"name\"));\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n    // wait for a while until we don't see the collection\n    long now = System.currentTimeMillis();\n    long timeout = now + 30000;\n    boolean removed = false;\n    while (System.currentTimeMillis() < timeout) {\n      Thread.sleep(100);\n      removed = !zkStateReader.getClusterState().getCollections().contains(message.getStr(\"name\"));\n      if (removed) {\n        Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n        break;\n      }\n    }\n    if (!removed) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully remove collection: \" + message.getStr(\"name\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b753f4bd40fd8ec5276ceae15e867d2dceeb5552","date":1387799061,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().getCollections()\n            .contains(message.getStr(\"name\"));\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["2ffd63d34721624b26ed9880b4822f7d0bbbe6dc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd5a9ad98c30992830fb229ec99d26b1bae3b19e","date":1390230278,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(300); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a13eb2cf6af62e53b6a82b328e98f3c77cf5cfa2","date":1390239218,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(300); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVECOLLECTION, \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ffd63d34721624b26ed9880b4822f7d0bbbe6dc","date":1421885455,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(message.getStr(collection));\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + message.getStr(\"name\"));\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb","b753f4bd40fd8ec5276ceae15e867d2dceeb5552"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(\"name\");\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), \"name\", collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      \n    } finally {\n      \n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      collectionCmd(zkStateReader.getClusterState(), message, params, results,\n          null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETE.toLower(), NAME, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n          Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b753f4bd40fd8ec5276ceae15e867d2dceeb5552":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb":["4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["37a0f60745e53927c4c876cfe5b5a58170f0646c","993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"2ffd63d34721624b26ed9880b4822f7d0bbbe6dc":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"a13eb2cf6af62e53b6a82b328e98f3c77cf5cfa2":["dd5a9ad98c30992830fb229ec99d26b1bae3b19e"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["a13eb2cf6af62e53b6a82b328e98f3c77cf5cfa2"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"dd5a9ad98c30992830fb229ec99d26b1bae3b19e":["b753f4bd40fd8ec5276ceae15e867d2dceeb5552"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["2ffd63d34721624b26ed9880b4822f7d0bbbe6dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["2ffd63d34721624b26ed9880b4822f7d0bbbe6dc","1390137e395d2f07f9ba5b8c43d293befe84d563"],"4ee5a5186e7187cd42c6f7ff64b6e7206a780325":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"]},"commit2Childs":{"b753f4bd40fd8ec5276ceae15e867d2dceeb5552":["dd5a9ad98c30992830fb229ec99d26b1bae3b19e"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb":["b753f4bd40fd8ec5276ceae15e867d2dceeb5552","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"2ffd63d34721624b26ed9880b4822f7d0bbbe6dc":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["2ffd63d34721624b26ed9880b4822f7d0bbbe6dc"],"a13eb2cf6af62e53b6a82b328e98f3c77cf5cfa2":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd5a9ad98c30992830fb229ec99d26b1bae3b19e":["a13eb2cf6af62e53b6a82b328e98f3c77cf5cfa2"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"4ee5a5186e7187cd42c6f7ff64b6e7206a780325":["37a0f60745e53927c4c876cfe5b5a58170f0646c","993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}