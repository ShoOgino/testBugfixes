{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc4cbb07b89a0942261a14579fdfc607af58137c","date":1331160678,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a2ba67a463f52915e77a5fd8714aa7d36faf59c","date":1348538193,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73bb5a57dc75b54a39494f99986599cae7dff417","date":1361040620,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method) // explicit\n        || (ft.getNumericType() != null && sf.hasDocValues()); // numeric doc values are per-segment by default\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            if (ft.getNumericType() != null && !sf.multiValued()) {\n              // force numeric faceting\n              if (prefix != null && !prefix.isEmpty()) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n              }\n              counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n            } else {\n              PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n              Executor executor = threads == 0 ? directExecutor : facetExecutor;\n              ps.setNumThreads(threads);\n              counts = ps.getFacetCounts(executor);\n            }\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method) // explicit\n        || (ft.getNumericType() != null && sf.hasDocValues()); // numeric doc values are per-segment by default\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            if (ft.getNumericType() != null && !sf.multiValued()) {\n              // force numeric faceting\n              if (prefix != null && !prefix.isEmpty()) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n              }\n              counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n            } else {\n              PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n              Executor executor = threads == 0 ? directExecutor : facetExecutor;\n              ps.setNumThreads(threads);\n              counts = ps.getFacetCounts(executor);\n            }\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa122aa6bc90e14eb49c0efee7cda631a87d8574","date":1361636893,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method) // explicit\n        || (ft.getNumericType() != null && sf.hasDocValues()); // numeric doc values are per-segment by default\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      // unless the enum method is explicitly specified, use a counting method.\n      if (enumMethod) {\n        counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        if (multiToken) {\n          UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n          counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n        } else {\n          // TODO: future logic could use filters instead of the fieldcache if\n          // the number of terms in the field is small enough.\n          if (per_segment) {\n            if (ft.getNumericType() != null && !sf.multiValued()) {\n              // force numeric faceting\n              if (prefix != null && !prefix.isEmpty()) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n              }\n              counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n            } else {\n              PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n              Executor executor = threads == 0 ? directExecutor : facetExecutor;\n              ps.setNumThreads(threads);\n              counts = ps.getFacetCounts(executor);\n            }\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n\n        }\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c","date":1378490020,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    return getTermCounts(field, this.docs);\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (method == null && ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (ft.getNumericType() != null && sf.hasDocValues()) {\n      // only fcs is able to leverage the numeric field caches\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          if (sf.hasDocValues()) {\n            counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          } else if (multiToken || TrieField.getMainValuePrefix(ft) != null) {\n            UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n            counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n          } else {\n            counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n          }\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepects the appropriate mincount\n   *\n   * @see FacetParams#FACET_MINCOUNT\n   */\n  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    return getTermCounts(field, this.docs);\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    return getTermCounts(field, this.docs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepects the appropriate mincount\n   *\n   * @see FacetParams#FACET_MINCOUNT\n   */\n  public NamedList<Integer> getTermCounts(String field, ParsedParams parsed) throws IOException {\n    Integer mincount = parsed.params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    return getTermCounts(field, mincount, parsed);\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepects the appropriate mincount\n   *\n   * @see FacetParams#FACET_MINCOUNT\n   */\n  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    return getTermCounts(field, this.docs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["fa122aa6bc90e14eb49c0efee7cda631a87d8574"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["c26f00b574427b55127e869b935845554afde1fa","dc4cbb07b89a0942261a14579fdfc607af58137c"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"dc4cbb07b89a0942261a14579fdfc607af58137c":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"fa122aa6bc90e14eb49c0efee7cda631a87d8574":["73bb5a57dc75b54a39494f99986599cae7dff417"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c","73bb5a57dc75b54a39494f99986599cae7dff417"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["dc4cbb07b89a0942261a14579fdfc607af58137c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"73bb5a57dc75b54a39494f99986599cae7dff417":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"92751ba9273251eab6a2e379ec42a1697a32ff96":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"dc4cbb07b89a0942261a14579fdfc607af58137c":["38e3b736c7ca086d61b7dbb841c905ee115490da","7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"c26f00b574427b55127e869b935845554afde1fa":["38e3b736c7ca086d61b7dbb841c905ee115490da","dc4cbb07b89a0942261a14579fdfc607af58137c"],"fa122aa6bc90e14eb49c0efee7cda631a87d8574":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["95303ff3749680c743b9425f9cf99e6e4065e8a8","73bb5a57dc75b54a39494f99986599cae7dff417"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"73bb5a57dc75b54a39494f99986599cae7dff417":["fa122aa6bc90e14eb49c0efee7cda631a87d8574","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","95303ff3749680c743b9425f9cf99e6e4065e8a8","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}