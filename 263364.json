{"path":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < utf16.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, utf16.result[pos]);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(utf16.result, 0, utf16.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < utf16.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, utf16.result[pos]);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(utf16.result, 0, utf16.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"780a676adba1080a3bb08ca427a08ff996227ecd","date":1285561731,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"705cdca081fbf23193d7ff6db22fedef9dd7c54f","date":1285601541,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n\n    while (true) {\n      curGen++;\n      linear = false;\n      state = runAutomaton.getInitialState();\n      // walk the automaton until a character is rejected.\n      for (pos = 0; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if (!backtrack(pos)) /* no more solutions at all */\n          return false;\n        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) \n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","date":1297092846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          linear = true;\n          infinitePosition = pos;\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"705cdca081fbf23193d7ff6db22fedef9dd7c54f":["780a676adba1080a3bb08ca427a08ff996227ecd"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["705cdca081fbf23193d7ff6db22fedef9dd7c54f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["705cdca081fbf23193d7ff6db22fedef9dd7c54f","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","705cdca081fbf23193d7ff6db22fedef9dd7c54f"],"780a676adba1080a3bb08ca427a08ff996227ecd":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60ba444201d2570214b6fcf1d15600dc1a01f548"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"705cdca081fbf23193d7ff6db22fedef9dd7c54f":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","29ef99d61cda9641b6250bf9567329a6e65f901d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["60ba444201d2570214b6fcf1d15600dc1a01f548","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","780a676adba1080a3bb08ca427a08ff996227ecd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"780a676adba1080a3bb08ca427a08ff996227ecd":["705cdca081fbf23193d7ff6db22fedef9dd7c54f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}